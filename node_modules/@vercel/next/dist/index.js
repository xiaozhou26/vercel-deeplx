"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/path-to-regexp@6.1.0/node_modules/path-to-regexp/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/.pnpm/path-to-regexp@6.1.0/node_modules/path-to-regexp/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function lexer(str) {
      var tokens = [];
      var i = 0;
      while (i < str.length) {
        var char = str[i];
        if (char === "*" || char === "+" || char === "?") {
          tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
          continue;
        }
        if (char === "\\") {
          tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
          continue;
        }
        if (char === "{") {
          tokens.push({ type: "OPEN", index: i, value: str[i++] });
          continue;
        }
        if (char === "}") {
          tokens.push({ type: "CLOSE", index: i, value: str[i++] });
          continue;
        }
        if (char === ":") {
          var name = "";
          var j = i + 1;
          while (j < str.length) {
            var code = str.charCodeAt(j);
            if (
              // `0-9`
              code >= 48 && code <= 57 || // `A-Z`
              code >= 65 && code <= 90 || // `a-z`
              code >= 97 && code <= 122 || // `_`
              code === 95
            ) {
              name += str[j++];
              continue;
            }
            break;
          }
          if (!name)
            throw new TypeError("Missing parameter name at " + i);
          tokens.push({ type: "NAME", index: i, value: name });
          i = j;
          continue;
        }
        if (char === "(") {
          var count = 1;
          var pattern = "";
          var j = i + 1;
          if (str[j] === "?") {
            throw new TypeError('Pattern cannot start with "?" at ' + j);
          }
          while (j < str.length) {
            if (str[j] === "\\") {
              pattern += str[j++] + str[j++];
              continue;
            }
            if (str[j] === ")") {
              count--;
              if (count === 0) {
                j++;
                break;
              }
            } else if (str[j] === "(") {
              count++;
              if (str[j + 1] !== "?") {
                throw new TypeError("Capturing groups are not allowed at " + j);
              }
            }
            pattern += str[j++];
          }
          if (count)
            throw new TypeError("Unbalanced pattern at " + i);
          if (!pattern)
            throw new TypeError("Missing pattern at " + i);
          tokens.push({ type: "PATTERN", index: i, value: pattern });
          i = j;
          continue;
        }
        tokens.push({ type: "CHAR", index: i, value: str[i++] });
      }
      tokens.push({ type: "END", index: i, value: "" });
      return tokens;
    }
    function parse(str, options) {
      if (options === void 0) {
        options = {};
      }
      var tokens = lexer(str);
      var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
      var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
      var result = [];
      var key = 0;
      var i = 0;
      var path5 = "";
      var tryConsume = function(type) {
        if (i < tokens.length && tokens[i].type === type)
          return tokens[i++].value;
      };
      var mustConsume = function(type) {
        var value2 = tryConsume(type);
        if (value2 !== void 0)
          return value2;
        var _a2 = tokens[i], nextType = _a2.type, index = _a2.index;
        throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
      };
      var consumeText = function() {
        var result2 = "";
        var value2;
        while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
          result2 += value2;
        }
        return result2;
      };
      while (i < tokens.length) {
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
          var prefix = char || "";
          if (prefixes.indexOf(prefix) === -1) {
            path5 += prefix;
            prefix = "";
          }
          if (path5) {
            result.push(path5);
            path5 = "";
          }
          result.push({
            name: name || key++,
            prefix,
            suffix: "",
            pattern: pattern || defaultPattern,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
          path5 += value;
          continue;
        }
        if (path5) {
          result.push(path5);
          path5 = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
          var prefix = consumeText();
          var name_1 = tryConsume("NAME") || "";
          var pattern_1 = tryConsume("PATTERN") || "";
          var suffix = consumeText();
          mustConsume("CLOSE");
          result.push({
            name: name_1 || (pattern_1 ? key++ : ""),
            pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
            prefix,
            suffix,
            modifier: tryConsume("MODIFIER") || ""
          });
          continue;
        }
        mustConsume("END");
      }
      return result;
    }
    exports.parse = parse;
    function compile(str, options) {
      return tokensToFunction(parse(str, options), options);
    }
    exports.compile = compile;
    function tokensToFunction(tokens, options) {
      if (options === void 0) {
        options = {};
      }
      var reFlags = flags(options);
      var _a = options.encode, encode = _a === void 0 ? function(x) {
        return x;
      } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
      var matches = tokens.map(function(token) {
        if (typeof token === "object") {
          return new RegExp("^(?:" + token.pattern + ")$", reFlags);
        }
      });
      return function(data) {
        var path5 = "";
        for (var i = 0; i < tokens.length; i++) {
          var token = tokens[i];
          if (typeof token === "string") {
            path5 += token;
            continue;
          }
          var value = data ? data[token.name] : void 0;
          var optional = token.modifier === "?" || token.modifier === "*";
          var repeat = token.modifier === "*" || token.modifier === "+";
          if (Array.isArray(value)) {
            if (!repeat) {
              throw new TypeError('Expected "' + token.name + '" to not repeat, but got an array');
            }
            if (value.length === 0) {
              if (optional)
                continue;
              throw new TypeError('Expected "' + token.name + '" to not be empty');
            }
            for (var j = 0; j < value.length; j++) {
              var segment = encode(value[j], token);
              if (validate && !matches[i].test(segment)) {
                throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
              }
              path5 += token.prefix + segment + token.suffix;
            }
            continue;
          }
          if (typeof value === "string" || typeof value === "number") {
            var segment = encode(String(value), token);
            if (validate && !matches[i].test(segment)) {
              throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but got "' + segment + '"');
            }
            path5 += token.prefix + segment + token.suffix;
            continue;
          }
          if (optional)
            continue;
          var typeOfMessage = repeat ? "an array" : "a string";
          throw new TypeError('Expected "' + token.name + '" to be ' + typeOfMessage);
        }
        return path5;
      };
    }
    exports.tokensToFunction = tokensToFunction;
    function match(str, options) {
      var keys = [];
      var re = pathToRegexp(str, keys, options);
      return regexpToFunction(re, keys, options);
    }
    exports.match = match;
    function regexpToFunction(re, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.decode, decode = _a === void 0 ? function(x) {
        return x;
      } : _a;
      return function(pathname) {
        var m = re.exec(pathname);
        if (!m)
          return false;
        var path5 = m[0], index = m.index;
        var params = /* @__PURE__ */ Object.create(null);
        var _loop_1 = function(i2) {
          if (m[i2] === void 0)
            return "continue";
          var key = keys[i2 - 1];
          if (key.modifier === "*" || key.modifier === "+") {
            params[key.name] = m[i2].split(key.prefix + key.suffix).map(function(value) {
              return decode(value, key);
            });
          } else {
            params[key.name] = decode(m[i2], key);
          }
        };
        for (var i = 1; i < m.length; i++) {
          _loop_1(i);
        }
        return { path: path5, index, params };
      };
    }
    exports.regexpToFunction = regexpToFunction;
    function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
    }
    function flags(options) {
      return options && options.sensitive ? "" : "i";
    }
    function regexpToRegexp(path5, keys) {
      if (!keys)
        return path5;
      var groups = path5.source.match(/\((?!\?)/g);
      if (groups) {
        for (var i = 0; i < groups.length; i++) {
          keys.push({
            name: i,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
          });
        }
      }
      return path5;
    }
    function arrayToRegexp(paths, keys, options) {
      var parts = paths.map(function(path5) {
        return pathToRegexp(path5, keys, options).source;
      });
      return new RegExp("(?:" + parts.join("|") + ")", flags(options));
    }
    function stringToRegexp(path5, keys, options) {
      return tokensToRegexp(parse(path5, options), keys, options);
    }
    function tokensToRegexp(tokens, keys, options) {
      if (options === void 0) {
        options = {};
      }
      var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function(x) {
        return x;
      } : _d;
      var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
      var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
      var route = start ? "^" : "";
      for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
        var token = tokens_1[_i];
        if (typeof token === "string") {
          route += escapeString(encode(token));
        } else {
          var prefix = escapeString(encode(token.prefix));
          var suffix = escapeString(encode(token.suffix));
          if (token.pattern) {
            if (keys)
              keys.push(token);
            if (prefix || suffix) {
              if (token.modifier === "+" || token.modifier === "*") {
                var mod = token.modifier === "*" ? "?" : "";
                route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
              } else {
                route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
              }
            } else {
              route += "(" + token.pattern + ")" + token.modifier;
            }
          } else {
            route += "(?:" + prefix + suffix + ")" + token.modifier;
          }
        }
      }
      if (end) {
        if (!strict)
          route += delimiter + "?";
        route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
      } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string" ? delimiter.indexOf(endToken[endToken.length - 1]) > -1 : (
          // tslint:disable-next-line
          endToken === void 0
        );
        if (!strict) {
          route += "(?:" + delimiter + "(?=" + endsWith + "))?";
        }
        if (!isEndDelimited) {
          route += "(?=" + delimiter + "|" + endsWith + ")";
        }
      }
      return new RegExp(route, flags(options));
    }
    exports.tokensToRegexp = tokensToRegexp;
    function pathToRegexp(path5, keys, options) {
      if (path5 instanceof RegExp)
        return regexpToRegexp(path5, keys);
      if (Array.isArray(path5))
        return arrayToRegexp(path5, keys, options);
      return stringToRegexp(path5, keys, options);
    }
    exports.pathToRegexp = pathToRegexp;
  }
});

// ../routing-utils/dist/superstatic.js
var require_superstatic = __commonJS({
  "../routing-utils/dist/superstatic.js"(exports, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var superstatic_exports = {};
    __export2(superstatic_exports, {
      collectHasSegments: () => collectHasSegments,
      convertCleanUrls: () => convertCleanUrls,
      convertHeaders: () => convertHeaders2,
      convertRedirects: () => convertRedirects2,
      convertRewrites: () => convertRewrites2,
      convertTrailingSlash: () => convertTrailingSlash,
      getCleanUrls: () => getCleanUrls,
      sourceToRegex: () => sourceToRegex
    });
    module2.exports = __toCommonJS2(superstatic_exports);
    var import_url3 = require("url");
    var import_path_to_regexp = require_dist();
    var UN_NAMED_SEGMENT = "__UN_NAMED_SEGMENT__";
    function getCleanUrls(filePaths) {
      const htmlFiles = filePaths.map(toRoute).filter((f) => f.endsWith(".html")).map((f) => ({
        html: f,
        clean: f.slice(0, -5)
      }));
      return htmlFiles;
    }
    function convertCleanUrls(cleanUrls, trailingSlash, status = 308) {
      const routes = [];
      if (cleanUrls) {
        const loc = trailingSlash ? "/$1/" : "/$1";
        routes.push({
          src: "^/(?:(.+)/)?index(?:\\.html)?/?$",
          headers: { Location: loc },
          status
        });
        routes.push({
          src: "^/(.*)\\.html/?$",
          headers: { Location: loc },
          status
        });
      }
      return routes;
    }
    function convertRedirects2(redirects, defaultStatus = 308) {
      return redirects.map((r) => {
        const { src, segments } = sourceToRegex(r.source);
        const hasSegments = collectHasSegments(r.has);
        normalizeHasKeys(r.has);
        normalizeHasKeys(r.missing);
        try {
          const loc = replaceSegments(segments, hasSegments, r.destination, true);
          let status;
          if (typeof r.permanent === "boolean") {
            status = r.permanent ? 308 : 307;
          } else if (r.statusCode) {
            status = r.statusCode;
          } else {
            status = defaultStatus;
          }
          const route = {
            src,
            headers: { Location: loc },
            status
          };
          if (r.has) {
            route.has = r.has;
          }
          if (r.missing) {
            route.missing = r.missing;
          }
          return route;
        } catch (e) {
          throw new Error(`Failed to parse redirect: ${JSON.stringify(r)}`);
        }
      });
    }
    function convertRewrites2(rewrites, internalParamNames) {
      return rewrites.map((r) => {
        const { src, segments } = sourceToRegex(r.source);
        const hasSegments = collectHasSegments(r.has);
        normalizeHasKeys(r.has);
        normalizeHasKeys(r.missing);
        try {
          const dest = replaceSegments(
            segments,
            hasSegments,
            r.destination,
            false,
            internalParamNames
          );
          const route = { src, dest, check: true };
          if (r.has) {
            route.has = r.has;
          }
          if (r.missing) {
            route.missing = r.missing;
          }
          if (r.statusCode) {
            route.status = r.statusCode;
          }
          return route;
        } catch (e) {
          throw new Error(`Failed to parse rewrite: ${JSON.stringify(r)}`);
        }
      });
    }
    function convertHeaders2(headers) {
      return headers.map((h) => {
        const obj = {};
        const { src, segments } = sourceToRegex(h.source);
        const hasSegments = collectHasSegments(h.has);
        normalizeHasKeys(h.has);
        normalizeHasKeys(h.missing);
        const namedSegments = segments.filter((name) => name !== UN_NAMED_SEGMENT);
        const indexes = {};
        segments.forEach((name, index) => {
          indexes[name] = toSegmentDest(index);
        });
        hasSegments.forEach((name) => {
          indexes[name] = "$" + name;
        });
        h.headers.forEach(({ key, value }) => {
          if (namedSegments.length > 0 || hasSegments.length > 0) {
            if (key.includes(":")) {
              key = safelyCompile(key, indexes);
            }
            if (value.includes(":")) {
              value = safelyCompile(value, indexes);
            }
          }
          obj[key] = value;
        });
        const route = {
          src,
          headers: obj,
          continue: true
        };
        if (h.has) {
          route.has = h.has;
        }
        if (h.missing) {
          route.missing = h.missing;
        }
        return route;
      });
    }
    function convertTrailingSlash(enable, status = 308) {
      const routes = [];
      if (enable) {
        routes.push({
          src: "^/\\.well-known(?:/.*)?$"
        });
        routes.push({
          src: "^/((?:[^/]+/)*[^/\\.]+)$",
          headers: { Location: "/$1/" },
          status
        });
        routes.push({
          src: "^/((?:[^/]+/)*[^/]+\\.\\w+)/$",
          headers: { Location: "/$1" },
          status
        });
      } else {
        routes.push({
          src: "^/(.*)\\/$",
          headers: { Location: "/$1" },
          status
        });
      }
      return routes;
    }
    function sourceToRegex(source) {
      const keys = [];
      const r = (0, import_path_to_regexp.pathToRegexp)(source, keys, {
        strict: true,
        sensitive: true,
        delimiter: "/"
      });
      const segments = keys.map((k) => k.name).map((name) => {
        if (typeof name !== "string") {
          return UN_NAMED_SEGMENT;
        }
        return name;
      });
      return { src: r.source, segments };
    }
    var namedGroupsRegex = /\(\?<([a-zA-Z][a-zA-Z0-9]*)>/g;
    var normalizeHasKeys = (hasItems = []) => {
      for (const hasItem of hasItems) {
        if ("key" in hasItem && hasItem.type === "header") {
          hasItem.key = hasItem.key.toLowerCase();
        }
      }
      return hasItems;
    };
    function collectHasSegments(has) {
      const hasSegments = /* @__PURE__ */ new Set();
      for (const hasItem of has || []) {
        if (!hasItem.value && "key" in hasItem) {
          hasSegments.add(hasItem.key);
        }
        if (hasItem.value) {
          for (const match of hasItem.value.matchAll(namedGroupsRegex)) {
            if (match[1]) {
              hasSegments.add(match[1]);
            }
          }
          if (hasItem.type === "host") {
            hasSegments.add("host");
          }
        }
      }
      return [...hasSegments];
    }
    var escapeSegment = (str, segmentName) => str.replace(new RegExp(`:${segmentName}`, "g"), `__ESC_COLON_${segmentName}`);
    var unescapeSegments = (str) => str.replace(/__ESC_COLON_/gi, ":");
    function replaceSegments(segments, hasItemSegments, destination, isRedirect, internalParamNames) {
      const namedSegments = segments.filter((name) => name !== UN_NAMED_SEGMENT);
      const canNeedReplacing = destination.includes(":") && namedSegments.length > 0 || hasItemSegments.length > 0 || !isRedirect;
      if (!canNeedReplacing) {
        return destination;
      }
      let escapedDestination = destination;
      const indexes = {};
      segments.forEach((name, index) => {
        indexes[name] = toSegmentDest(index);
        escapedDestination = escapeSegment(escapedDestination, name);
      });
      hasItemSegments.forEach((name) => {
        indexes[name] = "$" + name;
        escapedDestination = escapeSegment(escapedDestination, name);
      });
      const parsedDestination = (0, import_url3.parse)(escapedDestination, true);
      delete parsedDestination.href;
      delete parsedDestination.path;
      delete parsedDestination.search;
      delete parsedDestination.host;
      let { pathname, hash, query, hostname, ...rest } = parsedDestination;
      pathname = unescapeSegments(pathname || "");
      hash = unescapeSegments(hash || "");
      hostname = unescapeSegments(hostname || "");
      let destParams = /* @__PURE__ */ new Set();
      const pathnameKeys = [];
      const hashKeys = [];
      const hostnameKeys = [];
      try {
        (0, import_path_to_regexp.pathToRegexp)(pathname, pathnameKeys);
        (0, import_path_to_regexp.pathToRegexp)(hash || "", hashKeys);
        (0, import_path_to_regexp.pathToRegexp)(hostname || "", hostnameKeys);
      } catch (_) {
      }
      destParams = new Set(
        [...pathnameKeys, ...hashKeys, ...hostnameKeys].map((key) => key.name).filter((val) => typeof val === "string")
      );
      pathname = safelyCompile(pathname, indexes, true);
      hash = hash ? safelyCompile(hash, indexes, true) : null;
      hostname = hostname ? safelyCompile(hostname, indexes, true) : null;
      for (const [key, strOrArray] of Object.entries(query)) {
        if (Array.isArray(strOrArray)) {
          query[key] = strOrArray.map(
            (str) => safelyCompile(unescapeSegments(str), indexes, true)
          );
        } else {
          query[key] = safelyCompile(
            unescapeSegments(strOrArray),
            indexes,
            true
          );
        }
      }
      const paramKeys = Object.keys(indexes);
      const needsQueryUpdating = (
        // we do not consider an internal param since it is added automatically
        !isRedirect && !paramKeys.some(
          (param) => !(internalParamNames && internalParamNames.includes(param)) && destParams.has(param)
        )
      );
      if (needsQueryUpdating) {
        for (const param of paramKeys) {
          if (!(param in query) && param !== UN_NAMED_SEGMENT) {
            query[param] = indexes[param];
          }
        }
      }
      destination = (0, import_url3.format)({
        ...rest,
        hostname,
        pathname,
        query,
        hash
      });
      return destination.replace(/%24/g, "$");
    }
    function safelyCompile(value, indexes, attemptDirectCompile) {
      if (!value) {
        return value;
      }
      if (attemptDirectCompile) {
        try {
          return (0, import_path_to_regexp.compile)(value, { validate: false })(indexes);
        } catch (e) {
        }
      }
      for (const key of Object.keys(indexes)) {
        if (value.includes(`:${key}`)) {
          value = value.replace(
            new RegExp(`:${key}\\*`, "g"),
            `:${key}--ESCAPED_PARAM_ASTERISK`
          ).replace(
            new RegExp(`:${key}\\?`, "g"),
            `:${key}--ESCAPED_PARAM_QUESTION`
          ).replace(new RegExp(`:${key}\\+`, "g"), `:${key}--ESCAPED_PARAM_PLUS`).replace(
            new RegExp(`:${key}(?!\\w)`, "g"),
            `--ESCAPED_PARAM_COLON${key}`
          );
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISK/g, "*");
      return (0, import_path_to_regexp.compile)(`/${value}`, { validate: false })(indexes).slice(1);
    }
    function toSegmentDest(index) {
      const i = index + 1;
      return "$" + i.toString();
    }
    function toRoute(filePath) {
      return filePath.startsWith("/") ? filePath : "/" + filePath;
    }
  }
});

// ../../node_modules/.pnpm/async-sema@3.0.1/node_modules/async-sema/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/async-sema@3.0.1/node_modules/async-sema/lib/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (let j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function pow2AtLeast(n) {
      n = n >>> 0;
      n = n - 1;
      n = n | n >> 1;
      n = n | n >> 2;
      n = n | n >> 4;
      n = n | n >> 8;
      n = n | n >> 16;
      return n + 1;
    }
    function getCapacity(capacity) {
      return pow2AtLeast(Math.min(Math.max(16, capacity), 1073741824));
    }
    var Deque = class {
      constructor(capacity) {
        this._capacity = getCapacity(capacity);
        this._length = 0;
        this._front = 0;
        this.arr = [];
      }
      push(item) {
        const length = this._length;
        this.checkCapacity(length + 1);
        const i = this._front + length & this._capacity - 1;
        this.arr[i] = item;
        this._length = length + 1;
        return length + 1;
      }
      pop() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const i = this._front + length - 1 & this._capacity - 1;
        const ret = this.arr[i];
        this.arr[i] = void 0;
        this._length = length - 1;
        return ret;
      }
      shift() {
        const length = this._length;
        if (length === 0) {
          return void 0;
        }
        const front = this._front;
        const ret = this.arr[front];
        this.arr[front] = void 0;
        this._front = front + 1 & this._capacity - 1;
        this._length = length - 1;
        return ret;
      }
      get length() {
        return this._length;
      }
      checkCapacity(size) {
        if (this._capacity < size) {
          this.resizeTo(getCapacity(this._capacity * 1.5 + 16));
        }
      }
      resizeTo(capacity) {
        const oldCapacity = this._capacity;
        this._capacity = capacity;
        const front = this._front;
        const length = this._length;
        if (front + length > oldCapacity) {
          const moveItemsCount = front + length & oldCapacity - 1;
          arrayMove(this.arr, 0, this.arr, oldCapacity, moveItemsCount);
        }
      }
    };
    var ReleaseEmitter = class extends events_1.default {
    };
    function isFn(x) {
      return typeof x === "function";
    }
    function defaultInit() {
      return "1";
    }
    var Sema4 = class {
      constructor(nr, { initFn = defaultInit, pauseFn, resumeFn, capacity = 10 } = {}) {
        if (isFn(pauseFn) !== isFn(resumeFn)) {
          throw new Error("pauseFn and resumeFn must be both set for pausing");
        }
        this.nrTokens = nr;
        this.free = new Deque(nr);
        this.waiting = new Deque(capacity);
        this.releaseEmitter = new ReleaseEmitter();
        this.noTokens = initFn === defaultInit;
        this.pauseFn = pauseFn;
        this.resumeFn = resumeFn;
        this.paused = false;
        this.releaseEmitter.on("release", (token) => {
          const p = this.waiting.shift();
          if (p) {
            p.resolve(token);
          } else {
            if (this.resumeFn && this.paused) {
              this.paused = false;
              this.resumeFn();
            }
            this.free.push(token);
          }
        });
        for (let i = 0; i < nr; i++) {
          this.free.push(initFn());
        }
      }
      async acquire() {
        let token = this.free.pop();
        if (token !== void 0) {
          return token;
        }
        return new Promise((resolve, reject) => {
          if (this.pauseFn && !this.paused) {
            this.paused = true;
            this.pauseFn();
          }
          this.waiting.push({ resolve, reject });
        });
      }
      release(token) {
        this.releaseEmitter.emit("release", this.noTokens ? "1" : token);
      }
      drain() {
        const a = new Array(this.nrTokens);
        for (let i = 0; i < this.nrTokens; i++) {
          a[i] = this.acquire();
        }
        return Promise.all(a);
      }
      nrWaiting() {
        return this.waiting.length;
      }
    };
    exports.Sema = Sema4;
    function RateLimit(rps, { timeUnit = 1e3, uniformDistribution = false } = {}) {
      const sema = new Sema4(uniformDistribution ? 1 : rps);
      const delay = uniformDistribution ? timeUnit / rps : timeUnit;
      return async function rl() {
        await sema.acquire();
        setTimeout(() => sema.release(), delay);
      };
    }
    exports.RateLimit = RateLimit;
  }
});

// ../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../../node_modules/.pnpm/escape-string-regexp@2.0.0/node_modules/escape-string-regexp/index.js"(exports, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// ../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js
var require_p_try = __commonJS({
  "../../node_modules/.pnpm/p-try@2.2.0/node_modules/p-try/index.js"(exports, module2) {
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve) => {
      resolve(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// ../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "../../node_modules/.pnpm/p-limit@2.3.0/node_modules/p-limit/index.js"(exports, module2) {
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// ../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js
var require_p_locate = __commonJS({
  "../../node_modules/.pnpm/p-locate@4.1.0/node_modules/p-locate/index.js"(exports, module2) {
    "use strict";
    var pLimit = require_p_limit();
    var EndError = class extends Error {
      constructor(value) {
        super();
        this.value = value;
      }
    };
    var testElement = async (element, tester) => tester(await element);
    var finder = async (element) => {
      const values = await Promise.all(element);
      if (values[1] === true) {
        throw new EndError(values[0]);
      }
      return false;
    };
    var pLocate = async (iterable, tester, options) => {
      options = {
        concurrency: Infinity,
        preserveOrder: true,
        ...options
      };
      const limit = pLimit(options.concurrency);
      const items = [...iterable].map((element) => [element, limit(testElement, element, tester)]);
      const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);
      try {
        await Promise.all(items.map((element) => checkLimit(finder, element)));
      } catch (error) {
        if (error instanceof EndError) {
          return error.value;
        }
        throw error;
      }
    };
    module2.exports = pLocate;
    module2.exports.default = pLocate;
  }
});

// ../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js
var require_locate_path = __commonJS({
  "../../node_modules/.pnpm/locate-path@5.0.0/node_modules/locate-path/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var fs5 = require("fs");
    var { promisify: promisify2 } = require("util");
    var pLocate = require_p_locate();
    var fsStat = promisify2(fs5.stat);
    var fsLStat = promisify2(fs5.lstat);
    var typeMappings = {
      directory: "isDirectory",
      file: "isFile"
    };
    function checkType({ type }) {
      if (type in typeMappings) {
        return;
      }
      throw new Error(`Invalid type specified: ${type}`);
    }
    var matchType = (type, stat2) => type === void 0 || stat2[typeMappings[type]]();
    module2.exports = async (paths, options) => {
      options = {
        cwd: process.cwd(),
        type: "file",
        allowSymlinks: true,
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fsStat : fsLStat;
      return pLocate(paths, async (path_) => {
        try {
          const stat2 = await statFn(path5.resolve(options.cwd, path_));
          return matchType(options.type, stat2);
        } catch (_) {
          return false;
        }
      }, options);
    };
    module2.exports.sync = (paths, options) => {
      options = {
        cwd: process.cwd(),
        allowSymlinks: true,
        type: "file",
        ...options
      };
      checkType(options);
      const statFn = options.allowSymlinks ? fs5.statSync : fs5.lstatSync;
      for (const path_ of paths) {
        try {
          const stat2 = statFn(path5.resolve(options.cwd, path_));
          if (matchType(options.type, stat2)) {
            return path_;
          }
        } catch (_) {
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js
var require_path_exists = __commonJS({
  "../../node_modules/.pnpm/path-exists@4.0.0/node_modules/path-exists/index.js"(exports, module2) {
    "use strict";
    var fs5 = require("fs");
    var { promisify: promisify2 } = require("util");
    var pAccess = promisify2(fs5.access);
    module2.exports = async (path5) => {
      try {
        await pAccess(path5);
        return true;
      } catch (_) {
        return false;
      }
    };
    module2.exports.sync = (path5) => {
      try {
        fs5.accessSync(path5);
        return true;
      } catch (_) {
        return false;
      }
    };
  }
});

// ../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js
var require_find_up = __commonJS({
  "../../node_modules/.pnpm/find-up@4.1.0/node_modules/find-up/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var locatePath = require_locate_path();
    var pathExists2 = require_path_exists();
    var stop = Symbol("findUp.stop");
    module2.exports = async (name, options = {}) => {
      let directory = path5.resolve(options.cwd || "");
      const { root } = path5.parse(directory);
      const paths = [].concat(name);
      const runMatcher = async (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath(paths, locateOptions);
        }
        const foundPath = await name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = await runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path5.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path5.dirname(directory);
      }
    };
    module2.exports.sync = (name, options = {}) => {
      let directory = path5.resolve(options.cwd || "");
      const { root } = path5.parse(directory);
      const paths = [].concat(name);
      const runMatcher = (locateOptions) => {
        if (typeof name !== "function") {
          return locatePath.sync(paths, locateOptions);
        }
        const foundPath = name(locateOptions.cwd);
        if (typeof foundPath === "string") {
          return locatePath.sync([foundPath], locateOptions);
        }
        return foundPath;
      };
      while (true) {
        const foundPath = runMatcher({ ...options, cwd: directory });
        if (foundPath === stop) {
          return;
        }
        if (foundPath) {
          return path5.resolve(directory, foundPath);
        }
        if (directory === root) {
          return;
        }
        directory = path5.dirname(directory);
      }
    };
    module2.exports.exists = pathExists2;
    module2.exports.sync.exists = pathExists2.sync;
    module2.exports.stop = stop;
  }
});

// ../../node_modules/.pnpm/universalify@0.1.2/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../../node_modules/.pnpm/universalify@0.1.2/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function() {
        if (typeof arguments[arguments.length - 1] === "function")
          fn.apply(this, arguments);
        else {
          return new Promise((resolve, reject) => {
            arguments[arguments.length] = (err, res) => {
              if (err)
                return reject(err);
              resolve(res);
            };
            arguments.length++;
            fn.apply(this, arguments);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, arguments);
        else
          fn.apply(this, arguments).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs5) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs5);
      }
      if (!fs5.lutimes) {
        patchLutimes(fs5);
      }
      fs5.chown = chownFix(fs5.chown);
      fs5.fchown = chownFix(fs5.fchown);
      fs5.lchown = chownFix(fs5.lchown);
      fs5.chmod = chmodFix(fs5.chmod);
      fs5.fchmod = chmodFix(fs5.fchmod);
      fs5.lchmod = chmodFix(fs5.lchmod);
      fs5.chownSync = chownFixSync(fs5.chownSync);
      fs5.fchownSync = chownFixSync(fs5.fchownSync);
      fs5.lchownSync = chownFixSync(fs5.lchownSync);
      fs5.chmodSync = chmodFixSync(fs5.chmodSync);
      fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
      fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
      fs5.stat = statFix(fs5.stat);
      fs5.fstat = statFix(fs5.fstat);
      fs5.lstat = statFix(fs5.lstat);
      fs5.statSync = statFixSync(fs5.statSync);
      fs5.fstatSync = statFixSync(fs5.fstatSync);
      fs5.lstatSync = statFixSync(fs5.lstatSync);
      if (fs5.chmod && !fs5.lchmod) {
        fs5.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchmodSync = function() {
        };
      }
      if (fs5.chown && !fs5.lchown) {
        fs5.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs5.rename = typeof fs5.rename !== "function" ? fs5.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs5.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs5.rename);
      }
      fs5.read = typeof fs5.read !== "function" ? fs5.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs5.read);
      fs5.readSync = typeof fs5.readSync !== "function" ? fs5.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs5, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs5.readSync);
      function patchLchmod(fs6) {
        fs6.lchmod = function(path5, mode, callback) {
          fs6.open(
            path5,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs6.fchmod(fd, mode, function(err2) {
                fs6.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs6.lchmodSync = function(path5, mode) {
          var fd = fs6.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs6.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs6) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs6.futimes) {
          fs6.lutimes = function(path5, at, mt, cb) {
            fs6.open(path5, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs6.futimes(fd, at, mt, function(er2) {
                fs6.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs6.lutimesSync = function(path5, at, mt) {
            var fd = fs6.openSync(path5, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs6.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs6.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs6.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs6.futimes) {
          fs6.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs6.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs5, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs5, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs5, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs5, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs5) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs5.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs5.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.10/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs5 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug4 = noop;
    if (util.debuglog)
      debug4 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug4 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs5[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs5, queue);
      fs5.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs5, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs5.close);
      fs5.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs5, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs5.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug4(fs5[gracefulQueue]);
          require("assert").equal(fs5[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs5[gracefulQueue]);
    }
    module2.exports = patch(clone(fs5));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
      module2.exports = patch(fs5);
      fs5.__patched = true;
    }
    function patch(fs6) {
      polyfills(fs6);
      fs6.gracefulify = patch;
      fs6.createReadStream = createReadStream;
      fs6.createWriteStream = createWriteStream;
      var fs$readFile = fs6.readFile;
      fs6.readFile = readFile3;
      function readFile3(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs6.writeFile;
      fs6.writeFile = writeFile2;
      function writeFile2(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs6.appendFile;
      if (fs$appendFile)
        fs6.appendFile = appendFile;
      function appendFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs6.copyFile;
      if (fs$copyFile)
        fs6.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs6.readdir;
      fs6.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs6);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs6.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs6.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs6, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs6, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs6, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs6, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path5, options) {
        return new fs6.ReadStream(path5, options);
      }
      function createWriteStream(path5, options) {
        return new fs6.WriteStream(path5, options);
      }
      var fs$open = fs6.open;
      fs6.open = open;
      function open(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs6;
    }
    function enqueue(elem) {
      debug4("ENQUEUE", elem[0].name, elem[1]);
      fs5[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs5[gracefulQueue].length; ++i) {
        if (fs5[gracefulQueue][i].length > 2) {
          fs5[gracefulQueue][i][3] = now;
          fs5[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs5[gracefulQueue].length === 0)
        return;
      var elem = fs5[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug4("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug4("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug4("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs5[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchown",
      "lchmod",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "readFile",
      "readdir",
      "readlink",
      "realpath",
      "rename",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs5[key] === "function";
    });
    Object.keys(fs5).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports[key] = fs5[key];
    });
    api.forEach((method) => {
      exports[method] = u(fs5[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs5.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs5.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs5.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs5.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs5.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs5.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/win32.js
var require_win32 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/win32.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    function getRootPath(p) {
      p = path5.normalize(path5.resolve(p)).split(path5.sep);
      if (p.length > 0)
        return p[0];
      return null;
    }
    var INVALID_PATH_CHARS = /[<>:"|?*]/;
    function invalidWin32Path(p) {
      const rp = getRootPath(p);
      p = p.replace(rp, "");
      return INVALID_PATH_CHARS.test(p);
    }
    module2.exports = {
      getRootPath,
      invalidWin32Path
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/mkdirs.js
var require_mkdirs = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/mkdirs.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirs(p, opts, callback, made) {
      if (typeof opts === "function") {
        callback = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        return callback(errInval);
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs5;
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      callback = callback || function() {
      };
      p = path5.resolve(p);
      xfs.mkdir(p, mode, (er) => {
        if (!er) {
          made = made || p;
          return callback(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path5.dirname(p) === p)
              return callback(er);
            mkdirs(path5.dirname(p), opts, (er2, made2) => {
              if (er2)
                callback(er2, made2);
              else
                mkdirs(p, opts, callback, made2);
            });
            break;
          default:
            xfs.stat(p, (er2, stat2) => {
              if (er2 || !stat2.isDirectory())
                callback(er, made);
              else
                callback(null, made);
            });
            break;
        }
      });
    }
    module2.exports = mkdirs;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js
var require_mkdirs_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/mkdirs-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var invalidWin32Path = require_win32().invalidWin32Path;
    var o777 = parseInt("0777", 8);
    function mkdirsSync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      let mode = opts.mode;
      const xfs = opts.fs || fs5;
      if (process.platform === "win32" && invalidWin32Path(p)) {
        const errInval = new Error(p + " contains invalid WIN32 path characters.");
        errInval.code = "EINVAL";
        throw errInval;
      }
      if (mode === void 0) {
        mode = o777 & ~process.umask();
      }
      if (!made)
        made = null;
      p = path5.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        if (err0.code === "ENOENT") {
          if (path5.dirname(p) === p)
            throw err0;
          made = mkdirsSync(path5.dirname(p), opts, made);
          mkdirsSync(p, opts, made);
        } else {
          let stat2;
          try {
            stat2 = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat2.isDirectory())
            throw err0;
        }
      }
      return made;
    }
    module2.exports = mkdirsSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var mkdirs = u(require_mkdirs());
    var mkdirsSync = require_mkdirs_sync();
    module2.exports = {
      mkdirs,
      mkdirsSync,
      // alias
      mkdirp: mkdirs,
      mkdirpSync: mkdirsSync,
      ensureDir: mkdirs,
      ensureDirSync: mkdirsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var os = require("os");
    var path5 = require("path");
    function hasMillisResSync() {
      let tmpfile = path5.join("millis-test-sync" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path5.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs5.writeFileSync(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141");
      const fd = fs5.openSync(tmpfile, "r+");
      fs5.futimesSync(fd, d, d);
      fs5.closeSync(fd);
      return fs5.statSync(tmpfile).mtime > 1435410243e3;
    }
    function hasMillisRes(callback) {
      let tmpfile = path5.join("millis-test" + Date.now().toString() + Math.random().toString().slice(2));
      tmpfile = path5.join(os.tmpdir(), tmpfile);
      const d = /* @__PURE__ */ new Date(1435410243862);
      fs5.writeFile(tmpfile, "https://github.com/jprichardson/node-fs-extra/pull/141", (err) => {
        if (err)
          return callback(err);
        fs5.open(tmpfile, "r+", (err2, fd) => {
          if (err2)
            return callback(err2);
          fs5.futimes(fd, d, d, (err3) => {
            if (err3)
              return callback(err3);
            fs5.close(fd, (err4) => {
              if (err4)
                return callback(err4);
              fs5.stat(tmpfile, (err5, stats) => {
                if (err5)
                  return callback(err5);
                callback(null, stats.mtime > 1435410243e3);
              });
            });
          });
        });
      });
    }
    function timeRemoveMillis(timestamp) {
      if (typeof timestamp === "number") {
        return Math.floor(timestamp / 1e3) * 1e3;
      } else if (timestamp instanceof Date) {
        return new Date(Math.floor(timestamp.getTime() / 1e3) * 1e3);
      } else {
        throw new Error("fs-extra: timeRemoveMillis() unknown parameter type");
      }
    }
    function utimesMillis(path6, atime, mtime, callback) {
      fs5.open(path6, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs5.futimes(fd, atime, mtime, (futimesErr) => {
          fs5.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path6, atime, mtime) {
      const fd = fs5.openSync(path6, "r+");
      fs5.futimesSync(fd, atime, mtime);
      return fs5.closeSync(fd);
    }
    module2.exports = {
      hasMillisRes,
      hasMillisResSync,
      timeRemoveMillis,
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/util/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/util/buffer.js"(exports, module2) {
    "use strict";
    module2.exports = function(size) {
      if (typeof Buffer.allocUnsafe === "function") {
        try {
          return Buffer.allocUnsafe(size);
        } catch (e) {
          return new Buffer(size);
        }
      }
      return new Buffer(size);
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var utimesSync = require_utimes().utimesMillisSync;
    var notExist = Symbol("notExist");
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const destStat = checkPaths(src, dest);
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path5.dirname(dest);
      if (!fs5.existsSync(destParent))
        mkdirpSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs5.statSync : fs5.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs5.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      if (typeof fs5.copyFileSync === "function") {
        fs5.copyFileSync(src, dest);
        fs5.chmodSync(dest, srcStat.mode);
        if (opts.preserveTimestamps) {
          return utimesSync(dest, srcStat.atime, srcStat.mtime);
        }
        return;
      }
      return copyFileFallback(srcStat, src, dest, opts);
    }
    function copyFileFallback(srcStat, src, dest, opts) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = require_buffer()(BUF_LENGTH);
      const fdr = fs5.openSync(src, "r");
      const fdw = fs5.openSync(dest, "w", srcStat.mode);
      let pos = 0;
      while (pos < srcStat.size) {
        const bytesRead = fs5.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs5.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      if (opts.preserveTimestamps)
        fs5.futimesSync(fdw, srcStat.atime, srcStat.mtime);
      fs5.closeSync(fdr);
      fs5.closeSync(fdw);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcStat, src, dest, opts) {
      fs5.mkdirSync(dest);
      copyDir(src, dest, opts);
      return fs5.chmodSync(dest, srcStat.mode);
    }
    function copyDir(src, dest, opts) {
      fs5.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      const destStat = checkPaths(srcItem, destItem);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs5.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
      }
      if (destStat === notExist) {
        return fs5.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs5.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs5.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path5.resolve(process.cwd(), resolvedDest);
        }
        if (isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs5.statSync(dest).isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs5.unlinkSync(dest);
      return fs5.symlinkSync(resolvedSrc, dest);
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path5.resolve(src).split(path5.sep);
      const destArray = path5.resolve(dest).split(path5.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest) {
      const srcStat = fs5.statSync(src);
      let destStat;
      try {
        destStat = fs5.statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: notExist };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest) {
      const { srcStat, destStat } = checkStats(src, dest);
      if (destStat.ino && destStat.ino === srcStat.ino) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`);
      }
      return destStat;
    }
    module2.exports = copySync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy-sync/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs5 = require_fs();
    function pathExists2(path5) {
      return fs5.access(path5).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists2),
      pathExistsSync: fs5.existsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdirp = require_mkdirs2().mkdirs;
    var pathExists2 = require_path_exists2().pathExists;
    var utimes = require_utimes().utimesMillis;
    var notExist = Symbol("notExist");
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      checkPaths(src, dest, (err, destStat) => {
        if (err)
          return cb(err);
        if (opts.filter)
          return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
        return checkParentDir(destStat, src, dest, opts, cb);
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path5.dirname(dest);
      pathExists2(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirp(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include) {
          if (destStat)
            return onInclude(destStat, src, dest, opts, cb);
          return onInclude(src, dest, opts, cb);
        }
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs5.stat : fs5.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs5.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      if (typeof fs5.copyFile === "function") {
        return fs5.copyFile(src, dest, (err) => {
          if (err)
            return cb(err);
          return setDestModeAndTimestamps(srcStat, dest, opts, cb);
        });
      }
      return copyFileFallback(srcStat, src, dest, opts, cb);
    }
    function copyFileFallback(srcStat, src, dest, opts, cb) {
      const rs = fs5.createReadStream(src);
      rs.on("error", (err) => cb(err)).once("open", () => {
        const ws = fs5.createWriteStream(dest, { mode: srcStat.mode });
        ws.on("error", (err) => cb(err)).on("open", () => rs.pipe(ws)).once("close", () => setDestModeAndTimestamps(srcStat, dest, opts, cb));
      });
    }
    function setDestModeAndTimestamps(srcStat, dest, opts, cb) {
      fs5.chmod(dest, srcStat.mode, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps) {
          return utimes(dest, srcStat.atime, srcStat.mtime, cb);
        }
        return cb();
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (destStat === notExist)
        return mkDirAndCopy(srcStat, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcStat, src, dest, opts, cb) {
      fs5.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return fs5.chmod(dest, srcStat.mode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs5.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path5.join(src, item);
      const destItem = path5.join(dest, item);
      checkPaths(srcItem, destItem, (err, destStat) => {
        if (err)
          return cb(err);
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs5.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path5.resolve(process.cwd(), resolvedSrc);
        }
        if (destStat === notExist) {
          return fs5.symlink(resolvedSrc, dest, cb);
        } else {
          fs5.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs5.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path5.resolve(process.cwd(), resolvedDest);
            }
            if (isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs5.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs5.symlink(resolvedSrc, dest, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = path5.resolve(src).split(path5.sep);
      const destArray = path5.resolve(dest).split(path5.sep);
      return srcArray.reduce((acc, current, i) => acc && destArray[i] === current, true);
    }
    function checkStats(src, dest, cb) {
      fs5.stat(src, (err, srcStat) => {
        if (err)
          return cb(err);
        fs5.stat(dest, (err2, destStat) => {
          if (err2) {
            if (err2.code === "ENOENT")
              return cb(null, { srcStat, destStat: notExist });
            return cb(err2);
          }
          return cb(null, { srcStat, destStat });
        });
      });
    }
    function checkPaths(src, dest, cb) {
      checkStats(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat.ino && destStat.ino === srcStat.ino) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot copy '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        return cb(null, destStat);
      });
    }
    module2.exports = copy;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/remove/rimraf.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var assert = require("assert");
    var isWindows = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs5[m];
        m = m + "Sync";
        options[m] = options[m] || fs5[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er) {
        assert(er instanceof Error);
      }
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      if (er) {
        assert(er instanceof Error);
      }
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path5.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr) {
        assert(originalEr instanceof Error);
      }
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path5.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require("fs");
    var path5 = require("path");
    var mkdir = require_mkdirs2();
    var remove2 = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs5.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path5.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove2.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs5.readdirSync(dir);
      } catch (err) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path5.join(dir, item);
        remove2.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists2 = require_path_exists2().pathExists;
    function createFile(file, callback) {
      function makeFile() {
        fs5.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs5.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path5.dirname(file);
        pathExists2(dir, (err2, dirExists) => {
          if (err2)
            return callback(err2);
          if (dirExists)
            return makeFile();
          mkdir.mkdirs(dir, (err3) => {
            if (err3)
              return callback(err3);
            makeFile();
          });
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs5.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path5.dirname(file);
      if (!fs5.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs5.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists2 = require_path_exists2().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs5.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists2(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs5.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path5.dirname(dstpath);
          pathExists2(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs5.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs5.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path5.dirname(dstpath);
      const dirExists = fs5.existsSync(dir);
      if (dirExists)
        return fs5.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs5.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var pathExists2 = require_path_exists2().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path5.isAbsolute(srcpath)) {
        return fs5.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            "toCwd": srcpath,
            "toDst": srcpath
          });
        });
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        return pathExists2(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              "toCwd": relativeToDst,
              "toDst": srcpath
            });
          } else {
            return fs5.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                "toCwd": srcpath,
                "toDst": path5.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path5.isAbsolute(srcpath)) {
        exists = fs5.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          "toCwd": srcpath,
          "toDst": srcpath
        };
      } else {
        const dstdir = path5.dirname(dstpath);
        const relativeToDst = path5.join(dstdir, srcpath);
        exists = fs5.existsSync(relativeToDst);
        if (exists) {
          return {
            "toCwd": relativeToDst,
            "toDst": srcpath
          };
        } else {
          exists = fs5.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            "toCwd": srcpath,
            "toDst": path5.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs5.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs5.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path5 = require("path");
    var fs5 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists2 = require_path_exists2().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists2(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path5.dirname(dstpath);
            pathExists2(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs5.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs5.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs5.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path5.dirname(dstpath);
      const exists = fs5.existsSync(dir);
      if (exists)
        return fs5.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs5.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      // file
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      // link
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      // symlink
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js
var require_polyfills2 = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs5) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs5);
      }
      if (!fs5.lutimes) {
        patchLutimes(fs5);
      }
      fs5.chown = chownFix(fs5.chown);
      fs5.fchown = chownFix(fs5.fchown);
      fs5.lchown = chownFix(fs5.lchown);
      fs5.chmod = chmodFix(fs5.chmod);
      fs5.fchmod = chmodFix(fs5.fchmod);
      fs5.lchmod = chmodFix(fs5.lchmod);
      fs5.chownSync = chownFixSync(fs5.chownSync);
      fs5.fchownSync = chownFixSync(fs5.fchownSync);
      fs5.lchownSync = chownFixSync(fs5.lchownSync);
      fs5.chmodSync = chmodFixSync(fs5.chmodSync);
      fs5.fchmodSync = chmodFixSync(fs5.fchmodSync);
      fs5.lchmodSync = chmodFixSync(fs5.lchmodSync);
      fs5.stat = statFix(fs5.stat);
      fs5.fstat = statFix(fs5.fstat);
      fs5.lstat = statFix(fs5.lstat);
      fs5.statSync = statFixSync(fs5.statSync);
      fs5.fstatSync = statFixSync(fs5.fstatSync);
      fs5.lstatSync = statFixSync(fs5.lstatSync);
      if (fs5.chmod && !fs5.lchmod) {
        fs5.lchmod = function(path5, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchmodSync = function() {
        };
      }
      if (fs5.chown && !fs5.lchown) {
        fs5.lchown = function(path5, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs5.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs5.rename = typeof fs5.rename !== "function" ? fs5.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs5.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs5.rename);
      }
      fs5.read = typeof fs5.read !== "function" ? fs5.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs5, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs5.read);
      fs5.readSync = typeof fs5.readSync !== "function" ? fs5.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs5, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs5.readSync);
      function patchLchmod(fs6) {
        fs6.lchmod = function(path5, mode, callback) {
          fs6.open(
            path5,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs6.fchmod(fd, mode, function(err2) {
                fs6.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs6.lchmodSync = function(path5, mode) {
          var fd = fs6.openSync(path5, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs6.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs6.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs6.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs6) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs6.futimes) {
          fs6.lutimes = function(path5, at, mt, cb) {
            fs6.open(path5, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs6.futimes(fd, at, mt, function(er2) {
                fs6.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs6.lutimesSync = function(path5, at, mt) {
            var fd = fs6.openSync(path5, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs6.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs6.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs6.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs6.futimes) {
          fs6.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs6.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs5, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs5, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs5, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs5, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs5, target, options, callback) : orig.call(fs5, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs5, target, options) : orig.call(fs5, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams2 = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs5) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path5, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path5, options);
        Stream.call(this);
        var self = this;
        this.path = path5;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self._read();
          });
          return;
        }
        fs5.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self.emit("error", err);
            self.readable = false;
            return;
          }
          self.fd = fd;
          self.emit("open", fd);
          self._read();
        });
      }
      function WriteStream(path5, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path5, options);
        Stream.call(this);
        this.path = path5;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs5.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js
var require_clone2 = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs2 = __commonJS({
  "../../node_modules/.pnpm/graceful-fs@4.2.11/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs5 = require("fs");
    var polyfills = require_polyfills2();
    var legacy = require_legacy_streams2();
    var clone = require_clone2();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug4 = noop;
    if (util.debuglog)
      debug4 = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug4 = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs5[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs5, queue);
      fs5.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs5, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs5.close);
      fs5.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs5, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs5.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug4(fs5[gracefulQueue]);
          require("assert").equal(fs5[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs5[gracefulQueue]);
    }
    module2.exports = patch(clone(fs5));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs5.__patched) {
      module2.exports = patch(fs5);
      fs5.__patched = true;
    }
    function patch(fs6) {
      polyfills(fs6);
      fs6.gracefulify = patch;
      fs6.createReadStream = createReadStream;
      fs6.createWriteStream = createWriteStream;
      var fs$readFile = fs6.readFile;
      fs6.readFile = readFile3;
      function readFile3(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path5, options, cb);
        function go$readFile(path6, options2, cb2, startTime) {
          return fs$readFile(path6, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path6, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs6.writeFile;
      fs6.writeFile = writeFile2;
      function writeFile2(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path5, data, options, cb);
        function go$writeFile(path6, data2, options2, cb2, startTime) {
          return fs$writeFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs6.appendFile;
      if (fs$appendFile)
        fs6.appendFile = appendFile;
      function appendFile(path5, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path5, data, options, cb);
        function go$appendFile(path6, data2, options2, cb2, startTime) {
          return fs$appendFile(path6, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path6, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs6.copyFile;
      if (fs$copyFile)
        fs6.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs6.readdir;
      fs6.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path5, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path6, options2, cb2, startTime) {
          return fs$readdir(path6, options2, fs$readdirCallback(
            path6,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path5, options, cb);
        function fs$readdirCallback(path6, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path6, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs6);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs6.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs6.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs6, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs6, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs6, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs6, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path5, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path5, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path5, options) {
        return new fs6.ReadStream(path5, options);
      }
      function createWriteStream(path5, options) {
        return new fs6.WriteStream(path5, options);
      }
      var fs$open = fs6.open;
      fs6.open = open;
      function open(path5, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path5, flags, mode, cb);
        function go$open(path6, flags2, mode2, cb2, startTime) {
          return fs$open(path6, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path6, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs6;
    }
    function enqueue(elem) {
      debug4("ENQUEUE", elem[0].name, elem[1]);
      fs5[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs5[gracefulQueue].length; ++i) {
        if (fs5[gracefulQueue][i].length > 2) {
          fs5[gracefulQueue][i][3] = now;
          fs5[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs5[gracefulQueue].length === 0)
        return;
      var elem = fs5[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug4("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug4("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug4("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs5[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../../node_modules/.pnpm/jsonfile@4.0.0/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../../node_modules/.pnpm/jsonfile@4.0.0/node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs2();
    } catch (_) {
      _fs = require("fs");
    }
    function readFile3(file, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      if (typeof options === "string") {
        options = { encoding: options };
      }
      options = options || {};
      var fs5 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      fs5.readFile(file, options, function(err, data) {
        if (err)
          return callback(err);
        data = stripBom(data);
        var obj;
        try {
          obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err2) {
          if (shouldThrow) {
            err2.message = file + ": " + err2.message;
            return callback(err2);
          } else {
            return callback(null, null);
          }
        }
        callback(null, obj);
      });
    }
    function readFileSync(file, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { encoding: options };
      }
      var fs5 = options.fs || _fs;
      var shouldThrow = true;
      if ("throws" in options) {
        shouldThrow = options.throws;
      }
      try {
        var content = fs5.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = file + ": " + err.message;
          throw err;
        } else {
          return null;
        }
      }
    }
    function stringify(obj, options) {
      var spaces;
      var EOL = "\n";
      if (typeof options === "object" && options !== null) {
        if (options.spaces) {
          spaces = options.spaces;
        }
        if (options.EOL) {
          EOL = options.EOL;
        }
      }
      var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
      return str.replace(/\n/g, EOL) + EOL;
    }
    function writeFile2(file, obj, options, callback) {
      if (callback == null) {
        callback = options;
        options = {};
      }
      options = options || {};
      var fs5 = options.fs || _fs;
      var str = "";
      try {
        str = stringify(obj, options);
      } catch (err) {
        if (callback)
          callback(err, null);
        return;
      }
      fs5.writeFile(file, str, options, callback);
    }
    function writeFileSync(file, obj, options) {
      options = options || {};
      var fs5 = options.fs || _fs;
      var str = stringify(obj, options);
      return fs5.writeFileSync(file, str, options);
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      content = content.replace(/^\uFEFF/, "");
      return content;
    }
    var jsonfile = {
      readFile: readFile3,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile();
    module2.exports = {
      // jsonfile exports
      readJson: u(jsonFile.readFile),
      readJsonSync: jsonFile.readFileSync,
      writeJson: u(jsonFile.writeFile),
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists2 = require_path_exists2().pathExists;
    var jsonFile = require_jsonfile2();
    function outputJson(file, data, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      const dir = path5.dirname(file);
      pathExists2(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return jsonFile.writeJson(file, data, options, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          jsonFile.writeJson(file, data, options, callback);
        });
      });
    }
    module2.exports = outputJson;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs2();
    var jsonFile = require_jsonfile2();
    function outputJsonSync(file, data, options) {
      const dir = path5.dirname(file);
      if (!fs5.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      jsonFile.writeJsonSync(file, data, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/move-sync/index.js"(exports, module2) {
    "use strict";
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirsSync;
    var buffer = require_buffer();
    function moveSync(src, dest, options) {
      options = options || {};
      const overwrite = options.overwrite || options.clobber || false;
      src = path5.resolve(src);
      dest = path5.resolve(dest);
      if (src === dest)
        return fs5.accessSync(src);
      if (isSrcSubdir(src, dest))
        throw new Error(`Cannot move '${src}' into itself '${dest}'.`);
      mkdirpSync(path5.dirname(dest));
      tryRenameSync();
      function tryRenameSync() {
        if (overwrite) {
          try {
            return fs5.renameSync(src, dest);
          } catch (err) {
            if (err.code === "ENOTEMPTY" || err.code === "EEXIST" || err.code === "EPERM") {
              removeSync(dest);
              options.overwrite = false;
              return moveSync(src, dest, options);
            }
            if (err.code !== "EXDEV")
              throw err;
            return moveSyncAcrossDevice(src, dest, overwrite);
          }
        } else {
          try {
            fs5.linkSync(src, dest);
            return fs5.unlinkSync(src);
          } catch (err) {
            if (err.code === "EXDEV" || err.code === "EISDIR" || err.code === "EPERM" || err.code === "ENOTSUP") {
              return moveSyncAcrossDevice(src, dest, overwrite);
            }
            throw err;
          }
        }
      }
    }
    function moveSyncAcrossDevice(src, dest, overwrite) {
      const stat2 = fs5.statSync(src);
      if (stat2.isDirectory()) {
        return moveDirSyncAcrossDevice(src, dest, overwrite);
      } else {
        return moveFileSyncAcrossDevice(src, dest, overwrite);
      }
    }
    function moveFileSyncAcrossDevice(src, dest, overwrite) {
      const BUF_LENGTH = 64 * 1024;
      const _buff = buffer(BUF_LENGTH);
      const flags = overwrite ? "w" : "wx";
      const fdr = fs5.openSync(src, "r");
      const stat2 = fs5.fstatSync(fdr);
      const fdw = fs5.openSync(dest, flags, stat2.mode);
      let pos = 0;
      while (pos < stat2.size) {
        const bytesRead = fs5.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
        fs5.writeSync(fdw, _buff, 0, bytesRead);
        pos += bytesRead;
      }
      fs5.closeSync(fdr);
      fs5.closeSync(fdw);
      return fs5.unlinkSync(src);
    }
    function moveDirSyncAcrossDevice(src, dest, overwrite) {
      const options = {
        overwrite: false
      };
      if (overwrite) {
        removeSync(dest);
        tryCopySync();
      } else {
        tryCopySync();
      }
      function tryCopySync() {
        copySync(src, dest, options);
        return removeSync(src);
      }
    }
    function isSrcSubdir(src, dest) {
      try {
        return fs5.statSync(src).isDirectory() && src !== dest && dest.indexOf(src) > -1 && dest.split(path5.dirname(src) + path5.sep)[1].split(path5.sep)[0] === path5.basename(src);
      } catch (e) {
        return false;
      }
    }
    module2.exports = {
      moveSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/move/index.js
var require_move = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var copy = require_copy2().copy;
    var remove2 = require_remove().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists2 = require_path_exists2().pathExists;
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      src = path5.resolve(src);
      dest = path5.resolve(dest);
      if (src === dest)
        return fs5.access(src, cb);
      fs5.stat(src, (err, st) => {
        if (err)
          return cb(err);
        if (st.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(`Cannot move '${src}' to a subdirectory of itself, '${dest}'.`));
        }
        mkdirp(path5.dirname(dest), (err2) => {
          if (err2)
            return cb(err2);
          return doRename(src, dest, overwrite, cb);
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove2(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists2(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs5.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove2(src, cb);
      });
    }
    function isSrcSubdir(src, dest) {
      const srcArray = src.split(path5.sep);
      const destArray = dest.split(path5.sep);
      return srcArray.reduce((acc, current, i) => {
        return acc && destArray[i] === current;
      }, true);
    }
    module2.exports = {
      move: u(move)
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/output/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs5 = require_graceful_fs();
    var path5 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists2 = require_path_exists2().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path5.dirname(file);
      pathExists2(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs5.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs5.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path5.dirname(file);
      if (fs5.existsSync(dir)) {
        return fs5.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs5.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/fs-extra@7.0.0/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = Object.assign(
      {},
      // Export promiseified graceful-fs:
      require_fs(),
      // Export extra methods:
      require_copy_sync2(),
      require_copy2(),
      require_empty(),
      require_ensure(),
      require_json(),
      require_mkdirs2(),
      require_move_sync(),
      require_move(),
      require_output(),
      require_path_exists2(),
      require_remove()
    );
    var fs5 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs5, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs5.promises;
        }
      });
    }
  }
});

// ../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../../node_modules/.pnpm/semver@6.3.1/node_modules/semver/semver.js"(exports, module2) {
    exports = module2.exports = SemVer;
    var debug4;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug4 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug4 = function() {
      };
    }
    exports.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src[t.COERCE]), "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug4(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports.parse = parse;
    function parse(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports.valid = valid;
    function valid(version2, options) {
      var v = parse(version2, options);
      return v ? v.version : null;
    }
    exports.clean = clean;
    function clean(version2, options) {
      var s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug4("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug4("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug4("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }
    exports.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }
    exports.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug4("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug4("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug4("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY || version2 === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug4("hyphen replace", range);
      range = range.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug4("comparator trim", range, safeRe[t.COMPARATORTRIM]);
      range = range.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug4("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug4("caret", comp);
      comp = replaceTildes(comp, options);
      debug4("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug4("xrange", comp);
      comp = replaceStars(comp, options);
      debug4("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug4("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug4("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug4("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug4("caret", comp, options);
      var r = options.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug4("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug4("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug4("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug4("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug4("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug4("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug4("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug4("replaceStars", comp, options);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        try {
          version2 = new SemVer(version2, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug4(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports.satisfies = satisfies;
    function satisfies(version2, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version2);
    }
    exports.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports.ltr = ltr;
    function ltr(version2, range, options) {
      return outside(version2, range, "<", options);
    }
    exports.gtr = gtr;
    function gtr(version2, range, options) {
      return outside(version2, range, ">", options);
    }
    exports.outside = outside;
    function outside(version2, range, hilo, options) {
      version2 = new SemVer(version2, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports.coerce = coerce;
    function coerce(version2, options) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version2.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// ../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "../../node_modules/.pnpm/buffer-crc32@0.2.13/node_modules/buffer-crc32/index.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc322() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc322.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc322.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc322;
  }
});

// ../../node_modules/.pnpm/text-table@0.2.0/node_modules/text-table/index.js
var require_text_table = __commonJS({
  "../../node_modules/.pnpm/text-table@0.2.0/node_modules/text-table/index.js"(exports, module2) {
    module2.exports = function(rows_, opts) {
      if (!opts)
        opts = {};
      var hsep = opts.hsep === void 0 ? "  " : opts.hsep;
      var align = opts.align || [];
      var stringLength = opts.stringLength || function(s) {
        return String(s).length;
      };
      var dotsizes = reduce(rows_, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = dotindex(c);
          if (!acc[ix] || n > acc[ix])
            acc[ix] = n;
        });
        return acc;
      }, []);
      var rows = map(rows_, function(row) {
        return map(row, function(c_, ix) {
          var c = String(c_);
          if (align[ix] === ".") {
            var index = dotindex(c);
            var size = dotsizes[ix] + (/\./.test(c) ? 1 : 2) - (stringLength(c) - index);
            return c + Array(size).join(" ");
          } else
            return c;
        });
      });
      var sizes = reduce(rows, function(acc, row) {
        forEach(row, function(c, ix) {
          var n = stringLength(c);
          if (!acc[ix] || n > acc[ix])
            acc[ix] = n;
        });
        return acc;
      }, []);
      return map(rows, function(row) {
        return map(row, function(c, ix) {
          var n = sizes[ix] - stringLength(c) || 0;
          var s = Array(Math.max(n + 1, 1)).join(" ");
          if (align[ix] === "r" || align[ix] === ".") {
            return s + c;
          }
          if (align[ix] === "c") {
            return Array(Math.ceil(n / 2 + 1)).join(" ") + c + Array(Math.floor(n / 2 + 1)).join(" ");
          }
          return c + s;
        }).join(hsep).replace(/\s+$/, "");
      }).join("\n");
    };
    function dotindex(c) {
      var m = /\.[^.]*$/.exec(c);
      return m ? m.index + 1 : c.length;
    }
    function reduce(xs, f, init) {
      if (xs.reduce)
        return xs.reduce(f, init);
      var i = 0;
      var acc = arguments.length >= 3 ? init : xs[i++];
      for (; i < xs.length; i++) {
        f(acc, xs[i], i);
      }
      return acc;
    }
    function forEach(xs, f) {
      if (xs.forEach)
        return xs.forEach(f);
      for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
      }
    }
    function map(xs, f) {
      if (xs.map)
        return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f.call(xs, xs[i], i));
      }
      return res;
    }
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js
var require_Source = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/Source.js"(exports, module2) {
    "use strict";
    var Source3 = class {
      source() {
        throw new Error("Abstract");
      }
      buffer() {
        const source = this.source();
        if (Buffer.isBuffer(source))
          return source;
        return Buffer.from(source, "utf-8");
      }
      size() {
        return this.buffer().length;
      }
      map(options) {
        return null;
      }
      sourceAndMap(options) {
        return {
          source: this.source(),
          map: this.map(options)
        };
      }
      updateHash(hash) {
        throw new Error("Abstract");
      }
    };
    module2.exports = Source3;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js
var require_getGeneratedSourceInfo = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getGeneratedSourceInfo.js"(exports, module2) {
    "use strict";
    var CHAR_CODE_NEW_LINE = "\n".charCodeAt(0);
    var getGeneratedSourceInfo = (source) => {
      if (source === void 0) {
        return {};
      }
      const lastLineStart = source.lastIndexOf("\n");
      if (lastLineStart === -1) {
        return {
          generatedLine: 1,
          generatedColumn: source.length,
          source
        };
      }
      let generatedLine = 2;
      for (let i = 0; i < lastLineStart; i++) {
        if (source.charCodeAt(i) === CHAR_CODE_NEW_LINE)
          generatedLine++;
      }
      return {
        generatedLine,
        generatedColumn: source.length - lastLineStart - 1,
        source
      };
    };
    module2.exports = getGeneratedSourceInfo;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js
var require_splitIntoLines = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoLines.js"(exports, module2) {
    var splitIntoLines = (str) => {
      const results = [];
      const len = str.length;
      let i = 0;
      for (; i < len; ) {
        const cc = str.charCodeAt(i);
        if (cc === 10) {
          results.push("\n");
          i++;
        } else {
          let j = i + 1;
          while (j < len && str.charCodeAt(j) !== 10)
            j++;
          results.push(str.slice(i, j + 1));
          i = j + 1;
        }
      }
      return results;
    };
    module2.exports = splitIntoLines;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js
var require_streamChunksOfRawSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfRawSource.js"(exports, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfRawSource = (source, onChunk, onSource, onName) => {
      let line = 1;
      const matches = splitIntoLines(source);
      let match;
      for (match of matches) {
        onChunk(match, line, 0, -1, -1, -1, -1);
        line++;
      }
      return matches.length === 0 || match.endsWith("\n") ? {
        generatedLine: matches.length + 1,
        generatedColumn: 0
      } : {
        generatedLine: matches.length,
        generatedColumn: match.length
      };
    };
    module2.exports = (source, onChunk, onSource, onName, finalSource) => {
      return finalSource ? getGeneratedSourceInfo(source) : streamChunksOfRawSource(source, onChunk, onSource, onName);
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js
var require_RawSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/RawSource.js"(exports, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var Source3 = require_Source();
    var RawSource = class extends Source3 {
      constructor(value, convertToString = false) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        if (!isBuffer && typeof value !== "string") {
          throw new TypeError("argument 'value' must be either string of Buffer");
        }
        this._valueIsBuffer = !convertToString && isBuffer;
        this._value = convertToString && isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._valueAsString = isBuffer ? void 0 : value;
      }
      isBuffer() {
        return this._valueIsBuffer;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return null;
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = Buffer.from(this._valueAsBuffer, "utf-8");
        }
        if (this._valueAsString === void 0) {
          this._valueAsString = typeof this._value === "string" ? this._value : this._value.toString("utf-8");
        }
        return streamChunksOfRawSource(
          this._valueAsString,
          onChunk,
          onSource,
          onName,
          !!(options && options.finalSource)
        );
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("RawSource");
        hash.update(this._valueAsBuffer);
      }
    };
    module2.exports = RawSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js
var require_createMappingsSerializer = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/createMappingsSerializer.js"(exports, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(
      ""
    );
    var CONTINUATION_BIT = 32;
    var createMappingsSerializer = (options) => {
      const linesOnly = options && options.columns === false;
      return linesOnly ? createLinesOnlyMappingsSerializer() : createFullMappingsSerializer();
    };
    var createFullMappingsSerializer = () => {
      let currentLine = 1;
      let currentColumn = 0;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      let currentOriginalColumn = 0;
      let currentNameIndex = 0;
      let activeMapping = false;
      let activeName = false;
      let initial = true;
      return (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (activeMapping && currentLine === generatedLine) {
          if (sourceIndex === currentSourceIndex && originalLine === currentOriginalLine && originalColumn === currentOriginalColumn && !activeName && nameIndex < 0) {
            return "";
          }
        } else {
          if (sourceIndex < 0) {
            return "";
          }
        }
        let str;
        if (currentLine < generatedLine) {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          currentColumn = 0;
          initial = false;
        } else if (initial) {
          str = "";
          initial = false;
        } else {
          str = ",";
        }
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        writeValue(generatedColumn - currentColumn);
        currentColumn = generatedColumn;
        if (sourceIndex >= 0) {
          activeMapping = true;
          if (sourceIndex === currentSourceIndex) {
            str += "A";
          } else {
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
          }
          writeValue(originalLine - currentOriginalLine);
          currentOriginalLine = originalLine;
          if (originalColumn === currentOriginalColumn) {
            str += "A";
          } else {
            writeValue(originalColumn - currentOriginalColumn);
            currentOriginalColumn = originalColumn;
          }
          if (nameIndex >= 0) {
            writeValue(nameIndex - currentNameIndex);
            currentNameIndex = nameIndex;
            activeName = true;
          } else {
            activeName = false;
          }
        } else {
          activeMapping = false;
        }
        return str;
      };
    };
    var createLinesOnlyMappingsSerializer = () => {
      let lastWrittenLine = 0;
      let currentLine = 1;
      let currentSourceIndex = 0;
      let currentOriginalLine = 1;
      return (generatedLine, _generatedColumn, sourceIndex, originalLine, _originalColumn, _nameIndex) => {
        if (sourceIndex < 0) {
          return "";
        }
        if (lastWrittenLine === generatedLine) {
          return "";
        }
        let str;
        const writeValue = (value) => {
          const sign = value >>> 31 & 1;
          const mask = value >> 31;
          const absValue = value + mask ^ mask;
          let data = absValue << 1 | sign;
          for (; ; ) {
            const sextet = data & 31;
            data >>= 5;
            if (data === 0) {
              str += ALPHABET[sextet];
              break;
            } else {
              str += ALPHABET[sextet | CONTINUATION_BIT];
            }
          }
        };
        lastWrittenLine = generatedLine;
        if (generatedLine === currentLine + 1) {
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return ";AACA";
            } else {
              str = ";AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str = ";A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        } else {
          str = ";".repeat(generatedLine - currentLine);
          currentLine = generatedLine;
          if (sourceIndex === currentSourceIndex) {
            currentSourceIndex = sourceIndex;
            if (originalLine === currentOriginalLine + 1) {
              currentOriginalLine = originalLine;
              return str + "AACA";
            } else {
              str += "AA";
              writeValue(originalLine - currentOriginalLine);
              currentOriginalLine = originalLine;
              return str + "A";
            }
          } else {
            str += "A";
            writeValue(sourceIndex - currentSourceIndex);
            currentSourceIndex = sourceIndex;
            writeValue(originalLine - currentOriginalLine);
            currentOriginalLine = originalLine;
            return str + "A";
          }
        }
      };
    };
    module2.exports = createMappingsSerializer;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js
var require_getFromStreamChunks = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getFromStreamChunks.js"(exports) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    exports.getSourceAndMap = (inputSource, options) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      const { source } = inputSource.streamChunks(
        Object.assign({}, options, { finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0)
            code += chunk;
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return {
        source: source !== void 0 ? source : code,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    exports.getMap = (source, options) => {
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(options);
      source.streamChunks(
        Object.assign({}, options, { source: false, finalSource: true }),
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          mappings += addMapping(
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
        }
      );
      return mappings.length > 0 ? {
        version: 3,
        file: "x",
        mappings,
        sources,
        sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
        names
      } : null;
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js
var require_splitIntoPotentialTokens = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/splitIntoPotentialTokens.js"(exports, module2) {
    var splitIntoPotentialTokens = (str) => {
      const len = str.length;
      if (len === 0)
        return null;
      const results = [];
      let i = 0;
      for (; i < len; ) {
        const s = i;
        block: {
          let cc = str.charCodeAt(i);
          while (cc !== 10 && cc !== 59 && cc !== 123 && cc !== 125) {
            if (++i >= len)
              break block;
            cc = str.charCodeAt(i);
          }
          while (cc === 59 || cc === 32 || cc === 123 || cc === 125 || cc === 13 || cc === 9) {
            if (++i >= len)
              break block;
            cc = str.charCodeAt(i);
          }
          if (cc === 10) {
            i++;
          }
        }
        results.push(str.slice(s, i));
      }
      return results;
    };
    module2.exports = splitIntoPotentialTokens;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js
var require_OriginalSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/OriginalSource.js"(exports, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var splitIntoLines = require_splitIntoLines();
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var Source3 = require_Source();
    var splitIntoPotentialTokens = require_splitIntoPotentialTokens();
    var OriginalSource2 = class extends Source3 {
      constructor(value, name) {
        super();
        const isBuffer = Buffer.isBuffer(value);
        this._value = isBuffer ? void 0 : value;
        this._valueAsBuffer = isBuffer ? value : void 0;
        this._name = name;
      }
      getName() {
        return this._name;
      }
      source() {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        return this._value;
      }
      buffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        return this._valueAsBuffer;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      /**
       * @param {object} options options
       * @param {function(string, number, number, number, number, number, number): void} onChunk called for each chunk of code
       * @param {function(number, string, string)} onSource called for each source
       * @param {function(number, string)} onName called for each name
       * @returns {void}
       */
      streamChunks(options, onChunk, onSource, onName) {
        if (this._value === void 0) {
          this._value = this._valueAsBuffer.toString("utf-8");
        }
        onSource(0, this._name, this._value);
        const finalSource = !!(options && options.finalSource);
        if (!options || options.columns !== false) {
          const matches = splitIntoPotentialTokens(this._value);
          let line = 1;
          let column = 0;
          if (matches !== null) {
            for (const match of matches) {
              const isEndOfLine = match.endsWith("\n");
              if (isEndOfLine && match.length === 1) {
                if (!finalSource)
                  onChunk(match, line, column, -1, -1, -1, -1);
              } else {
                const chunk = finalSource ? void 0 : match;
                onChunk(chunk, line, column, 0, line, column, -1);
              }
              if (isEndOfLine) {
                line++;
                column = 0;
              } else {
                column += match.length;
              }
            }
          }
          return {
            generatedLine: line,
            generatedColumn: column,
            source: finalSource ? this._value : void 0
          };
        } else if (finalSource) {
          const result = getGeneratedSourceInfo(this._value);
          const { generatedLine, generatedColumn } = result;
          if (generatedColumn === 0) {
            for (let line = 1; line < generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          } else {
            for (let line = 1; line <= generatedLine; line++)
              onChunk(void 0, line, 0, 0, line, 0, -1);
          }
          return result;
        } else {
          let line = 1;
          const matches = splitIntoLines(this._value);
          let match;
          for (match of matches) {
            onChunk(finalSource ? void 0 : match, line, 0, 0, line, 0, -1);
            line++;
          }
          return matches.length === 0 || match.endsWith("\n") ? {
            generatedLine: matches.length + 1,
            generatedColumn: 0,
            source: finalSource ? this._value : void 0
          } : {
            generatedLine: matches.length,
            generatedColumn: match.length,
            source: finalSource ? this._value : void 0
          };
        }
      }
      updateHash(hash) {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._value, "utf-8");
        }
        hash.update("OriginalSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._name || "");
      }
    };
    module2.exports = OriginalSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js
var require_getSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/getSource.js"(exports, module2) {
    "use strict";
    var getSource = (sourceMap, index) => {
      if (index < 0)
        return null;
      const { sourceRoot, sources } = sourceMap;
      const source = sources[index];
      if (!sourceRoot)
        return source;
      if (sourceRoot.endsWith("/"))
        return sourceRoot + source;
      return sourceRoot + "/" + source;
    };
    module2.exports = getSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js
var require_readMappings = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/readMappings.js"(exports, module2) {
    "use strict";
    var ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var CONTINUATION_BIT = 32;
    var END_SEGMENT_BIT = 64;
    var NEXT_LINE = END_SEGMENT_BIT | 1;
    var INVALID = END_SEGMENT_BIT | 2;
    var DATA_MASK = 31;
    var ccToValue = new Uint8Array("z".charCodeAt(0) + 1);
    {
      ccToValue.fill(INVALID);
      for (let i = 0; i < ALPHABET.length; i++) {
        ccToValue[ALPHABET.charCodeAt(i)] = i;
      }
      ccToValue[",".charCodeAt(0)] = END_SEGMENT_BIT;
      ccToValue[";".charCodeAt(0)] = NEXT_LINE;
    }
    var ccMax = ccToValue.length - 1;
    var readMappings = (mappings, onMapping) => {
      const currentData = new Uint32Array([0, 0, 1, 0, 0]);
      let currentDataPos = 0;
      let currentValue = 0;
      let currentValuePos = 0;
      let generatedLine = 1;
      let generatedColumn = -1;
      for (let i = 0; i < mappings.length; i++) {
        const cc = mappings.charCodeAt(i);
        if (cc > ccMax)
          continue;
        const value = ccToValue[cc];
        if ((value & END_SEGMENT_BIT) !== 0) {
          if (currentData[0] > generatedColumn) {
            if (currentDataPos === 1) {
              onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
            } else if (currentDataPos === 4) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                -1
              );
            } else if (currentDataPos === 5) {
              onMapping(
                generatedLine,
                currentData[0],
                currentData[1],
                currentData[2],
                currentData[3],
                currentData[4]
              );
            }
            generatedColumn = currentData[0];
          }
          currentDataPos = 0;
          if (value === NEXT_LINE) {
            generatedLine++;
            currentData[0] = 0;
            generatedColumn = -1;
          }
        } else if ((value & CONTINUATION_BIT) === 0) {
          currentValue |= value << currentValuePos;
          const finalValue = currentValue & 1 ? -(currentValue >> 1) : currentValue >> 1;
          currentData[currentDataPos++] += finalValue;
          currentValuePos = 0;
          currentValue = 0;
        } else {
          currentValue |= (value & DATA_MASK) << currentValuePos;
          currentValuePos += 5;
        }
      }
      if (currentDataPos === 1) {
        onMapping(generatedLine, currentData[0], -1, -1, -1, -1);
      } else if (currentDataPos === 4) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          -1
        );
      } else if (currentDataPos === 5) {
        onMapping(
          generatedLine,
          currentData[0],
          currentData[1],
          currentData[2],
          currentData[3],
          currentData[4]
        );
      }
    };
    module2.exports = readMappings;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js
var require_streamChunksOfSourceMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfSourceMap.js"(exports, module2) {
    "use strict";
    var getGeneratedSourceInfo = require_getGeneratedSourceInfo();
    var getSource = require_getSource();
    var readMappings = require_readMappings();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfSourceMapFull = (source, sourceMap, onChunk, onSource, onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      let currentGeneratedLine = 1;
      let currentGeneratedColumn = 0;
      let mappingActive = false;
      let activeMappingSourceIndex = -1;
      let activeMappingOriginalLine = -1;
      let activeMappingOriginalColumn = -1;
      let activeMappingNameIndex = -1;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (mappingActive && currentGeneratedLine <= lines.length) {
          let chunk;
          const mappingLine = currentGeneratedLine;
          const mappingColumn = currentGeneratedColumn;
          const line = lines[currentGeneratedLine - 1];
          if (generatedLine !== currentGeneratedLine) {
            chunk = line.slice(currentGeneratedColumn);
            currentGeneratedLine++;
            currentGeneratedColumn = 0;
          } else {
            chunk = line.slice(currentGeneratedColumn, generatedColumn);
            currentGeneratedColumn = generatedColumn;
          }
          if (chunk) {
            onChunk(
              chunk,
              mappingLine,
              mappingColumn,
              activeMappingSourceIndex,
              activeMappingOriginalLine,
              activeMappingOriginalColumn,
              activeMappingNameIndex
            );
          }
          mappingActive = false;
        }
        if (generatedLine > currentGeneratedLine && currentGeneratedColumn > 0) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
          currentGeneratedColumn = 0;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedColumn > currentGeneratedColumn) {
          if (currentGeneratedLine <= lines.length) {
            const chunk = lines[currentGeneratedLine - 1].slice(
              currentGeneratedColumn,
              generatedColumn
            );
            onChunk(
              chunk,
              currentGeneratedLine,
              currentGeneratedColumn,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedColumn = generatedColumn;
        }
        if (sourceIndex >= 0 && (generatedLine < finalLine || generatedLine === finalLine && generatedColumn < finalColumn)) {
          mappingActive = true;
          activeMappingSourceIndex = sourceIndex;
          activeMappingOriginalLine = originalLine;
          activeMappingOriginalColumn = originalColumn;
          activeMappingNameIndex = nameIndex;
        }
      };
      readMappings(mappings, onMapping);
      onMapping(finalLine, finalColumn, -1, -1, -1, -1);
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapLinesFull = (source, sourceMap, onChunk, onSource, _onName) => {
      const lines = splitIntoLines(source);
      if (lines.length === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex < 0 || generatedLine < currentGeneratedLine || generatedLine > lines.length) {
          return;
        }
        while (generatedLine > currentGeneratedLine) {
          if (currentGeneratedLine <= lines.length) {
            onChunk(
              lines[currentGeneratedLine - 1],
              currentGeneratedLine,
              0,
              -1,
              -1,
              -1,
              -1
            );
          }
          currentGeneratedLine++;
        }
        if (generatedLine <= lines.length) {
          onChunk(
            lines[generatedLine - 1],
            generatedLine,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine++;
        }
      };
      readMappings(mappings, onMapping);
      for (; currentGeneratedLine <= lines.length; currentGeneratedLine++) {
        onChunk(
          lines[currentGeneratedLine - 1],
          currentGeneratedLine,
          0,
          -1,
          -1,
          -1,
          -1
        );
      }
      const lastLine = lines[lines.length - 1];
      const lastNewLine = lastLine.endsWith("\n");
      const finalLine = lastNewLine ? lines.length + 1 : lines.length;
      const finalColumn = lastNewLine ? 0 : lastLine.length;
      return {
        generatedLine: finalLine,
        generatedColumn: finalColumn
      };
    };
    var streamChunksOfSourceMapFinal = (source, sourceMap, onChunk, onSource, onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine: finalLine, generatedColumn: finalColumn } = result;
      if (finalLine === 1 && finalColumn === 0)
        return result;
      const { sources, sourcesContent, names, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      if (names) {
        for (let i = 0; i < names.length; i++) {
          onName(i, names[i]);
        }
      }
      let mappingActiveLine = 0;
      const onMapping = (generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
        if (generatedLine >= finalLine && (generatedColumn >= finalColumn || generatedLine > finalLine)) {
          return;
        }
        if (sourceIndex >= 0) {
          onChunk(
            void 0,
            generatedLine,
            generatedColumn,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          mappingActiveLine = generatedLine;
        } else if (mappingActiveLine === generatedLine) {
          onChunk(void 0, generatedLine, generatedColumn, -1, -1, -1, -1);
          mappingActiveLine = 0;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    var streamChunksOfSourceMapLinesFinal = (source, sourceMap, onChunk, onSource, _onName) => {
      const result = getGeneratedSourceInfo(source);
      const { generatedLine, generatedColumn } = result;
      if (generatedLine === 1 && generatedColumn === 0) {
        return {
          generatedLine: 1,
          generatedColumn: 0
        };
      }
      const { sources, sourcesContent, mappings } = sourceMap;
      for (let i = 0; i < sources.length; i++) {
        onSource(
          i,
          getSource(sourceMap, i),
          sourcesContent && sourcesContent[i] || void 0
        );
      }
      const finalLine = generatedColumn === 0 ? generatedLine - 1 : generatedLine;
      let currentGeneratedLine = 1;
      const onMapping = (generatedLine2, _generatedColumn, sourceIndex, originalLine, originalColumn, _nameIndex) => {
        if (sourceIndex >= 0 && currentGeneratedLine <= generatedLine2 && generatedLine2 <= finalLine) {
          onChunk(
            void 0,
            generatedLine2,
            0,
            sourceIndex,
            originalLine,
            originalColumn,
            -1
          );
          currentGeneratedLine = generatedLine2 + 1;
        }
      };
      readMappings(mappings, onMapping);
      return result;
    };
    module2.exports = (source, sourceMap, onChunk, onSource, onName, finalSource, columns) => {
      if (columns) {
        return finalSource ? streamChunksOfSourceMapFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      } else {
        return finalSource ? streamChunksOfSourceMapLinesFinal(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        ) : streamChunksOfSourceMapLinesFull(
          source,
          sourceMap,
          onChunk,
          onSource,
          onName
        );
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js
var require_streamChunksOfCombinedSourceMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunksOfCombinedSourceMap.js"(exports, module2) {
    "use strict";
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var splitIntoLines = require_splitIntoLines();
    var streamChunksOfCombinedSourceMap = (source, sourceMap, innerSourceName, innerSource, innerSourceMap, removeInnerSource, onChunk, onSource, onName, finalSource, columns) => {
      let sourceMapping = /* @__PURE__ */ new Map();
      let nameMapping = /* @__PURE__ */ new Map();
      const sourceIndexMapping = [];
      const nameIndexMapping = [];
      const nameIndexValueMapping = [];
      let innerSourceIndex = -2;
      const innerSourceIndexMapping = [];
      const innerSourceIndexValueMapping = [];
      const innerSourceContents = [];
      const innerSourceContentLines = [];
      const innerNameIndexMapping = [];
      const innerNameIndexValueMapping = [];
      const innerSourceMapLineData = [];
      const findInnerMapping = (line, column) => {
        if (line > innerSourceMapLineData.length)
          return -1;
        const { mappingsData } = innerSourceMapLineData[line - 1];
        let l = 0;
        let r = mappingsData.length / 5;
        while (l < r) {
          let m = l + r >> 1;
          if (mappingsData[m * 5] <= column) {
            l = m + 1;
          } else {
            r = m;
          }
        }
        if (l === 0)
          return -1;
        return l - 1;
      };
      return streamChunksOfSourceMap(
        source,
        sourceMap,
        (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (sourceIndex === innerSourceIndex) {
            const idx = findInnerMapping(originalLine, originalColumn);
            if (idx !== -1) {
              const { chunks, mappingsData } = innerSourceMapLineData[originalLine - 1];
              const mi = idx * 5;
              const innerSourceIndex2 = mappingsData[mi + 1];
              const innerOriginalLine = mappingsData[mi + 2];
              let innerOriginalColumn = mappingsData[mi + 3];
              let innerNameIndex = mappingsData[mi + 4];
              if (innerSourceIndex2 >= 0) {
                const innerChunk = chunks[idx];
                const innerGeneratedColumn = mappingsData[mi];
                const locationInChunk = originalColumn - innerGeneratedColumn;
                if (locationInChunk > 0) {
                  let originalSourceLines = innerSourceIndex2 < innerSourceContentLines.length ? innerSourceContentLines[innerSourceIndex2] : null;
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const originalChunk = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + locationInChunk
                    ) : "";
                    if (innerChunk.slice(0, locationInChunk) === originalChunk) {
                      innerOriginalColumn += locationInChunk;
                      innerNameIndex = -1;
                    }
                  }
                }
                let sourceIndex2 = innerSourceIndex2 < innerSourceIndexMapping.length ? innerSourceIndexMapping[innerSourceIndex2] : -2;
                if (sourceIndex2 === -2) {
                  const [source2, sourceContent] = innerSourceIndex2 < innerSourceIndexValueMapping.length ? innerSourceIndexValueMapping[innerSourceIndex2] : [null, void 0];
                  let globalIndex = sourceMapping.get(source2);
                  if (globalIndex === void 0) {
                    sourceMapping.set(source2, globalIndex = sourceMapping.size);
                    onSource(globalIndex, source2, sourceContent);
                  }
                  sourceIndex2 = globalIndex;
                  innerSourceIndexMapping[innerSourceIndex2] = sourceIndex2;
                }
                let finalNameIndex = -1;
                if (innerNameIndex >= 0) {
                  finalNameIndex = innerNameIndex < innerNameIndexMapping.length ? innerNameIndexMapping[innerNameIndex] : -2;
                  if (finalNameIndex === -2) {
                    const name = innerNameIndex < innerNameIndexValueMapping.length ? innerNameIndexValueMapping[innerNameIndex] : void 0;
                    if (name) {
                      let globalIndex = nameMapping.get(name);
                      if (globalIndex === void 0) {
                        nameMapping.set(name, globalIndex = nameMapping.size);
                        onName(globalIndex, name);
                      }
                      finalNameIndex = globalIndex;
                    } else {
                      finalNameIndex = -1;
                    }
                    innerNameIndexMapping[innerNameIndex] = finalNameIndex;
                  }
                } else if (nameIndex >= 0) {
                  let originalSourceLines = innerSourceContentLines[innerSourceIndex2];
                  if (originalSourceLines === void 0) {
                    const originalSource = innerSourceContents[innerSourceIndex2];
                    originalSourceLines = originalSource ? splitIntoLines(originalSource) : null;
                    innerSourceContentLines[innerSourceIndex2] = originalSourceLines;
                  }
                  if (originalSourceLines !== null) {
                    const name = nameIndexValueMapping[nameIndex];
                    const originalName = innerOriginalLine <= originalSourceLines.length ? originalSourceLines[innerOriginalLine - 1].slice(
                      innerOriginalColumn,
                      innerOriginalColumn + name.length
                    ) : "";
                    if (name === originalName) {
                      finalNameIndex = nameIndex < nameIndexMapping.length ? nameIndexMapping[nameIndex] : -2;
                      if (finalNameIndex === -2) {
                        const name2 = nameIndexValueMapping[nameIndex];
                        if (name2) {
                          let globalIndex = nameMapping.get(name2);
                          if (globalIndex === void 0) {
                            nameMapping.set(name2, globalIndex = nameMapping.size);
                            onName(globalIndex, name2);
                          }
                          finalNameIndex = globalIndex;
                        } else {
                          finalNameIndex = -1;
                        }
                        nameIndexMapping[nameIndex] = finalNameIndex;
                      }
                    }
                  }
                }
                onChunk(
                  chunk,
                  generatedLine,
                  generatedColumn,
                  sourceIndex2,
                  innerOriginalLine,
                  innerOriginalColumn,
                  finalNameIndex
                );
                return;
              }
            }
            if (removeInnerSource) {
              onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
              return;
            } else {
              if (sourceIndexMapping[sourceIndex] === -2) {
                let globalIndex = sourceMapping.get(innerSourceName);
                if (globalIndex === void 0) {
                  sourceMapping.set(source, globalIndex = sourceMapping.size);
                  onSource(globalIndex, innerSourceName, innerSource);
                }
                sourceIndexMapping[sourceIndex] = globalIndex;
              }
            }
          }
          const finalSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
          if (finalSourceIndex < 0) {
            onChunk(chunk, generatedLine, generatedColumn, -1, -1, -1, -1);
          } else {
            let finalNameIndex = -1;
            if (nameIndex >= 0 && nameIndex < nameIndexMapping.length) {
              finalNameIndex = nameIndexMapping[nameIndex];
              if (finalNameIndex === -2) {
                const name = nameIndexValueMapping[nameIndex];
                let globalIndex = nameMapping.get(name);
                if (globalIndex === void 0) {
                  nameMapping.set(name, globalIndex = nameMapping.size);
                  onName(globalIndex, name);
                }
                finalNameIndex = globalIndex;
                nameIndexMapping[nameIndex] = finalNameIndex;
              }
            }
            onChunk(
              chunk,
              generatedLine,
              generatedColumn,
              finalSourceIndex,
              originalLine,
              originalColumn,
              finalNameIndex
            );
          }
        },
        (i, source2, sourceContent) => {
          if (source2 === innerSourceName) {
            innerSourceIndex = i;
            if (innerSource !== void 0)
              sourceContent = innerSource;
            else
              innerSource = sourceContent;
            sourceIndexMapping[i] = -2;
            streamChunksOfSourceMap(
              sourceContent,
              innerSourceMap,
              (chunk, generatedLine, generatedColumn, sourceIndex, originalLine, originalColumn, nameIndex) => {
                while (innerSourceMapLineData.length < generatedLine) {
                  innerSourceMapLineData.push({
                    mappingsData: [],
                    chunks: []
                  });
                }
                const data = innerSourceMapLineData[generatedLine - 1];
                data.mappingsData.push(
                  generatedColumn,
                  sourceIndex,
                  originalLine,
                  originalColumn,
                  nameIndex
                );
                data.chunks.push(chunk);
              },
              (i2, source3, sourceContent2) => {
                innerSourceContents[i2] = sourceContent2;
                innerSourceContentLines[i2] = void 0;
                innerSourceIndexMapping[i2] = -2;
                innerSourceIndexValueMapping[i2] = [source3, sourceContent2];
              },
              (i2, name) => {
                innerNameIndexMapping[i2] = -2;
                innerNameIndexValueMapping[i2] = name;
              },
              false,
              columns
            );
          } else {
            let globalIndex = sourceMapping.get(source2);
            if (globalIndex === void 0) {
              sourceMapping.set(source2, globalIndex = sourceMapping.size);
              onSource(globalIndex, source2, sourceContent);
            }
            sourceIndexMapping[i] = globalIndex;
          }
        },
        (i, name) => {
          nameIndexMapping[i] = -2;
          nameIndexValueMapping[i] = name;
        },
        finalSource,
        columns
      );
    };
    module2.exports = streamChunksOfCombinedSourceMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js
var require_SourceMapSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SourceMapSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfCombinedSourceMap = require_streamChunksOfCombinedSourceMap();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var SourceMapSource2 = class extends Source3 {
      constructor(value, name, sourceMap, originalSource, innerSourceMap, removeOriginalSource) {
        super();
        const valueIsBuffer = Buffer.isBuffer(value);
        this._valueAsString = valueIsBuffer ? void 0 : value;
        this._valueAsBuffer = valueIsBuffer ? value : void 0;
        this._name = name;
        this._hasSourceMap = !!sourceMap;
        const sourceMapIsBuffer = Buffer.isBuffer(sourceMap);
        const sourceMapIsString = typeof sourceMap === "string";
        this._sourceMapAsObject = sourceMapIsBuffer || sourceMapIsString ? void 0 : sourceMap;
        this._sourceMapAsString = sourceMapIsString ? sourceMap : void 0;
        this._sourceMapAsBuffer = sourceMapIsBuffer ? sourceMap : void 0;
        this._hasOriginalSource = !!originalSource;
        const originalSourceIsBuffer = Buffer.isBuffer(originalSource);
        this._originalSourceAsString = originalSourceIsBuffer ? void 0 : originalSource;
        this._originalSourceAsBuffer = originalSourceIsBuffer ? originalSource : void 0;
        this._hasInnerSourceMap = !!innerSourceMap;
        const innerSourceMapIsBuffer = Buffer.isBuffer(innerSourceMap);
        const innerSourceMapIsString = typeof innerSourceMap === "string";
        this._innerSourceMapAsObject = innerSourceMapIsBuffer || innerSourceMapIsString ? void 0 : innerSourceMap;
        this._innerSourceMapAsString = innerSourceMapIsString ? innerSourceMap : void 0;
        this._innerSourceMapAsBuffer = innerSourceMapIsBuffer ? innerSourceMap : void 0;
        this._removeOriginalSource = removeOriginalSource;
      }
      _ensureValueBuffer() {
        if (this._valueAsBuffer === void 0) {
          this._valueAsBuffer = Buffer.from(this._valueAsString, "utf-8");
        }
      }
      _ensureValueString() {
        if (this._valueAsString === void 0) {
          this._valueAsString = this._valueAsBuffer.toString("utf-8");
        }
      }
      _ensureOriginalSourceBuffer() {
        if (this._originalSourceAsBuffer === void 0 && this._hasOriginalSource) {
          this._originalSourceAsBuffer = Buffer.from(
            this._originalSourceAsString,
            "utf-8"
          );
        }
      }
      _ensureOriginalSourceString() {
        if (this._originalSourceAsString === void 0 && this._hasOriginalSource) {
          this._originalSourceAsString = this._originalSourceAsBuffer.toString(
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapObject() {
        if (this._innerSourceMapAsObject === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsObject = JSON.parse(this._innerSourceMapAsString);
        }
      }
      _ensureInnerSourceMapBuffer() {
        if (this._innerSourceMapAsBuffer === void 0 && this._hasInnerSourceMap) {
          this._ensureInnerSourceMapString();
          this._innerSourceMapAsBuffer = Buffer.from(
            this._innerSourceMapAsString,
            "utf-8"
          );
        }
      }
      _ensureInnerSourceMapString() {
        if (this._innerSourceMapAsString === void 0 && this._hasInnerSourceMap) {
          if (this._innerSourceMapAsBuffer !== void 0) {
            this._innerSourceMapAsString = this._innerSourceMapAsBuffer.toString(
              "utf-8"
            );
          } else {
            this._innerSourceMapAsString = JSON.stringify(
              this._innerSourceMapAsObject
            );
          }
        }
      }
      _ensureSourceMapObject() {
        if (this._sourceMapAsObject === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsObject = JSON.parse(this._sourceMapAsString);
        }
      }
      _ensureSourceMapBuffer() {
        if (this._sourceMapAsBuffer === void 0) {
          this._ensureSourceMapString();
          this._sourceMapAsBuffer = Buffer.from(this._sourceMapAsString, "utf-8");
        }
      }
      _ensureSourceMapString() {
        if (this._sourceMapAsString === void 0) {
          if (this._sourceMapAsBuffer !== void 0) {
            this._sourceMapAsString = this._sourceMapAsBuffer.toString("utf-8");
          } else {
            this._sourceMapAsString = JSON.stringify(this._sourceMapAsObject);
          }
        }
      }
      getArgsAsBuffers() {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        return [
          this._valueAsBuffer,
          this._name,
          this._sourceMapAsBuffer,
          this._originalSourceAsBuffer,
          this._innerSourceMapAsBuffer,
          this._removeOriginalSource
        ];
      }
      buffer() {
        this._ensureValueBuffer();
        return this._valueAsBuffer;
      }
      source() {
        this._ensureValueString();
        return this._valueAsString;
      }
      map(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureSourceMapObject();
          return this._sourceMapAsObject;
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (!this._hasInnerSourceMap) {
          this._ensureValueString();
          this._ensureSourceMapObject();
          return {
            source: this._valueAsString,
            map: this._sourceMapAsObject
          };
        }
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._ensureValueString();
        this._ensureSourceMapObject();
        this._ensureOriginalSourceString();
        if (this._hasInnerSourceMap) {
          this._ensureInnerSourceMapObject();
          return streamChunksOfCombinedSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            this._name,
            this._originalSourceAsString,
            this._innerSourceMapAsObject,
            this._removeOriginalSource,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfSourceMap(
            this._valueAsString,
            this._sourceMapAsObject,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        }
      }
      updateHash(hash) {
        this._ensureValueBuffer();
        this._ensureSourceMapBuffer();
        this._ensureOriginalSourceBuffer();
        this._ensureInnerSourceMapBuffer();
        hash.update("SourceMapSource");
        hash.update(this._valueAsBuffer);
        hash.update(this._sourceMapAsBuffer);
        if (this._hasOriginalSource) {
          hash.update(this._originalSourceAsBuffer);
        }
        if (this._hasInnerSourceMap) {
          hash.update(this._innerSourceMapAsBuffer);
        }
        hash.update(this._removeOriginalSource ? "true" : "false");
      }
    };
    module2.exports = SourceMapSource2;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js
var require_streamChunks = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamChunks.js"(exports, module2) {
    "use strict";
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    module2.exports = (source, options, onChunk, onSource, onName) => {
      if (typeof source.streamChunks === "function") {
        return source.streamChunks(options, onChunk, onSource, onName);
      } else {
        const sourceAndMap = source.sourceAndMap(options);
        if (sourceAndMap.map) {
          return streamChunksOfSourceMap(
            sourceAndMap.source,
            sourceAndMap.map,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource),
            !!(options && options.columns !== false)
          );
        } else {
          return streamChunksOfRawSource(
            sourceAndMap.source,
            onChunk,
            onSource,
            onName,
            !!(options && options.finalSource)
          );
        }
      }
    };
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js
var require_streamAndGetSourceAndMap = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/helpers/streamAndGetSourceAndMap.js"(exports, module2) {
    "use strict";
    var createMappingsSerializer = require_createMappingsSerializer();
    var streamChunks = require_streamChunks();
    var streamAndGetSourceAndMap = (inputSource, options, onChunk, onSource, onName) => {
      let code = "";
      let mappings = "";
      let sources = [];
      let sourcesContent = [];
      let names = [];
      const addMapping = createMappingsSerializer(
        Object.assign({}, options, { columns: true })
      );
      const finalSource = !!(options && options.finalSource);
      const { generatedLine, generatedColumn, source } = streamChunks(
        inputSource,
        options,
        (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
          if (chunk !== void 0)
            code += chunk;
          mappings += addMapping(
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
          return onChunk(
            finalSource ? void 0 : chunk,
            generatedLine2,
            generatedColumn2,
            sourceIndex,
            originalLine,
            originalColumn,
            nameIndex
          );
        },
        (sourceIndex, source2, sourceContent) => {
          while (sources.length < sourceIndex) {
            sources.push(null);
          }
          sources[sourceIndex] = source2;
          if (sourceContent !== void 0) {
            while (sourcesContent.length < sourceIndex) {
              sourcesContent.push(null);
            }
            sourcesContent[sourceIndex] = sourceContent;
          }
          return onSource(sourceIndex, source2, sourceContent);
        },
        (nameIndex, name) => {
          while (names.length < nameIndex) {
            names.push(null);
          }
          names[nameIndex] = name;
          return onName(nameIndex, name);
        }
      );
      const resultSource = source !== void 0 ? source : code;
      return {
        result: {
          generatedLine,
          generatedColumn,
          source: finalSource ? resultSource : void 0
        },
        source: resultSource,
        map: mappings.length > 0 ? {
          version: 3,
          file: "x",
          mappings,
          sources,
          sourcesContent: sourcesContent.length > 0 ? sourcesContent : void 0,
          names
        } : null
      };
    };
    module2.exports = streamAndGetSourceAndMap;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js
var require_CachedSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CachedSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var streamChunksOfSourceMap = require_streamChunksOfSourceMap();
    var streamChunksOfRawSource = require_streamChunksOfRawSource();
    var streamAndGetSourceAndMap = require_streamAndGetSourceAndMap();
    var mapToBufferedMap = (map) => {
      if (typeof map !== "object" || !map)
        return map;
      const bufferedMap = Object.assign({}, map);
      if (map.mappings) {
        bufferedMap.mappings = Buffer.from(map.mappings, "utf-8");
      }
      if (map.sourcesContent) {
        bufferedMap.sourcesContent = map.sourcesContent.map(
          (str) => str && Buffer.from(str, "utf-8")
        );
      }
      return bufferedMap;
    };
    var bufferedMapToMap = (bufferedMap) => {
      if (typeof bufferedMap !== "object" || !bufferedMap)
        return bufferedMap;
      const map = Object.assign({}, bufferedMap);
      if (bufferedMap.mappings) {
        map.mappings = bufferedMap.mappings.toString("utf-8");
      }
      if (bufferedMap.sourcesContent) {
        map.sourcesContent = bufferedMap.sourcesContent.map(
          (buffer) => buffer && buffer.toString("utf-8")
        );
      }
      return map;
    };
    var CachedSource = class extends Source3 {
      constructor(source, cachedData) {
        super();
        this._source = source;
        this._cachedSourceType = cachedData ? cachedData.source : void 0;
        this._cachedSource = void 0;
        this._cachedBuffer = cachedData ? cachedData.buffer : void 0;
        this._cachedSize = cachedData ? cachedData.size : void 0;
        this._cachedMaps = cachedData ? cachedData.maps : /* @__PURE__ */ new Map();
        this._cachedHashUpdate = cachedData ? cachedData.hash : void 0;
      }
      getCachedData() {
        const bufferedMaps = /* @__PURE__ */ new Map();
        for (const pair of this._cachedMaps) {
          let cacheEntry = pair[1];
          if (cacheEntry.bufferedMap === void 0) {
            cacheEntry.bufferedMap = mapToBufferedMap(
              this._getMapFromCacheEntry(cacheEntry)
            );
          }
          bufferedMaps.set(pair[0], {
            map: void 0,
            bufferedMap: cacheEntry.bufferedMap
          });
        }
        if (this._cachedSource) {
          this.buffer();
        }
        return {
          buffer: this._cachedBuffer,
          source: this._cachedSourceType !== void 0 ? this._cachedSourceType : typeof this._cachedSource === "string" ? true : Buffer.isBuffer(this._cachedSource) ? false : void 0,
          size: this._cachedSize,
          maps: bufferedMaps,
          hash: this._cachedHashUpdate
        };
      }
      originalLazy() {
        return this._source;
      }
      original() {
        if (typeof this._source === "function")
          this._source = this._source();
        return this._source;
      }
      source() {
        const source = this._getCachedSource();
        if (source !== void 0)
          return source;
        return this._cachedSource = this.original().source();
      }
      _getMapFromCacheEntry(cacheEntry) {
        if (cacheEntry.map !== void 0) {
          return cacheEntry.map;
        } else if (cacheEntry.bufferedMap !== void 0) {
          return cacheEntry.map = bufferedMapToMap(cacheEntry.bufferedMap);
        }
      }
      _getCachedSource() {
        if (this._cachedSource !== void 0)
          return this._cachedSource;
        if (this._cachedBuffer && this._cachedSourceType !== void 0) {
          return this._cachedSource = this._cachedSourceType ? this._cachedBuffer.toString("utf-8") : this._cachedBuffer;
        }
      }
      buffer() {
        if (this._cachedBuffer !== void 0)
          return this._cachedBuffer;
        if (this._cachedSource !== void 0) {
          if (Buffer.isBuffer(this._cachedSource)) {
            return this._cachedBuffer = this._cachedSource;
          }
          return this._cachedBuffer = Buffer.from(this._cachedSource, "utf-8");
        }
        if (typeof this.original().buffer === "function") {
          return this._cachedBuffer = this.original().buffer();
        }
        const bufferOrString = this.source();
        if (Buffer.isBuffer(bufferOrString)) {
          return this._cachedBuffer = bufferOrString;
        }
        return this._cachedBuffer = Buffer.from(bufferOrString, "utf-8");
      }
      size() {
        if (this._cachedSize !== void 0)
          return this._cachedSize;
        if (this._cachedBuffer !== void 0) {
          return this._cachedSize = this._cachedBuffer.length;
        }
        const source = this._getCachedSource();
        if (source !== void 0) {
          return this._cachedSize = Buffer.byteLength(source);
        }
        return this._cachedSize = this.original().size();
      }
      sourceAndMap(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          const map2 = this._getMapFromCacheEntry(cacheEntry);
          return { source: this.source(), map: map2 };
        }
        let source = this._getCachedSource();
        let map;
        if (source !== void 0) {
          map = this.original().map(options);
        } else {
          const sourceAndMap = this.original().sourceAndMap(options);
          source = sourceAndMap.source;
          map = sourceAndMap.map;
          this._cachedSource = source;
        }
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return { source, map };
      }
      streamChunks(options, onChunk, onSource, onName) {
        const key = options ? JSON.stringify(options) : "{}";
        if (this._cachedMaps.has(key) && (this._cachedBuffer !== void 0 || this._cachedSource !== void 0)) {
          const { source: source2, map: map2 } = this.sourceAndMap(options);
          if (map2) {
            return streamChunksOfSourceMap(
              source2,
              map2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource),
              true
            );
          } else {
            return streamChunksOfRawSource(
              source2,
              onChunk,
              onSource,
              onName,
              !!(options && options.finalSource)
            );
          }
        }
        const { result, source, map } = streamAndGetSourceAndMap(
          this.original(),
          options,
          onChunk,
          onSource,
          onName
        );
        this._cachedSource = source;
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return result;
      }
      map(options) {
        const key = options ? JSON.stringify(options) : "{}";
        const cacheEntry = this._cachedMaps.get(key);
        if (cacheEntry !== void 0) {
          return this._getMapFromCacheEntry(cacheEntry);
        }
        const map = this.original().map(options);
        this._cachedMaps.set(key, {
          map,
          bufferedMap: void 0
        });
        return map;
      }
      updateHash(hash) {
        if (this._cachedHashUpdate !== void 0) {
          for (const item of this._cachedHashUpdate)
            hash.update(item);
          return;
        }
        const update = [];
        let currentString = void 0;
        const tracker = {
          update: (item) => {
            if (typeof item === "string" && item.length < 10240) {
              if (currentString === void 0) {
                currentString = item;
              } else {
                currentString += item;
                if (currentString.length > 102400) {
                  update.push(Buffer.from(currentString));
                  currentString = void 0;
                }
              }
            } else {
              if (currentString !== void 0) {
                update.push(Buffer.from(currentString));
                currentString = void 0;
              }
              update.push(item);
            }
          }
        };
        this.original().updateHash(tracker);
        if (currentString !== void 0) {
          update.push(Buffer.from(currentString));
        }
        for (const item of update)
          hash.update(item);
        this._cachedHashUpdate = update;
      }
    };
    module2.exports = CachedSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js
var require_ConcatSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ConcatSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var stringsAsRawSources = /* @__PURE__ */ new WeakSet();
    var ConcatSource3 = class _ConcatSource extends Source3 {
      constructor() {
        super();
        this._children = [];
        for (let i = 0; i < arguments.length; i++) {
          const item = arguments[i];
          if (item instanceof _ConcatSource) {
            for (const child of item._children) {
              this._children.push(child);
            }
          } else {
            this._children.push(item);
          }
        }
        this._isOptimized = arguments.length === 0;
      }
      getChildren() {
        if (!this._isOptimized)
          this._optimize();
        return this._children;
      }
      add(item) {
        if (item instanceof _ConcatSource) {
          for (const child of item._children) {
            this._children.push(child);
          }
        } else {
          this._children.push(item);
        }
        this._isOptimized = false;
      }
      addAllSkipOptimizing(items) {
        for (const item of items) {
          this._children.push(item);
        }
      }
      buffer() {
        if (!this._isOptimized)
          this._optimize();
        const buffers = [];
        for (const child of this._children) {
          if (typeof child.buffer === "function") {
            buffers.push(child.buffer());
          } else {
            const bufferOrString = child.source();
            if (Buffer.isBuffer(bufferOrString)) {
              buffers.push(bufferOrString);
            } else {
              buffers.push(Buffer.from(bufferOrString, "utf-8"));
            }
          }
        }
        return Buffer.concat(buffers);
      }
      source() {
        if (!this._isOptimized)
          this._optimize();
        let source = "";
        for (const child of this._children) {
          source += child.source();
        }
        return source;
      }
      size() {
        if (!this._isOptimized)
          this._optimize();
        let size = 0;
        for (const child of this._children) {
          size += child.size();
        }
        return size;
      }
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        if (!this._isOptimized)
          this._optimize();
        if (this._children.length === 1)
          return this._children[0].streamChunks(options, onChunk, onSource, onName);
        let currentLineOffset = 0;
        let currentColumnOffset = 0;
        let sourceMapping = /* @__PURE__ */ new Map();
        let nameMapping = /* @__PURE__ */ new Map();
        const finalSource = !!(options && options.finalSource);
        let code = "";
        let needToCloseMapping = false;
        for (const item of this._children) {
          const sourceIndexMapping = [];
          const nameIndexMapping = [];
          let lastMappingLine = 0;
          const { generatedLine, generatedColumn, source } = streamChunks(
            item,
            options,
            // eslint-disable-next-line no-loop-func
            (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
              const line = generatedLine2 + currentLineOffset;
              const column = generatedLine2 === 1 ? generatedColumn2 + currentColumnOffset : generatedColumn2;
              if (needToCloseMapping) {
                if (generatedLine2 !== 1 || generatedColumn2 !== 0) {
                  onChunk(
                    void 0,
                    currentLineOffset + 1,
                    currentColumnOffset,
                    -1,
                    -1,
                    -1,
                    -1
                  );
                }
                needToCloseMapping = false;
              }
              const resultSourceIndex = sourceIndex < 0 || sourceIndex >= sourceIndexMapping.length ? -1 : sourceIndexMapping[sourceIndex];
              const resultNameIndex = nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex];
              lastMappingLine = resultSourceIndex < 0 ? 0 : generatedLine2;
              if (finalSource) {
                if (chunk !== void 0)
                  code += chunk;
                if (resultSourceIndex >= 0) {
                  onChunk(
                    void 0,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              } else {
                if (resultSourceIndex < 0) {
                  onChunk(chunk, line, column, -1, -1, -1, -1);
                } else {
                  onChunk(
                    chunk,
                    line,
                    column,
                    resultSourceIndex,
                    originalLine,
                    originalColumn,
                    resultNameIndex
                  );
                }
              }
            },
            (i, source2, sourceContent) => {
              let globalIndex = sourceMapping.get(source2);
              if (globalIndex === void 0) {
                sourceMapping.set(source2, globalIndex = sourceMapping.size);
                onSource(globalIndex, source2, sourceContent);
              }
              sourceIndexMapping[i] = globalIndex;
            },
            (i, name) => {
              let globalIndex = nameMapping.get(name);
              if (globalIndex === void 0) {
                nameMapping.set(name, globalIndex = nameMapping.size);
                onName(globalIndex, name);
              }
              nameIndexMapping[i] = globalIndex;
            }
          );
          if (source !== void 0)
            code += source;
          if (needToCloseMapping) {
            if (generatedLine !== 1 || generatedColumn !== 0) {
              onChunk(
                void 0,
                currentLineOffset + 1,
                currentColumnOffset,
                -1,
                -1,
                -1,
                -1
              );
              needToCloseMapping = false;
            }
          }
          if (generatedLine > 1) {
            currentColumnOffset = generatedColumn;
          } else {
            currentColumnOffset += generatedColumn;
          }
          needToCloseMapping = needToCloseMapping || finalSource && lastMappingLine === generatedLine;
          currentLineOffset += generatedLine - 1;
        }
        return {
          generatedLine: currentLineOffset + 1,
          generatedColumn: currentColumnOffset,
          source: finalSource ? code : void 0
        };
      }
      updateHash(hash) {
        if (!this._isOptimized)
          this._optimize();
        hash.update("ConcatSource");
        for (const item of this._children) {
          item.updateHash(hash);
        }
      }
      _optimize() {
        const newChildren = [];
        let currentString = void 0;
        let currentRawSources = void 0;
        const addStringToRawSources = (string) => {
          if (currentRawSources === void 0) {
            currentRawSources = string;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(string);
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              string
            ];
          }
        };
        const addSourceToRawSources = (source) => {
          if (currentRawSources === void 0) {
            currentRawSources = source;
          } else if (Array.isArray(currentRawSources)) {
            currentRawSources.push(source.source());
          } else {
            currentRawSources = [
              typeof currentRawSources === "string" ? currentRawSources : currentRawSources.source(),
              source.source()
            ];
          }
        };
        const mergeRawSources = () => {
          if (Array.isArray(currentRawSources)) {
            const rawSource = new RawSource(currentRawSources.join(""));
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else if (typeof currentRawSources === "string") {
            const rawSource = new RawSource(currentRawSources);
            stringsAsRawSources.add(rawSource);
            newChildren.push(rawSource);
          } else {
            newChildren.push(currentRawSources);
          }
        };
        for (const child of this._children) {
          if (typeof child === "string") {
            if (currentString === void 0) {
              currentString = child;
            } else {
              currentString += child;
            }
          } else {
            if (currentString !== void 0) {
              addStringToRawSources(currentString);
              currentString = void 0;
            }
            if (stringsAsRawSources.has(child)) {
              addSourceToRawSources(child);
            } else {
              if (currentRawSources !== void 0) {
                mergeRawSources();
                currentRawSources = void 0;
              }
              newChildren.push(child);
            }
          }
        }
        if (currentString !== void 0) {
          addStringToRawSources(currentString);
        }
        if (currentRawSources !== void 0) {
          mergeRawSources();
        }
        this._children = newChildren;
        this._isOptimized = true;
      }
    };
    module2.exports = ConcatSource3;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js
var require_ReplaceSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/ReplaceSource.js"(exports, module2) {
    "use strict";
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var streamChunks = require_streamChunks();
    var Source3 = require_Source();
    var splitIntoLines = require_splitIntoLines();
    var hasStableSort = typeof process === "object" && process.versions && typeof process.versions.v8 === "string" && !/^[0-6]\./.test(process.versions.v8);
    var MAX_SOURCE_POSITION = 536870912;
    var Replacement = class {
      constructor(start, end, content, name) {
        this.start = start;
        this.end = end;
        this.content = content;
        this.name = name;
        if (!hasStableSort) {
          this.index = -1;
        }
      }
    };
    var ReplaceSource = class extends Source3 {
      constructor(source, name) {
        super();
        this._source = source;
        this._name = name;
        this._replacements = [];
        this._isSorted = true;
      }
      getName() {
        return this._name;
      }
      getReplacements() {
        this._sortReplacements();
        return this._replacements;
      }
      replace(start, end, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue
          );
        this._replacements.push(new Replacement(start, end, newValue, name));
        this._isSorted = false;
      }
      insert(pos, newValue, name) {
        if (typeof newValue !== "string")
          throw new Error(
            "insertion must be a string, but is a " + typeof newValue + ": " + newValue
          );
        this._replacements.push(new Replacement(pos, pos - 1, newValue, name));
        this._isSorted = false;
      }
      source() {
        if (this._replacements.length === 0) {
          return this._source.source();
        }
        let current = this._source.source();
        let pos = 0;
        const result = [];
        this._sortReplacements();
        for (const replacement of this._replacements) {
          const start = Math.floor(replacement.start);
          const end = Math.floor(replacement.end + 1);
          if (pos < start) {
            const offset = start - pos;
            result.push(current.slice(0, offset));
            current = current.slice(offset);
            pos = start;
          }
          result.push(replacement.content);
          if (pos < end) {
            const offset = end - pos;
            current = current.slice(offset);
            pos = end;
          }
        }
        result.push(current);
        return result.join("");
      }
      map(options) {
        if (this._replacements.length === 0) {
          return this._source.map(options);
        }
        return getMap(this, options);
      }
      sourceAndMap(options) {
        if (this._replacements.length === 0) {
          return this._source.sourceAndMap(options);
        }
        return getSourceAndMap(this, options);
      }
      original() {
        return this._source;
      }
      _sortReplacements() {
        if (this._isSorted)
          return;
        if (hasStableSort) {
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0)
              return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0)
              return diff2;
            return 0;
          });
        } else {
          this._replacements.forEach((repl, i) => repl.index = i);
          this._replacements.sort(function(a, b) {
            const diff1 = a.start - b.start;
            if (diff1 !== 0)
              return diff1;
            const diff2 = a.end - b.end;
            if (diff2 !== 0)
              return diff2;
            return a.index - b.index;
          });
        }
        this._isSorted = true;
      }
      streamChunks(options, onChunk, onSource, onName) {
        this._sortReplacements();
        const repls = this._replacements;
        let pos = 0;
        let i = 0;
        let replacmentEnd = -1;
        let nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
        let generatedLineOffset = 0;
        let generatedColumnOffset = 0;
        let generatedColumnOffsetLine = 0;
        const sourceContents = [];
        const nameMapping = /* @__PURE__ */ new Map();
        const nameIndexMapping = [];
        const checkOriginalContent = (sourceIndex, line2, column, expectedChunk) => {
          let content = sourceIndex < sourceContents.length ? sourceContents[sourceIndex] : void 0;
          if (content === void 0)
            return false;
          if (typeof content === "string") {
            content = splitIntoLines(content);
            sourceContents[sourceIndex] = content;
          }
          const contentLine = line2 <= content.length ? content[line2 - 1] : null;
          if (contentLine === null)
            return false;
          return contentLine.slice(column, column + expectedChunk.length) === expectedChunk;
        };
        let { generatedLine, generatedColumn } = streamChunks(
          this._source,
          Object.assign({}, options, { finalSource: false }),
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            let chunkPos = 0;
            let endPos = pos + chunk.length;
            if (replacmentEnd > pos) {
              if (replacmentEnd >= endPos) {
                const line3 = generatedLine2 + generatedLineOffset;
                if (chunk.endsWith("\n")) {
                  generatedLineOffset--;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset += generatedColumn2;
                  }
                } else if (generatedColumnOffsetLine === line3) {
                  generatedColumnOffset -= chunk.length;
                } else {
                  generatedColumnOffset = -chunk.length;
                  generatedColumnOffsetLine = line3;
                }
                pos = endPos;
                return;
              }
              chunkPos = replacmentEnd - pos;
              if (checkOriginalContent(
                sourceIndex,
                originalLine,
                originalColumn,
                chunk.slice(0, chunkPos)
              )) {
                originalColumn += chunkPos;
              }
              pos += chunkPos;
              const line2 = generatedLine2 + generatedLineOffset;
              if (generatedColumnOffsetLine === line2) {
                generatedColumnOffset -= chunkPos;
              } else {
                generatedColumnOffset = -chunkPos;
                generatedColumnOffsetLine = line2;
              }
              generatedColumn2 += chunkPos;
            }
            if (nextReplacement < endPos) {
              do {
                let line2 = generatedLine2 + generatedLineOffset;
                if (nextReplacement > pos) {
                  const offset2 = nextReplacement - pos;
                  const chunkSlice = chunk.slice(chunkPos, chunkPos + offset2);
                  onChunk(
                    chunkSlice,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    nameIndex < 0 || nameIndex >= nameIndexMapping.length ? -1 : nameIndexMapping[nameIndex]
                  );
                  generatedColumn2 += offset2;
                  chunkPos += offset2;
                  pos = nextReplacement;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunkSlice
                  )) {
                    originalColumn += chunkSlice.length;
                  }
                }
                const { content, name } = repls[i];
                let matches2 = splitIntoLines(content);
                let replacementNameIndex = nameIndex;
                if (sourceIndex >= 0 && name) {
                  let globalIndex = nameMapping.get(name);
                  if (globalIndex === void 0) {
                    globalIndex = nameMapping.size;
                    nameMapping.set(name, globalIndex);
                    onName(globalIndex, name);
                  }
                  replacementNameIndex = globalIndex;
                }
                for (let m = 0; m < matches2.length; m++) {
                  const contentLine = matches2[m];
                  onChunk(
                    contentLine,
                    line2,
                    generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    replacementNameIndex
                  );
                  replacementNameIndex = -1;
                  if (m === matches2.length - 1 && !contentLine.endsWith("\n")) {
                    if (generatedColumnOffsetLine === line2) {
                      generatedColumnOffset += contentLine.length;
                    } else {
                      generatedColumnOffset = contentLine.length;
                      generatedColumnOffsetLine = line2;
                    }
                  } else {
                    generatedLineOffset++;
                    line2++;
                    generatedColumnOffset = -generatedColumn2;
                    generatedColumnOffsetLine = line2;
                  }
                }
                replacmentEnd = Math.max(
                  replacmentEnd,
                  Math.floor(repls[i].end + 1)
                );
                i++;
                nextReplacement = i < repls.length ? Math.floor(repls[i].start) : MAX_SOURCE_POSITION;
                const offset = chunk.length - endPos + replacmentEnd - chunkPos;
                if (offset > 0) {
                  if (replacmentEnd >= endPos) {
                    let line4 = generatedLine2 + generatedLineOffset;
                    if (chunk.endsWith("\n")) {
                      generatedLineOffset--;
                      if (generatedColumnOffsetLine === line4) {
                        generatedColumnOffset += generatedColumn2;
                      }
                    } else if (generatedColumnOffsetLine === line4) {
                      generatedColumnOffset -= chunk.length - chunkPos;
                    } else {
                      generatedColumnOffset = chunkPos - chunk.length;
                      generatedColumnOffsetLine = line4;
                    }
                    pos = endPos;
                    return;
                  }
                  const line3 = generatedLine2 + generatedLineOffset;
                  if (checkOriginalContent(
                    sourceIndex,
                    originalLine,
                    originalColumn,
                    chunk.slice(chunkPos, chunkPos + offset)
                  )) {
                    originalColumn += offset;
                  }
                  chunkPos += offset;
                  pos += offset;
                  if (generatedColumnOffsetLine === line3) {
                    generatedColumnOffset -= offset;
                  } else {
                    generatedColumnOffset = -offset;
                    generatedColumnOffsetLine = line3;
                  }
                  generatedColumn2 += offset;
                }
              } while (nextReplacement < endPos);
            }
            if (chunkPos < chunk.length) {
              const chunkSlice = chunkPos === 0 ? chunk : chunk.slice(chunkPos);
              const line2 = generatedLine2 + generatedLineOffset;
              onChunk(
                chunkSlice,
                line2,
                generatedColumn2 + (line2 === generatedColumnOffsetLine ? generatedColumnOffset : 0),
                sourceIndex,
                originalLine,
                originalColumn,
                nameIndex < 0 ? -1 : nameIndexMapping[nameIndex]
              );
            }
            pos = endPos;
          },
          (sourceIndex, source, sourceContent) => {
            while (sourceContents.length < sourceIndex)
              sourceContents.push(void 0);
            sourceContents[sourceIndex] = sourceContent;
            onSource(sourceIndex, source, sourceContent);
          },
          (nameIndex, name) => {
            let globalIndex = nameMapping.get(name);
            if (globalIndex === void 0) {
              globalIndex = nameMapping.size;
              nameMapping.set(name, globalIndex);
              onName(globalIndex, name);
            }
            nameIndexMapping[nameIndex] = globalIndex;
          }
        );
        let remainer = "";
        for (; i < repls.length; i++) {
          remainer += repls[i].content;
        }
        let line = generatedLine + generatedLineOffset;
        let matches = splitIntoLines(remainer);
        for (let m = 0; m < matches.length; m++) {
          const contentLine = matches[m];
          onChunk(
            contentLine,
            line,
            generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0),
            -1,
            -1,
            -1,
            -1
          );
          if (m === matches.length - 1 && !contentLine.endsWith("\n")) {
            if (generatedColumnOffsetLine === line) {
              generatedColumnOffset += contentLine.length;
            } else {
              generatedColumnOffset = contentLine.length;
              generatedColumnOffsetLine = line;
            }
          } else {
            generatedLineOffset++;
            line++;
            generatedColumnOffset = -generatedColumn;
            generatedColumnOffsetLine = line;
          }
        }
        return {
          generatedLine: line,
          generatedColumn: generatedColumn + (line === generatedColumnOffsetLine ? generatedColumnOffset : 0)
        };
      }
      updateHash(hash) {
        this._sortReplacements();
        hash.update("ReplaceSource");
        this._source.updateHash(hash);
        hash.update(this._name || "");
        for (const repl of this._replacements) {
          hash.update(`${repl.start}${repl.end}${repl.content}${repl.name}`);
        }
      }
    };
    module2.exports = ReplaceSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js
var require_PrefixSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/PrefixSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var RawSource = require_RawSource();
    var streamChunks = require_streamChunks();
    var { getMap, getSourceAndMap } = require_getFromStreamChunks();
    var REPLACE_REGEX = /\n(?=.|\s)/g;
    var PrefixSource = class extends Source3 {
      constructor(prefix, source) {
        super();
        this._source = typeof source === "string" || Buffer.isBuffer(source) ? new RawSource(source, true) : source;
        this._prefix = prefix;
      }
      getPrefix() {
        return this._prefix;
      }
      original() {
        return this._source;
      }
      source() {
        const node = this._source.source();
        const prefix = this._prefix;
        return prefix + node.replace(REPLACE_REGEX, "\n" + prefix);
      }
      // TODO efficient buffer() implementation
      map(options) {
        return getMap(this, options);
      }
      sourceAndMap(options) {
        return getSourceAndMap(this, options);
      }
      streamChunks(options, onChunk, onSource, onName) {
        const prefix = this._prefix;
        const prefixOffset = prefix.length;
        const linesOnly = !!(options && options.columns === false);
        const { generatedLine, generatedColumn, source } = streamChunks(
          this._source,
          options,
          (chunk, generatedLine2, generatedColumn2, sourceIndex, originalLine, originalColumn, nameIndex) => {
            if (generatedColumn2 !== 0) {
              generatedColumn2 += prefixOffset;
            } else if (chunk !== void 0) {
              if (linesOnly || sourceIndex < 0) {
                chunk = prefix + chunk;
              } else if (prefixOffset > 0) {
                onChunk(prefix, generatedLine2, generatedColumn2, -1, -1, -1, -1);
                generatedColumn2 += prefixOffset;
              }
            } else if (!linesOnly) {
              generatedColumn2 += prefixOffset;
            }
            onChunk(
              chunk,
              generatedLine2,
              generatedColumn2,
              sourceIndex,
              originalLine,
              originalColumn,
              nameIndex
            );
          },
          onSource,
          onName
        );
        return {
          generatedLine,
          generatedColumn: generatedColumn === 0 ? 0 : prefixOffset + generatedColumn,
          source: source !== void 0 ? prefix + source.replace(REPLACE_REGEX, "\n" + prefix) : void 0
        };
      }
      updateHash(hash) {
        hash.update("PrefixSource");
        this._source.updateHash(hash);
        hash.update(this._prefix);
      }
    };
    module2.exports = PrefixSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js
var require_SizeOnlySource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/SizeOnlySource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var SizeOnlySource = class extends Source3 {
      constructor(size) {
        super();
        this._size = size;
      }
      _error() {
        return new Error(
          "Content and Map of this Source is not available (only size() is supported)"
        );
      }
      size() {
        return this._size;
      }
      source() {
        throw this._error();
      }
      buffer() {
        throw this._error();
      }
      map(options) {
        throw this._error();
      }
      updateHash() {
        throw this._error();
      }
    };
    module2.exports = SizeOnlySource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js
var require_CompatSource = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/CompatSource.js"(exports, module2) {
    "use strict";
    var Source3 = require_Source();
    var CompatSource = class _CompatSource extends Source3 {
      static from(sourceLike) {
        return sourceLike instanceof Source3 ? sourceLike : new _CompatSource(sourceLike);
      }
      constructor(sourceLike) {
        super();
        this._sourceLike = sourceLike;
      }
      source() {
        return this._sourceLike.source();
      }
      buffer() {
        if (typeof this._sourceLike.buffer === "function") {
          return this._sourceLike.buffer();
        }
        return super.buffer();
      }
      size() {
        if (typeof this._sourceLike.size === "function") {
          return this._sourceLike.size();
        }
        return super.size();
      }
      map(options) {
        if (typeof this._sourceLike.map === "function") {
          return this._sourceLike.map(options);
        }
        return super.map(options);
      }
      sourceAndMap(options) {
        if (typeof this._sourceLike.sourceAndMap === "function") {
          return this._sourceLike.sourceAndMap(options);
        }
        return super.sourceAndMap(options);
      }
      updateHash(hash) {
        if (typeof this._sourceLike.updateHash === "function") {
          return this._sourceLike.updateHash(hash);
        }
        if (typeof this._sourceLike.map === "function") {
          throw new Error(
            "A Source-like object with a 'map' method must also provide an 'updateHash' method"
          );
        }
        hash.update(this.buffer());
      }
    };
    module2.exports = CompatSource;
  }
});

// ../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js
var require_lib3 = __commonJS({
  "../../node_modules/.pnpm/webpack-sources@3.2.3/node_modules/webpack-sources/lib/index.js"(exports) {
    var defineExport = (name, fn) => {
      let value;
      Object.defineProperty(exports, name, {
        get: () => {
          if (fn !== void 0) {
            value = fn();
            fn = void 0;
          }
          return value;
        },
        configurable: true
      });
    };
    defineExport("Source", () => require_Source());
    defineExport("RawSource", () => require_RawSource());
    defineExport("OriginalSource", () => require_OriginalSource());
    defineExport("SourceMapSource", () => require_SourceMapSource());
    defineExport("CachedSource", () => require_CachedSource());
    defineExport("ConcatSource", () => require_ConcatSource());
    defineExport("ReplaceSource", () => require_ReplaceSource());
    defineExport("PrefixSource", () => require_PrefixSource());
    defineExport("SizeOnlySource", () => require_SizeOnlySource());
    defineExport("CompatSource", () => require_CompatSource());
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.1.2/node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "../../node_modules/.pnpm/convert-source-map@1.8.0/node_modules/convert-source-map/index.js"(exports) {
    "use strict";
    var fs5 = require("fs");
    var path5 = require("path");
    var SafeBuffer = require_safe_buffer();
    Object.defineProperty(exports, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });
    function decodeBase64(base64) {
      return (SafeBuffer.Buffer.from(base64, "base64") || "").toString();
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, dir) {
      var r = exports.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path5.resolve(dir, filename);
      try {
        return fs5.readFileSync(filepath, "utf8");
      } catch (e) {
        throw new Error("An error occurred while trying to read the map file at " + filepath + "\n" + e);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment)
        sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment)
        sm = stripComment(sm);
      if (opts.isEncoded)
        sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded)
        sm = JSON.parse(sm);
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space) {
      return JSON.stringify(this.sourcemap, null, space);
    };
    Converter.prototype.toBase64 = function() {
      var json = this.toJSON();
      return (SafeBuffer.Buffer.from(json, "utf8") || "").toString("base64");
    };
    Converter.prototype.toComment = function(options) {
      var base64 = this.toBase64();
      var data = "sourceMappingURL=data:application/json;charset=utf-8;base64," + base64;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value) {
      if (this.sourcemap.hasOwnProperty(key))
        throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };
    Converter.prototype.setProperty = function(key, value) {
      this.sourcemap[key] = value;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports.fromBase64 = function(base64) {
      return new Converter(base64, { isEncoded: true });
    };
    exports.fromComment = function(comment) {
      comment = comment.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      return new Converter(comment, { isEncoded: true, hasComment: true });
    };
    exports.fromMapFileComment = function(comment, dir) {
      return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });
    };
    exports.fromSource = function(content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };
    exports.fromMapFileSource = function(content, dir) {
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), dir) : null;
    };
    exports.removeComments = function(src) {
      return src.replace(exports.commentRegex, "");
    };
    exports.removeMapFileComments = function(src) {
      return src.replace(exports.mapFileCommentRegex, "");
    };
    exports.generateMapFileComment = function(file, options) {
      var data = "sourceMappingURL=" + file;
      return options && options.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// ../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js
var require_bytes = __commonJS({
  "../../node_modules/.pnpm/bytes@3.1.2/node_modules/bytes/index.js"(exports, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format;
    module2.exports.parse = parse;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options) {
      if (typeof value === "string") {
        return parse(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.split(".").map(function(s, i) {
          return i === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
        }).join(".");
      }
      return str + unitSeparator + unit;
    }
    function parse(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      if (isNaN(floatValue)) {
        return null;
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// dist/___get-nextjs-edge-function.js
var require_get_nextjs_edge_function = __commonJS({
  "dist/___get-nextjs-edge-function.js"(exports, module2) {
    "use strict";
    module2.exports = 'var d=Object.defineProperty;var m=e=>d(e,"__esModule",{value:!0});var y=(e,r)=>{m(e);for(var t in r)d(e,t,{get:r[t],enumerable:!0})};y(exports,{default:()=>x});function h(e){let r={};return e&&e.forEach((t,i)=>{r[i]=t,i.toLowerCase()==="set-cookie"&&(r[i]=C(t))}),r}function C(e){let r=[],t=0,i,a,p,n,s;function c(){for(;t<e.length&&/\\s/.test(e.charAt(t));)t+=1;return t<e.length}function o(){return a=e.charAt(t),a!=="="&&a!==";"&&a!==","}for(;t<e.length;){for(i=t,s=!1;c();)if(a=e.charAt(t),a===","){for(p=t,t+=1,c(),n=t;t<e.length&&o();)t+=1;t<e.length&&e.charAt(t)==="="?(s=!0,t=n,r.push(e.substring(i,p)),i=t):t=p+1}else t+=1;(!s||t>=e.length)&&r.push(e.substring(i,e.length))}return r}function x(e){let r=e.staticRoutes.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page})),t=e.dynamicRoutes?.map(i=>({regexp:new RegExp(i.namedRegex),page:i.page}))||[];return async function(a,p){let n=new URL(a.url).pathname,s={};if(e.nextConfig?.basePath&&n.startsWith(e.nextConfig.basePath)&&(n=n.replace(e.nextConfig.basePath,"")||"/"),e.nextConfig?.i18n)for(let o of e.nextConfig.i18n.locales){let g=new RegExp(`^/${o}($|/)`,"i");if(n.match(g)){n=n.replace(g,"/")||"/";break}}for(let o of r)if(o.regexp.exec(n)){s.name=o.page;break}if(!s.name){let o=R(n);for(let g of t||[]){if(o&&!R(g.page))continue;let f=g.regexp.exec(n);if(f){s={name:g.page,params:f.groups};break}}}let c=await _ENTRIES[`middleware_${e.name}`].default.call({},{request:{url:a.url,method:a.method,headers:h(a.headers),ip:u(a.headers,l.Ip),geo:{city:u(a.headers,l.City,!0),country:u(a.headers,l.Country,!0),latitude:u(a.headers,l.Latitude),longitude:u(a.headers,l.Longitude),region:u(a.headers,l.Region,!0)},nextConfig:e.nextConfig,page:s,body:a.body}});return p.waitUntil(c.waitUntil),c.response}}function u(e,r,t=!1){let i=e.get(r)||void 0;return t&&i?decodeURIComponent(i):i}function R(e){return e==="/api"||e.startsWith("/api/")}var l;(function(n){n.City="x-vercel-ip-city",n.Country="x-vercel-ip-country",n.Ip="x-real-ip",n.Latitude="x-vercel-ip-latitude",n.Longitude="x-vercel-ip-longitude",n.Region="x-vercel-ip-country-region"})(l||(l={}));\n';
  }
});

// ../../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js
var require_resolve_from = __commonJS({
  "../../node_modules/.pnpm/resolve-from@5.0.0/node_modules/resolve-from/index.js"(exports, module2) {
    "use strict";
    var path5 = require("path");
    var Module = require("module");
    var fs5 = require("fs");
    var resolveFrom2 = (fromDirectory, moduleId, silent) => {
      if (typeof fromDirectory !== "string") {
        throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDirectory}\``);
      }
      if (typeof moduleId !== "string") {
        throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
      }
      try {
        fromDirectory = fs5.realpathSync(fromDirectory);
      } catch (error) {
        if (error.code === "ENOENT") {
          fromDirectory = path5.resolve(fromDirectory);
        } else if (silent) {
          return;
        } else {
          throw error;
        }
      }
      const fromFile = path5.join(fromDirectory, "noop.js");
      const resolveFileName = () => Module._resolveFilename(moduleId, {
        id: fromFile,
        filename: fromFile,
        paths: Module._nodeModulePaths(fromDirectory)
      });
      if (silent) {
        try {
          return resolveFileName();
        } catch (error) {
          return;
        }
      }
      return resolveFileName();
    };
    module2.exports = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId);
    module2.exports.silent = (fromDirectory, moduleId) => resolveFrom2(fromDirectory, moduleId, true);
  }
});

// ../../node_modules/.pnpm/pretty-bytes@5.3.0/node_modules/pretty-bytes/index.js
var require_pretty_bytes = __commonJS({
  "../../node_modules/.pnpm/pretty-bytes@5.3.0/node_modules/pretty-bytes/index.js"(exports, module2) {
    "use strict";
    var BYTE_UNITS = [
      "B",
      "kB",
      "MB",
      "GB",
      "TB",
      "PB",
      "EB",
      "ZB",
      "YB"
    ];
    var BIT_UNITS = [
      "b",
      "kbit",
      "Mbit",
      "Gbit",
      "Tbit",
      "Pbit",
      "Ebit",
      "Zbit",
      "Ybit"
    ];
    var toLocaleString = (number, locale) => {
      let result = number;
      if (typeof locale === "string") {
        result = number.toLocaleString(locale);
      } else if (locale === true) {
        result = number.toLocaleString();
      }
      return result;
    };
    module2.exports = (number, options) => {
      if (!Number.isFinite(number)) {
        throw new TypeError(`Expected a finite number, got ${typeof number}: ${number}`);
      }
      options = Object.assign({ bits: false }, options);
      const UNITS = options.bits ? BIT_UNITS : BYTE_UNITS;
      if (options.signed && number === 0) {
        return " 0 " + UNITS[0];
      }
      const isNegative = number < 0;
      const prefix = isNegative ? "-" : options.signed ? "+" : "";
      if (isNegative) {
        number = -number;
      }
      if (number < 1) {
        const numberString2 = toLocaleString(number, options.locale);
        return prefix + numberString2 + " " + UNITS[0];
      }
      const exponent = Math.min(Math.floor(Math.log10(number) / 3), UNITS.length - 1);
      number = Number((number / Math.pow(1e3, exponent)).toPrecision(3));
      const numberString = toLocaleString(number, options.locale);
      const unit = UNITS[exponent];
      return prefix + numberString + " " + unit;
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  MAX_AGE_ONE_YEAR: () => MAX_AGE_ONE_YEAR,
  build: () => build,
  htmlContentType: () => htmlContentType,
  prepareCache: () => prepareCache,
  version: () => version
});
module.exports = __toCommonJS(src_exports);
var import_build_utils3 = require("@vercel/build-utils");
var import_superstatic = __toESM(require_superstatic());
var import_nft2 = require("@vercel/nft");
var import_async_sema3 = __toESM(require_lib());
var import_escape_string_regexp3 = __toESM(require_escape_string_regexp());
var import_find_up = __toESM(require_find_up());
var import_fs_extra6 = __toESM(require_lib2());
var import_path5 = __toESM(require("path"));
var import_semver4 = __toESM(require_semver());
var import_url2 = __toESM(require("url"));

// src/create-serverless-config.ts
var import_fs_extra4 = __toESM(require_lib2());
var import_path3 = __toESM(require("path"));
var import_semver2 = __toESM(require_semver());

// src/utils.ts
var import_build_utils = require("@vercel/build-utils");
var import_async_sema = __toESM(require_lib());
var import_buffer_crc32 = __toESM(require_buffer_crc32());
var import_fs_extra3 = __toESM(require_lib2());
var import_path2 = __toESM(require("path"));
var import_semver = __toESM(require_semver());
var import_zlib2 = __toESM(require("zlib"));
var import_url = __toESM(require("url"));
var import_module = require("module");
var import_escape_string_regexp = __toESM(require_escape_string_regexp());
var import_text_table = __toESM(require_text_table());

// src/edge-function-source/get-edge-function-source.ts
var import_fs_extra2 = __toESM(require_lib2());
var import_webpack_sources2 = __toESM(require_lib3());

// src/sourcemapped.ts
var import_convert_source_map = __toESM(require_convert_source_map());
var import_fs_extra = __toESM(require_lib2());
var import_webpack_sources = __toESM(require_lib3());
function sourcemapped(strings, ...sources) {
  const concat = new import_webpack_sources.ConcatSource();
  for (let i = 0; i < Math.max(strings.length, sources.length); i++) {
    const string = strings[i];
    const source = sources[i];
    if (string)
      concat.add(raw(string));
    if (source)
      concat.add(source);
  }
  return concat;
}
function raw(value) {
  return new import_webpack_sources.OriginalSource(value, "[native code]");
}
async function fileToSource(content, sourceName, fullFilePath) {
  const sourcemap = await getSourceMap(content, fullFilePath);
  const cleanContent = removeInlinedSourceMap(content);
  return sourcemap ? new import_webpack_sources.SourceMapSource(cleanContent, sourceName, sourcemap) : new import_webpack_sources.OriginalSource(cleanContent, sourceName);
}
async function getSourceMap(content, fullFilePath) {
  try {
    if (fullFilePath && await import_fs_extra.default.pathExists(`${fullFilePath}.map`)) {
      const mapJson = await import_fs_extra.default.readFile(`${fullFilePath}.map`, "utf8");
      return import_convert_source_map.default.fromJSON(mapJson).toObject();
    }
    return import_convert_source_map.default.fromComment(content).toObject();
  } catch {
    return null;
  }
}
function stringifySourceMap(sourceMap) {
  if (!sourceMap)
    return;
  const obj = typeof sourceMap === "object" ? { ...sourceMap } : import_convert_source_map.default.fromJSON(sourceMap).toObject();
  delete obj.sourcesContent;
  return JSON.stringify(obj);
}
var SOURCE_MAP_COMMENT_REGEX = /^\s*?\/[/*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/gm;
function isValidSourceMapData(encoding, data) {
  if (encoding !== "base64") {
    return false;
  }
  data = data.replace(/\s/g, "").replace(/\*\//g, "");
  return /^[a-zA-Z0-9+=/]+$/.test(data);
}
function removeInlinedSourceMap(source) {
  for (const m of source.matchAll(SOURCE_MAP_COMMENT_REGEX)) {
    if (!isValidSourceMapData(m[4], m[5])) {
      continue;
    }
    source = source.replace(m[0], "");
  }
  return source;
}

// src/edge-function-source/get-edge-function-source.ts
var import_path = require("path");

// src/constants.ts
var KIB = 1024;
var MIB = 1024 * KIB;
var EDGE_FUNCTION_SIZE_LIMIT = 4 * MIB;
var MAX_UNCOMPRESSED_LAMBDA_SIZE = 250 * MIB;
var LAMBDA_RESERVED_UNCOMPRESSED_SIZE = 2.5 * MIB;
var LAMBDA_RESERVED_COMPRESSED_SIZE = 250 * KIB;

// src/edge-function-source/get-edge-function-source.ts
var import_zlib = __toESM(require("zlib"));
var import_util = require("util");

// src/pretty-bytes.ts
var import_bytes = __toESM(require_bytes());
var prettyBytes = (n) => (0, import_bytes.default)(n, { unitSeparator: " " });

// src/edge-function-source/get-edge-function-source.ts
var import_get_nextjs_edge_function = __toESM(require_get_nextjs_edge_function());
var gzip = (0, import_util.promisify)(import_zlib.default.gzip);
async function getNextjsEdgeFunctionSource(filePaths, params, outputDir, wasm) {
  const chunks = new import_webpack_sources2.ConcatSource(raw(`globalThis._ENTRIES = {};`));
  for (const filePath of filePaths) {
    const fullFilePath = (0, import_path.join)(outputDir, filePath);
    const content = await (0, import_fs_extra2.readFile)(fullFilePath, "utf8");
    chunks.add(raw(`
/**/;`));
    chunks.add(await fileToSource(content, filePath, fullFilePath));
  }
  const text = chunks.source();
  const wasmFiles = (wasm ?? []).map(
    ({ filePath }) => (0, import_path.join)(outputDir, filePath)
  );
  await validateSize(text, wasmFiles);
  const getPageMatchCode = `(function () {
    const module = { exports: {}, loaded: false };
    const fn = (function(module,exports) {${import_get_nextjs_edge_function.default}
});
    fn(module, module.exports);
    return module.exports;
  })`;
  return sourcemapped`
  ${raw(getWasmImportStatements(wasm))}
  ${chunks};
  export default ${raw(getPageMatchCode)}.call({}).default(
    ${raw(JSON.stringify(params))}
  )`;
}
function getWasmImportStatements(wasm = []) {
  return wasm.filter(({ name }) => name.startsWith("wasm_")).map(({ name }) => {
    const pathname = `/wasm/${name}.wasm`;
    return `const ${name} = require(${JSON.stringify(pathname)});`;
  }).join("\n");
}
async function validateSize(script, wasmFiles) {
  const buffers = [Buffer.from(script, "utf8")];
  for (const filePath of wasmFiles) {
    buffers.push(await (0, import_fs_extra2.readFile)(filePath));
  }
  const content = Buffer.concat(buffers);
  const gzipped = await gzip(content);
  if (gzipped.length > EDGE_FUNCTION_SIZE_LIMIT) {
    throw new Error(
      `Exceeds maximum edge function size: ${prettyBytes(
        gzipped.length
      )} / ${prettyBytes(EDGE_FUNCTION_SIZE_LIMIT)}`
    );
  }
}

// src/utils.ts
var require_ = (0, import_module.createRequire)(__filename);
var RSC_CONTENT_TYPE = "x-component";
var RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
var TEST_DYNAMIC_ROUTE = /\/\[[^\/]+?\](?=\/|$)/;
function isDynamicRoute(route) {
  route = route.startsWith("/") ? route : `/${route}`;
  return TEST_DYNAMIC_ROUTE.test(route);
}
function validateEntrypoint(entrypoint) {
  if (!/package\.json$/.exec(entrypoint) && !/next\.config\.js$/.exec(entrypoint)) {
    throw new import_build_utils.NowBuildError({
      message: 'Specified "src" for "@vercel/next" has to be "package.json" or "next.config.js"',
      code: "NEXT_INCORRECT_SRC"
    });
  }
}
function excludeFiles(files, matcher) {
  return Object.keys(files).reduce((newFiles, filePath) => {
    if (matcher(filePath)) {
      return newFiles;
    }
    return {
      ...newFiles,
      [filePath]: files[filePath]
    };
  }, {});
}
function normalizePackageJson(defaultPackageJson = {}) {
  const dependencies = {};
  const devDependencies = {
    ...defaultPackageJson.dependencies,
    ...defaultPackageJson.devDependencies
  };
  if (devDependencies.react) {
    dependencies.react = devDependencies.react;
    delete devDependencies.react;
  }
  if (devDependencies["react-dom"]) {
    dependencies["react-dom"] = devDependencies["react-dom"];
    delete devDependencies["react-dom"];
  }
  delete devDependencies["next-server"];
  return {
    ...defaultPackageJson,
    dependencies: {
      // react and react-dom can be overwritten
      react: "latest",
      "react-dom": "latest",
      ...dependencies,
      // override react if user provided it
      // next-server is forced to canary
      "next-server": "v7.0.2-canary.49"
    },
    devDependencies: {
      ...devDependencies,
      // next is forced to canary
      next: "v7.0.2-canary.49"
    },
    scripts: {
      ...defaultPackageJson.scripts,
      "now-build": "NODE_OPTIONS=--max_old_space_size=3000 next build --lambdas"
    }
  };
}
async function getNextConfig(workPath, entryPath) {
  const entryConfig = import_path2.default.join(entryPath, "./next.config.js");
  if (await import_fs_extra3.default.pathExists(entryConfig)) {
    return import_fs_extra3.default.readFile(entryConfig, "utf8");
  }
  const workConfig = import_path2.default.join(workPath, "./next.config.js");
  if (await import_fs_extra3.default.pathExists(workConfig)) {
    return import_fs_extra3.default.readFile(workConfig, "utf8");
  }
  return null;
}
function getImagesConfig(imagesManifest) {
  return imagesManifest?.images?.loader === "default" && imagesManifest.images?.unoptimized !== true ? {
    domains: imagesManifest.images.domains,
    sizes: imagesManifest.images.sizes,
    remotePatterns: imagesManifest.images.remotePatterns,
    minimumCacheTTL: imagesManifest.images.minimumCacheTTL,
    formats: imagesManifest.images.formats,
    dangerouslyAllowSVG: imagesManifest.images.dangerouslyAllowSVG,
    contentSecurityPolicy: imagesManifest.images.contentSecurityPolicy,
    contentDispositionType: imagesManifest.images.contentDispositionType
  } : void 0;
}
function normalizePage(page) {
  if (!page.startsWith("/")) {
    page = `/${page}`;
  }
  page = page.replace(/\/index$/, "/");
  return page;
}
async function getRoutesManifest(entryPath, outputDirectory, nextVersion) {
  const shouldHaveManifest = nextVersion && import_semver.default.gte(nextVersion, "9.1.4-canary.0");
  if (!shouldHaveManifest)
    return;
  const pathRoutesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "routes-manifest.json"
  );
  const hasRoutesManifest = await import_fs_extra3.default.access(pathRoutesManifest).then(() => true).catch(() => false);
  if (shouldHaveManifest && !hasRoutesManifest) {
    throw new import_build_utils.NowBuildError({
      message: `The file "${pathRoutesManifest}" couldn't be found. This is often caused by a misconfiguration in your project.`,
      link: "https://err.sh/vercel/vercel/now-next-routes-manifest",
      code: "NEXT_NO_ROUTES_MANIFEST"
    });
  }
  const routesManifest = await import_fs_extra3.default.readJSON(pathRoutesManifest);
  for (const route of routesManifest.dataRoutes || []) {
    if (Array.isArray(route.routeKeys)) {
      delete route.routeKeys;
      delete route.namedDataRouteRegex;
    }
  }
  for (const route of routesManifest.dynamicRoutes || []) {
    if ("routeKeys" in route && Array.isArray(route.routeKeys)) {
      delete route.routeKeys;
      delete route.namedRegex;
    }
  }
  return routesManifest;
}
async function getDynamicRoutes(entryPath, entryDirectory, dynamicPages, isDev, routesManifest, omittedRoutes, canUsePreviewMode, bypassToken, isServerMode, dynamicMiddlewareRouteMap, experimentalPPR) {
  if (routesManifest) {
    switch (routesManifest.version) {
      case 1:
      case 2: {
        return routesManifest.dynamicRoutes.filter(({ page }) => canUsePreviewMode || !omittedRoutes?.has(page)).map(({ page, regex }) => {
          return {
            src: regex,
            dest: !isDev ? import_path2.default.posix.join("/", entryDirectory, page) : page,
            check: true,
            status: canUsePreviewMode && omittedRoutes?.has(page) ? 404 : void 0
          };
        });
      }
      case 3:
      case 4: {
        const routes2 = [];
        for (const dynamicRoute of routesManifest.dynamicRoutes) {
          if (!canUsePreviewMode && omittedRoutes?.has(dynamicRoute.page)) {
            continue;
          }
          const params = dynamicRoute;
          if ("isMiddleware" in params) {
            const route2 = dynamicMiddlewareRouteMap?.get(params.page);
            if (!route2) {
              throw new Error(
                `Could not find dynamic middleware route for ${params.page}`
              );
            }
            routes2.push(route2);
            continue;
          }
          const { page, namedRegex, regex, routeKeys } = params;
          const route = {
            src: namedRegex || regex,
            dest: `${!isDev ? import_path2.default.posix.join("/", entryDirectory, page) : page}${routeKeys ? `?${Object.keys(routeKeys).map((key) => `${routeKeys[key]}=$${key}`).join("&")}` : ""}`
          };
          if (!isServerMode) {
            route.check = true;
          }
          if (isServerMode && canUsePreviewMode && omittedRoutes?.has(page)) {
            route.has = [
              {
                type: "cookie",
                key: "__prerender_bypass",
                value: bypassToken || void 0
              },
              {
                type: "cookie",
                key: "__next_preview_data"
              }
            ];
          }
          if (experimentalPPR) {
            let dest = route.dest?.replace(/($|\?)/, ".prefetch.rsc$1");
            if (page === "/" || page === "/index") {
              dest = dest?.replace(/([^/]+\.prefetch\.rsc(\?.*|$))/, "__$1");
            }
            routes2.push({
              ...route,
              src: route.src.replace(
                new RegExp((0, import_escape_string_regexp.default)("(?:/)?$")),
                "(?:\\.prefetch\\.rsc)(?:/)?$"
              ),
              dest
            });
          }
          routes2.push({
            ...route,
            src: route.src.replace(
              new RegExp((0, import_escape_string_regexp.default)("(?:/)?$")),
              "(?:\\.rsc)(?:/)?$"
            ),
            dest: route.dest?.replace(/($|\?)/, ".rsc$1")
          });
          routes2.push(route);
        }
        return routes2;
      }
      default: {
        throw new import_build_utils.NowBuildError({
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen.",
          code: "NEXT_VERSION_UPGRADE"
        });
      }
    }
  }
  if (!dynamicPages.length) {
    return [];
  }
  let getRouteRegex = void 0;
  let getSortedRoutes;
  try {
    const resolved = require_.resolve("next-server/dist/lib/router/utils", {
      paths: [entryPath]
    });
    ({ getRouteRegex, getSortedRoutes } = require_(resolved));
    if (typeof getRouteRegex !== "function") {
      getRouteRegex = void 0;
    }
  } catch (_) {
  }
  if (!getRouteRegex || !getSortedRoutes) {
    try {
      const resolved = require_.resolve(
        "next/dist/next-server/lib/router/utils",
        { paths: [entryPath] }
      );
      ({ getRouteRegex, getSortedRoutes } = require_(resolved));
      if (typeof getRouteRegex !== "function") {
        getRouteRegex = void 0;
      }
    } catch (_) {
    }
  }
  if (!getRouteRegex || !getSortedRoutes) {
    throw new import_build_utils.NowBuildError({
      message: "Found usage of dynamic routes but not on a new enough version of Next.js.",
      code: "NEXT_DYNAMIC_ROUTES_OUTDATED"
    });
  }
  const pageMatchers = getSortedRoutes(dynamicPages).map((pageName) => ({
    pageName,
    matcher: getRouteRegex && getRouteRegex(pageName).re
  }));
  const routes = [];
  pageMatchers.forEach((pageMatcher) => {
    const dest = !isDev ? import_path2.default.posix.join("/", entryDirectory, pageMatcher.pageName) : pageMatcher.pageName;
    if (pageMatcher && pageMatcher.matcher) {
      routes.push({
        src: pageMatcher.matcher.source,
        dest,
        check: !isDev
      });
    }
  });
  return routes;
}
function localizeDynamicRoutes(dynamicRoutes, dynamicPrefix, entryDirectory, staticPages, prerenderManifest, routesManifest, isServerMode, isCorrectLocaleAPIRoutes, inversedAppPathRoutesManifest) {
  return dynamicRoutes.map((route) => {
    if (route.middleware !== void 0 || route.middlewarePath !== void 0)
      return route;
    const { i18n } = routesManifest || {};
    if (i18n) {
      const { pathname } = import_url.default.parse(route.dest);
      const pathnameNoPrefix = pathname?.replace(dynamicPrefix, "");
      const isFallback = prerenderManifest.fallbackRoutes[pathname];
      const isBlocking = prerenderManifest.blockingFallbackRoutes[pathname];
      const isApiRoute = pathnameNoPrefix === "/api" || pathnameNoPrefix?.startsWith("/api/");
      const isAutoExport = staticPages[addLocaleOrDefault(pathname, routesManifest).substring(1)];
      const isAppRoute = inversedAppPathRoutesManifest?.[pathnameNoPrefix || ""];
      const isLocalePrefixed = isFallback || isBlocking || isAutoExport || isServerMode;
      route.src = route.src.replace(
        "^",
        `^${dynamicPrefix ? `${dynamicPrefix}[/]?` : "[/]?"}(?${isLocalePrefixed ? "<nextLocale>" : ":"}${i18n.locales.map((locale) => (0, import_escape_string_regexp.default)(locale)).join("|")})?`
      );
      if (isLocalePrefixed && !(isCorrectLocaleAPIRoutes && isApiRoute) && !isAppRoute) {
        route.dest = route.dest.replace(
          `${import_path2.default.posix.join("/", entryDirectory, "/")}`,
          `${import_path2.default.posix.join("/", entryDirectory, "$nextLocale", "/")}`
        );
      }
    } else {
      route.src = route.src.replace("^", `^${dynamicPrefix}`);
    }
    return route;
  });
}
async function getImagesManifest(entryPath, outputDirectory) {
  const pathImagesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "images-manifest.json"
  );
  const hasImagesManifest = await import_fs_extra3.default.access(pathImagesManifest).then(() => true).catch(() => false);
  if (!hasImagesManifest) {
    return void 0;
  }
  return import_fs_extra3.default.readJson(pathImagesManifest);
}
function filterStaticPages(staticPageFiles, dynamicPages, entryDirectory, htmlContentType2, prerenderManifest, routesManifest) {
  const staticPages = {};
  Object.keys(staticPageFiles).forEach((page) => {
    const pathname = page.replace(/\.html$/, "");
    const routeName = normalizeLocalePath(
      normalizePage(pathname),
      routesManifest?.i18n?.locales
    ).pathname;
    if (prerenderManifest.staticRoutes[routeName] || prerenderManifest.fallbackRoutes[routeName] || prerenderManifest.staticRoutes[normalizePage(pathname)] || prerenderManifest.fallbackRoutes[normalizePage(pathname)]) {
      return;
    }
    const staticRoute = import_path2.default.posix.join(entryDirectory, pathname);
    staticPages[staticRoute] = staticPageFiles[page];
    staticPages[staticRoute].contentType = htmlContentType2;
    if (isDynamicRoute(pathname)) {
      dynamicPages.push(routeName);
      return;
    }
  });
  return staticPages;
}
function getFilesMapFromReasons(fileList, reasons, ignoreFn) {
  const parentFilesMap = /* @__PURE__ */ new Map();
  function propagateToParents(parents, file, seen = /* @__PURE__ */ new Set()) {
    for (const parent of parents || []) {
      if (!seen.has(parent)) {
        seen.add(parent);
        let parentFiles = parentFilesMap.get(parent);
        if (!parentFiles) {
          parentFiles = /* @__PURE__ */ new Set();
          parentFilesMap.set(parent, parentFiles);
        }
        if (!ignoreFn?.(file, parent)) {
          parentFiles.add(file);
        }
        const parentReason = reasons.get(parent);
        if (parentReason?.parents) {
          propagateToParents(parentReason.parents, file, seen);
        }
      }
    }
  }
  for (const file of fileList) {
    const reason = reasons.get(file);
    const isInitial = reason?.type.length === 1 && reason.type.includes("initial");
    if (!reason || !reason.parents || isInitial && reason.parents.size === 0) {
      continue;
    }
    propagateToParents(reason.parents, file);
  }
  return parentFilesMap;
}
var collectTracedFiles = (baseDir, lstatResults, lstatSema, reasons, files) => async (file) => {
  const reason = reasons.get(file);
  if (reason && reason.type.includes("initial")) {
    return;
  }
  const filePath = import_path2.default.join(baseDir, file);
  if (!lstatResults[filePath]) {
    lstatResults[filePath] = lstatSema.acquire().then(() => (0, import_fs_extra3.lstat)(filePath)).finally(() => lstatSema.release());
  }
  const { mode } = await lstatResults[filePath];
  files[file] = new import_build_utils.FileFsRef({
    fsPath: import_path2.default.join(baseDir, file),
    mode
  });
};
var ExperimentalTraceVersion = `9.0.4-canary.1`;
var compressBuffer = (buf) => {
  return new Promise((resolve, reject) => {
    import_zlib2.default.deflateRaw(
      buf,
      { level: import_zlib2.default.constants.Z_BEST_COMPRESSION },
      (err, compBuf) => {
        if (err)
          return reject(err);
        resolve(compBuf);
      }
    );
  });
};
async function createPseudoLayer(files) {
  const pseudoLayer = {};
  let pseudoLayerBytes = 0;
  for (const fileName of Object.keys(files)) {
    const file = files[fileName];
    if ((0, import_build_utils.isSymbolicLink)(file.mode)) {
      const symlinkTarget = await import_fs_extra3.default.readlink(file.fsPath);
      pseudoLayer[fileName] = {
        file,
        isSymlink: true,
        symlinkTarget
      };
    } else {
      const origBuffer = await (0, import_build_utils.streamToBuffer)(file.toStream());
      const compBuffer = await compressBuffer(origBuffer);
      pseudoLayerBytes += compBuffer.byteLength;
      pseudoLayer[fileName] = {
        file,
        compBuffer,
        isSymlink: false,
        crc32: import_buffer_crc32.default.unsigned(origBuffer),
        uncompressedSize: origBuffer.byteLength
      };
    }
  }
  return { pseudoLayer, pseudoLayerBytes };
}
var createLambdaSema = new import_async_sema.Sema(1);
async function createLambdaFromPseudoLayers({
  files: baseFiles,
  layers,
  isStreaming,
  nextVersion,
  ...lambdaOptions
}) {
  await createLambdaSema.acquire();
  const files = {};
  const addedFiles = /* @__PURE__ */ new Set();
  for (const layer of layers) {
    for (const seedKey of Object.keys(layer)) {
      if (addedFiles.has(seedKey)) {
        continue;
      }
      const item = layer[seedKey];
      files[seedKey] = item.file;
      addedFiles.add(seedKey);
    }
  }
  for (const fileName of Object.keys(baseFiles)) {
    if (addedFiles.has(fileName)) {
      continue;
    }
    const file = baseFiles[fileName];
    files[fileName] = file;
    addedFiles.add(fileName);
  }
  createLambdaSema.release();
  return new import_build_utils.NodejsLambda({
    ...lambdaOptions,
    ...isStreaming ? {
      supportsResponseStreaming: true
    } : {},
    files,
    shouldAddHelpers: false,
    shouldAddSourcemapSupport: false,
    supportsMultiPayloads: true,
    framework: {
      slug: "nextjs",
      version: nextVersion
    }
  });
}
async function getExportIntent(entryPath) {
  const pathExportMarker = import_path2.default.join(entryPath, ".next", "export-marker.json");
  const hasExportMarker = await import_fs_extra3.default.access(pathExportMarker, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasExportMarker) {
    return false;
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathExportMarker, "utf8"));
  switch (manifest.version) {
    case 1: {
      if (manifest.hasExportPathMap !== true) {
        return false;
      }
      return { trailingSlash: manifest.exportTrailingSlash };
    }
    default: {
      return false;
    }
  }
}
async function getExportStatus(entryPath) {
  const pathExportDetail = import_path2.default.join(entryPath, ".next", "export-detail.json");
  const hasExportDetail = await import_fs_extra3.default.access(pathExportDetail, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasExportDetail) {
    return false;
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathExportDetail, "utf8"));
  switch (manifest.version) {
    case 1: {
      return {
        success: !!manifest.success,
        outDirectory: manifest.outDirectory
      };
    }
    default: {
      return false;
    }
  }
}
async function getRequiredServerFilesManifest(entryPath, outputDirectory) {
  const pathRequiredServerFilesManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "required-server-files.json"
  );
  const hasManifest = await import_fs_extra3.default.access(pathRequiredServerFilesManifest, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasManifest) {
    return false;
  }
  const manifestData = JSON.parse(
    await import_fs_extra3.default.readFile(pathRequiredServerFilesManifest, "utf8")
  );
  const requiredServerFiles = {
    files: [],
    ignore: [],
    config: {},
    appDir: manifestData.appDir,
    relativeAppDir: manifestData.relativeAppDir
  };
  switch (manifestData.version) {
    case 1: {
      requiredServerFiles.files = manifestData.files;
      requiredServerFiles.ignore = manifestData.ignore;
      requiredServerFiles.config = manifestData.config;
      requiredServerFiles.appDir = manifestData.appDir;
      break;
    }
    default: {
      throw new Error(
        `Invalid required-server-files manifest version ${manifestData.version}, please contact support if this error persists`
      );
    }
  }
  return requiredServerFiles;
}
async function getPrerenderManifest(entryPath, outputDirectory) {
  const pathPrerenderManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "prerender-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(pathPrerenderManifest, import_fs_extra3.default.constants.F_OK).then(() => true).catch(() => false);
  if (!hasManifest) {
    return {
      staticRoutes: {},
      blockingFallbackRoutes: {},
      fallbackRoutes: {},
      bypassToken: null,
      omittedRoutes: {},
      notFoundRoutes: [],
      isLocalePrefixed: false
    };
  }
  const manifest = JSON.parse(await import_fs_extra3.default.readFile(pathPrerenderManifest, "utf8"));
  switch (manifest.version) {
    case 1: {
      const routes = Object.keys(manifest.routes);
      const lazyRoutes = Object.keys(manifest.dynamicRoutes);
      const ret = {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: manifest.preview && manifest.preview.previewModeId || null,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: false
      };
      routes.forEach((route) => {
        const { initialRevalidateSeconds, dataRoute, srcRoute } = manifest.routes[route];
        ret.staticRoutes[route] = {
          initialRevalidate: initialRevalidateSeconds === false ? false : Math.max(1, initialRevalidateSeconds),
          dataRoute,
          srcRoute
        };
      });
      lazyRoutes.forEach((lazyRoute) => {
        const { routeRegex, fallback, dataRoute, dataRouteRegex } = manifest.dynamicRoutes[lazyRoute];
        if (fallback) {
          ret.fallbackRoutes[lazyRoute] = {
            routeRegex,
            fallback,
            dataRoute,
            dataRouteRegex
          };
        } else {
          ret.blockingFallbackRoutes[lazyRoute] = {
            routeRegex,
            dataRoute,
            dataRouteRegex
          };
        }
      });
      return ret;
    }
    case 2:
    case 3:
    case 4: {
      const routes = Object.keys(manifest.routes);
      const lazyRoutes = Object.keys(manifest.dynamicRoutes);
      const ret = {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: manifest.preview.previewModeId,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: manifest.version > 2
      };
      if (manifest.notFoundRoutes) {
        ret.notFoundRoutes.push(...manifest.notFoundRoutes);
      }
      routes.forEach((route) => {
        const { initialRevalidateSeconds, dataRoute, srcRoute } = manifest.routes[route];
        let initialStatus;
        let initialHeaders;
        let experimentalBypassFor;
        let experimentalPPR;
        let prefetchDataRoute;
        if (manifest.version === 4) {
          initialStatus = manifest.routes[route].initialStatus;
          initialHeaders = manifest.routes[route].initialHeaders;
          experimentalBypassFor = manifest.routes[route].experimentalBypassFor;
          experimentalPPR = manifest.routes[route].experimentalPPR;
          prefetchDataRoute = manifest.routes[route].prefetchDataRoute;
        }
        ret.staticRoutes[route] = {
          initialRevalidate: initialRevalidateSeconds === false ? false : Math.max(1, initialRevalidateSeconds),
          dataRoute,
          prefetchDataRoute,
          srcRoute,
          initialStatus,
          initialHeaders,
          experimentalBypassFor,
          experimentalPPR
        };
      });
      lazyRoutes.forEach((lazyRoute) => {
        const { routeRegex, fallback, dataRoute, dataRouteRegex } = manifest.dynamicRoutes[lazyRoute];
        let experimentalBypassFor;
        let experimentalPPR;
        let prefetchDataRoute;
        let prefetchDataRouteRegex;
        if (manifest.version === 4) {
          experimentalBypassFor = manifest.dynamicRoutes[lazyRoute].experimentalBypassFor;
          experimentalPPR = manifest.dynamicRoutes[lazyRoute].experimentalPPR;
          prefetchDataRoute = manifest.dynamicRoutes[lazyRoute].prefetchDataRoute;
          prefetchDataRouteRegex = manifest.dynamicRoutes[lazyRoute].prefetchDataRouteRegex;
        }
        if (typeof fallback === "string") {
          ret.fallbackRoutes[lazyRoute] = {
            experimentalBypassFor,
            experimentalPPR,
            routeRegex,
            fallback,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex
          };
        } else if (fallback === null) {
          ret.blockingFallbackRoutes[lazyRoute] = {
            experimentalBypassFor,
            experimentalPPR,
            routeRegex,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex
          };
        } else {
          ret.omittedRoutes[lazyRoute] = {
            experimentalBypassFor,
            experimentalPPR,
            routeRegex,
            dataRoute,
            dataRouteRegex,
            prefetchDataRoute,
            prefetchDataRouteRegex
          };
        }
      });
      return ret;
    }
    default: {
      return {
        staticRoutes: {},
        blockingFallbackRoutes: {},
        fallbackRoutes: {},
        bypassToken: null,
        omittedRoutes: {},
        notFoundRoutes: [],
        isLocalePrefixed: false
      };
    }
  }
}
var _usesSrcCache;
async function usesSrcDirectory(workPath) {
  if (!_usesSrcCache) {
    const sourcePages = import_path2.default.join(workPath, "src", "pages");
    try {
      if ((await import_fs_extra3.default.stat(sourcePages)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  if (!_usesSrcCache) {
    const sourceAppdir = import_path2.default.join(workPath, "src", "app");
    try {
      if ((await import_fs_extra3.default.stat(sourceAppdir)).isDirectory()) {
        _usesSrcCache = true;
      }
    } catch (_err) {
      _usesSrcCache = false;
    }
  }
  return Boolean(_usesSrcCache);
}
async function getSourceFilePathFromPage({
  workPath,
  page,
  pageExtensions
}) {
  const usesSrcDir = await usesSrcDirectory(workPath);
  const extensionsToTry = pageExtensions || ["js", "jsx", "ts", "tsx"];
  for (const pageType of ["pages", "app"]) {
    let fsPath = import_path2.default.join(workPath, pageType, page);
    if (usesSrcDir) {
      fsPath = import_path2.default.join(workPath, "src", pageType, page);
    }
    if (import_fs_extra3.default.existsSync(fsPath)) {
      return import_path2.default.relative(workPath, fsPath);
    }
    const extensionless = fsPath.replace(import_path2.default.extname(fsPath), "");
    for (const ext of extensionsToTry) {
      fsPath = `${extensionless}.${ext}`;
      if (pageType === "app" && extensionless === import_path2.default.join(workPath, `${usesSrcDir ? "src/" : ""}app/index`)) {
        fsPath = `${extensionless.replace(/index$/, "page")}.${ext}`;
      }
      if (import_fs_extra3.default.existsSync(fsPath)) {
        return import_path2.default.relative(workPath, fsPath);
      }
    }
    if (isDirectory(extensionless)) {
      if (pageType === "pages") {
        for (const ext of extensionsToTry) {
          fsPath = import_path2.default.join(extensionless, `index.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
        }
      } else {
        for (const ext of extensionsToTry) {
          fsPath = import_path2.default.join(extensionless, `page.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
          fsPath = import_path2.default.join(extensionless, `route.${ext}`);
          if (import_fs_extra3.default.existsSync(fsPath)) {
            return import_path2.default.relative(workPath, fsPath);
          }
        }
      }
    }
  }
  console.log(
    `WARNING: Unable to find source file for page ${page} with extensions: ${extensionsToTry.join(
      ", "
    )}, this can cause functions config from \`vercel.json\` to not be applied`
  );
  return "";
}
function isDirectory(path5) {
  return import_fs_extra3.default.existsSync(path5) && import_fs_extra3.default.lstatSync(path5).isDirectory();
}
function normalizeLocalePath(pathname, locales) {
  let detectedLocale;
  const pathnameParts = pathname.split("/");
  (locales || []).some((locale) => {
    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
      detectedLocale = locale;
      pathnameParts.splice(1, 1);
      pathname = pathnameParts.join("/") || "/";
      return true;
    }
    return false;
  });
  return {
    pathname,
    detectedLocale
  };
}
function addLocaleOrDefault(pathname, routesManifest, locale) {
  if (!routesManifest?.i18n)
    return pathname;
  if (!locale)
    locale = routesManifest.i18n.defaultLocale;
  return locale ? `/${locale}${pathname === "/index" ? "" : pathname}` : pathname;
}
async function getPageLambdaGroups({
  entryPath,
  config,
  functionsConfigManifest,
  pages,
  prerenderRoutes,
  experimentalPPRRoutes,
  pageTraces,
  compressedPages,
  tracedPseudoLayer,
  initialPseudoLayer,
  initialPseudoLayerUncompressed,
  lambdaCompressedByteLimit,
  internalPages,
  pageExtensions,
  inversedAppPathManifest
}) {
  const groups = [];
  for (const page of pages) {
    const newPages = [...internalPages, page];
    const routeName = normalizePage(page.replace(/\.js$/, ""));
    const isPrerenderRoute = prerenderRoutes.has(routeName);
    const isExperimentalPPR = experimentalPPRRoutes?.has(routeName) ?? false;
    let opts = {};
    if (functionsConfigManifest && functionsConfigManifest.functions[routeName]) {
      opts = functionsConfigManifest.functions[routeName];
    }
    if (config && config.functions) {
      const pageFromManifest = inversedAppPathManifest?.[routeName];
      const sourceFile = await getSourceFilePathFromPage({
        workPath: entryPath,
        // since this function is used by both `pages` and `app`, the manifest might not be provided
        // so fallback to normal behavior of just checking the `page`.
        page: pageFromManifest ?? page,
        pageExtensions
      });
      const vercelConfigOpts = await (0, import_build_utils.getLambdaOptionsFromFunction)({
        sourceFile,
        config
      });
      opts = { ...vercelConfigOpts, ...opts };
    }
    let matchingGroup = groups.find((group) => {
      const matches = group.maxDuration === opts.maxDuration && group.memory === opts.memory && group.isPrerenders === isPrerenderRoute && group.isExperimentalPPR === isExperimentalPPR;
      if (matches) {
        let newTracedFilesSize = group.pseudoLayerBytes;
        let newTracedFilesUncompressedSize = group.pseudoLayerUncompressedBytes;
        for (const newPage of newPages) {
          Object.keys(pageTraces[newPage] || {}).map((file) => {
            if (!group.pseudoLayer[file]) {
              const item = tracedPseudoLayer[file];
              newTracedFilesSize += item.compBuffer?.byteLength || 0;
              newTracedFilesUncompressedSize += item.uncompressedSize || 0;
            }
          });
          newTracedFilesSize += compressedPages[newPage].compBuffer.byteLength;
          newTracedFilesUncompressedSize += compressedPages[newPage].uncompressedSize;
        }
        const underUncompressedLimit = newTracedFilesUncompressedSize < MAX_UNCOMPRESSED_LAMBDA_SIZE - LAMBDA_RESERVED_UNCOMPRESSED_SIZE;
        const underCompressedLimit = newTracedFilesSize < lambdaCompressedByteLimit - LAMBDA_RESERVED_COMPRESSED_SIZE;
        return underUncompressedLimit && underCompressedLimit;
      }
      return false;
    });
    if (matchingGroup) {
      matchingGroup.pages.push(page);
    } else {
      const newGroup = {
        pages: [page],
        ...opts,
        isPrerenders: isPrerenderRoute,
        isExperimentalPPR,
        isApiLambda: !!isApiPage(page),
        pseudoLayerBytes: initialPseudoLayer.pseudoLayerBytes,
        pseudoLayerUncompressedBytes: initialPseudoLayerUncompressed,
        pseudoLayer: Object.assign({}, initialPseudoLayer.pseudoLayer)
      };
      groups.push(newGroup);
      matchingGroup = newGroup;
    }
    for (const newPage of newPages) {
      Object.keys(pageTraces[newPage] || {}).map((file) => {
        const pseudoItem = tracedPseudoLayer[file];
        const compressedSize = pseudoItem?.compBuffer?.byteLength || 0;
        if (!matchingGroup.pseudoLayer[file]) {
          matchingGroup.pseudoLayer[file] = pseudoItem;
          matchingGroup.pseudoLayerBytes += compressedSize;
          matchingGroup.pseudoLayerUncompressedBytes += pseudoItem.uncompressedSize || 0;
        }
      });
      matchingGroup.pseudoLayerBytes += compressedPages[newPage].compBuffer.byteLength;
      matchingGroup.pseudoLayerUncompressedBytes += compressedPages[newPage].uncompressedSize;
    }
  }
  return groups;
}
var outputFunctionFileSizeInfo = (pages, pseudoLayer, pseudoLayerBytes, pseudoLayerUncompressedBytes, compressedPages) => {
  const exceededLimitOutput = [];
  console.log(
    `Serverless Function's page${pages.length === 1 ? "" : "s"}: ${pages.join(
      ", "
    )}`
  );
  exceededLimitOutput.push([
    "Large Dependencies",
    "Uncompressed size",
    "Compressed size"
  ]);
  const dependencies = {};
  for (const fileKey of Object.keys(pseudoLayer)) {
    if (!pseudoLayer[fileKey].isSymlink) {
      const fileItem = pseudoLayer[fileKey];
      const depKey = fileKey.split("/").slice(0, 3).join("/");
      if (!dependencies[depKey]) {
        dependencies[depKey] = {
          compressed: 0,
          uncompressed: 0
        };
      }
      dependencies[depKey].compressed += fileItem.compBuffer.byteLength;
      dependencies[depKey].uncompressed += fileItem.uncompressedSize;
    }
  }
  for (const page of pages) {
    dependencies[`pages/${page}`] = {
      compressed: compressedPages[page].compBuffer.byteLength,
      uncompressed: compressedPages[page].uncompressedSize
    };
  }
  let numLargeDependencies = 0;
  Object.keys(dependencies).sort((a, b) => {
    const aDep = dependencies[a];
    const bDep = dependencies[b];
    if (aDep.compressed > bDep.compressed) {
      return -1;
    }
    if (aDep.compressed < bDep.compressed) {
      return 1;
    }
    return 0;
  }).forEach((depKey) => {
    const dep = dependencies[depKey];
    if (dep.compressed < 100 * KIB && dep.uncompressed < 500 * KIB) {
      return;
    }
    exceededLimitOutput.push([
      depKey,
      prettyBytes(dep.uncompressed),
      prettyBytes(dep.compressed)
    ]);
    numLargeDependencies += 1;
  });
  if (numLargeDependencies === 0) {
    exceededLimitOutput.push([
      "No large dependencies found (> 100KB compressed)"
    ]);
  }
  exceededLimitOutput.push([]);
  exceededLimitOutput.push([
    "All dependencies",
    prettyBytes(pseudoLayerUncompressedBytes),
    prettyBytes(pseudoLayerBytes)
  ]);
  console.log(
    (0, import_text_table.default)(exceededLimitOutput, {
      align: ["l", "r", "r"]
    })
  );
};
var detectLambdaLimitExceeding = async (lambdaGroups, compressedSizeLimit, compressedPages) => {
  const COMPRESSED_SIZE_LIMIT_CLOSE = compressedSizeLimit - 5 * MIB;
  const UNCOMPRESSED_SIZE_LIMIT_CLOSE = MAX_UNCOMPRESSED_LAMBDA_SIZE - 5 * MIB;
  let numExceededLimit = 0;
  let numCloseToLimit = 0;
  let loggedHeadInfo = false;
  const filteredGroups = lambdaGroups.filter((group) => {
    const exceededLimit = group.pseudoLayerBytes > compressedSizeLimit || group.pseudoLayerUncompressedBytes > MAX_UNCOMPRESSED_LAMBDA_SIZE;
    const closeToLimit = group.pseudoLayerBytes > COMPRESSED_SIZE_LIMIT_CLOSE || group.pseudoLayerUncompressedBytes > UNCOMPRESSED_SIZE_LIMIT_CLOSE;
    if (closeToLimit || exceededLimit || (0, import_build_utils.getPlatformEnv)("BUILDER_DEBUG") || process.env.NEXT_DEBUG_FUNCTION_SIZE) {
      if (exceededLimit) {
        numExceededLimit += 1;
      }
      if (closeToLimit) {
        numCloseToLimit += 1;
      }
      return true;
    }
  });
  for (const group of filteredGroups) {
    if (!loggedHeadInfo) {
      if (numExceededLimit || numCloseToLimit) {
        console.log(
          `Warning: Max serverless function size of ${prettyBytes(
            compressedSizeLimit
          )} compressed or ${prettyBytes(
            MAX_UNCOMPRESSED_LAMBDA_SIZE
          )} uncompressed${numExceededLimit ? "" : " almost"} reached`
        );
      } else {
        console.log(`Serverless function size info`);
      }
      loggedHeadInfo = true;
    }
    outputFunctionFileSizeInfo(
      group.pages,
      group.pseudoLayer,
      group.pseudoLayerBytes,
      group.pseudoLayerUncompressedBytes,
      compressedPages
    );
  }
  if (numExceededLimit) {
    console.log(
      `Max serverless function size was exceeded for ${numExceededLimit} function${numExceededLimit === 1 ? "" : "s"}`
    );
  }
};
var onPrerenderRouteInitial = (prerenderManifest, canUsePreviewMode, entryDirectory, nonLambdaSsgPages, routeKey, hasPages404, routesManifest, appDir) => {
  let static404Page;
  let static500Page;
  const pr = prerenderManifest.staticRoutes[routeKey];
  const { initialRevalidate, srcRoute, dataRoute } = pr;
  const route = srcRoute || routeKey;
  const isAppPathRoute = appDir && (!dataRoute || dataRoute?.endsWith(".rsc"));
  const routeNoLocale = routesManifest?.i18n ? normalizeLocalePath(routeKey, routesManifest.i18n.locales).pathname : routeKey;
  if (routeNoLocale === "/404") {
    static404Page = import_path2.default.posix.join(entryDirectory, routeKey);
  }
  if (routeNoLocale === "/500") {
    static500Page = import_path2.default.posix.join(entryDirectory, routeKey);
  }
  if (
    // App paths must be Prerenders to ensure Vary header is
    // correctly added
    !isAppPathRoute && initialRevalidate === false && (!canUsePreviewMode || hasPages404 && routeNoLocale === "/404") && !prerenderManifest.fallbackRoutes[route] && !prerenderManifest.blockingFallbackRoutes[route]
  ) {
    if (routesManifest?.i18n && Object.keys(prerenderManifest.staticRoutes).some((route2) => {
      const staticRoute = prerenderManifest.staticRoutes[route2];
      return staticRoute.srcRoute === srcRoute && staticRoute.initialRevalidate !== false;
    })) {
      return {
        static404Page,
        static500Page
      };
    }
    nonLambdaSsgPages.add(route === "/" ? "/index" : route);
  }
  return {
    static404Page,
    static500Page
  };
};
var prerenderGroup = 1;
var onPrerenderRoute = (prerenderRouteArgs) => async (routeKey, {
  isBlocking,
  isFallback,
  isOmitted,
  locale
}) => {
  const {
    appDir,
    pagesDir,
    static404Page,
    localePrefixed404,
    entryDirectory,
    prerenderManifest,
    isSharedLambdas,
    isServerMode,
    canUsePreviewMode,
    lambdas,
    experimentalStreamingLambdaPaths,
    prerenders,
    pageLambdaMap,
    routesManifest,
    isCorrectNotFoundRoutes,
    isEmptyAllowQueryForPrendered
  } = prerenderRouteArgs;
  if (isBlocking && isFallback) {
    throw new import_build_utils.NowBuildError({
      code: "NEXT_ISBLOCKING_ISFALLBACK",
      message: "invariant: isBlocking and isFallback cannot both be true"
    });
  }
  if (isFallback && isOmitted) {
    throw new import_build_utils.NowBuildError({
      code: "NEXT_ISOMITTED_ISFALLBACK",
      message: "invariant: isOmitted and isFallback cannot both be true"
    });
  }
  let routeFileNoExt = routeKey === "/" ? "/index" : routeKey;
  let origRouteFileNoExt = routeFileNoExt;
  const { isLocalePrefixed } = prerenderManifest;
  if (!locale && isLocalePrefixed) {
    const localePathResult = normalizeLocalePath(
      routeKey,
      routesManifest?.i18n?.locales || []
    );
    locale = localePathResult.detectedLocale;
    origRouteFileNoExt = localePathResult.pathname === "/" ? "/index" : localePathResult.pathname;
  }
  const nonDynamicSsg = !isFallback && !isBlocking && !isOmitted && !prerenderManifest.staticRoutes[routeKey].srcRoute;
  if (nonDynamicSsg && !isLocalePrefixed || isFallback || isOmitted) {
    routeFileNoExt = addLocaleOrDefault(
      // root index files are located without folder/index.html
      routeFileNoExt,
      routesManifest,
      locale
    );
  }
  const isNotFound = prerenderManifest.notFoundRoutes.includes(routeKey);
  let initialRevalidate;
  let srcRoute;
  let dataRoute;
  let prefetchDataRoute;
  let initialStatus;
  let initialHeaders;
  let experimentalBypassFor;
  let experimentalPPR;
  if (isFallback || isBlocking) {
    const pr = isFallback ? prerenderManifest.fallbackRoutes[routeKey] : prerenderManifest.blockingFallbackRoutes[routeKey];
    initialRevalidate = 1;
    if (initialRevalidate === false) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_ISLAZY_INITIALREVALIDATE",
        message: "invariant isLazy: initialRevalidate !== false"
      });
    }
    srcRoute = null;
    dataRoute = pr.dataRoute;
    experimentalBypassFor = pr.experimentalBypassFor;
    experimentalPPR = pr.experimentalPPR;
    prefetchDataRoute = pr.prefetchDataRoute;
  } else if (isOmitted) {
    initialRevalidate = false;
    srcRoute = routeKey;
    dataRoute = prerenderManifest.omittedRoutes[routeKey].dataRoute;
    experimentalBypassFor = prerenderManifest.omittedRoutes[routeKey].experimentalBypassFor;
    experimentalPPR = prerenderManifest.omittedRoutes[routeKey].experimentalPPR;
    prefetchDataRoute = prerenderManifest.omittedRoutes[routeKey].prefetchDataRoute;
  } else {
    const pr = prerenderManifest.staticRoutes[routeKey];
    ({
      initialRevalidate,
      srcRoute,
      dataRoute,
      initialHeaders,
      initialStatus,
      experimentalBypassFor,
      experimentalPPR,
      prefetchDataRoute
    } = pr);
  }
  let isAppPathRoute = false;
  if (appDir && experimentalPPR) {
    isAppPathRoute = true;
  }
  if (appDir && srcRoute && (!dataRoute || dataRoute?.endsWith(".rsc"))) {
    isAppPathRoute = true;
  }
  const isOmittedOrNotFound = isOmitted || isNotFound;
  let htmlFsRef = null;
  let prerender;
  if (experimentalPPR && appDir) {
    const htmlPath = import_path2.default.join(appDir, `${routeFileNoExt}.html`);
    const metaPath = import_path2.default.join(appDir, `${routeFileNoExt}.meta`);
    if (import_fs_extra3.default.existsSync(htmlPath) && import_fs_extra3.default.existsSync(metaPath)) {
      const meta = JSON.parse(await import_fs_extra3.default.readFile(metaPath, "utf8"));
      if ("postponed" in meta && typeof meta.postponed === "string") {
        prerender = meta.postponed;
        initialHeaders ??= {};
        initialHeaders["content-type"] = `application/x-nextjs-pre-render; state-length=${meta.postponed.length}`;
        const html = await import_fs_extra3.default.readFileSync(htmlPath, "utf8");
        prerender += html;
      }
    }
    if (!dataRoute?.endsWith(".rsc")) {
      throw new Error(
        `Invariant: unexpected output path for ${dataRoute} and PPR`
      );
    }
    if (!prefetchDataRoute?.endsWith(".prefetch.rsc")) {
      throw new Error(
        `Invariant: unexpected output path for ${prefetchDataRoute} and PPR`
      );
    }
  }
  if (prerender) {
    const contentType = initialHeaders?.["content-type"];
    if (!contentType) {
      throw new Error("Invariant: contentType can't be undefined");
    }
    htmlFsRef = new import_build_utils.FileBlob({ contentType, data: prerender });
  } else if (appDir && !dataRoute && !prefetchDataRoute && isAppPathRoute && !(isBlocking || isFallback)) {
    const contentType = initialHeaders?.["content-type"];
    const fsPath = import_path2.default.join(appDir, `${routeFileNoExt}.body`);
    if (import_fs_extra3.default.existsSync(fsPath)) {
      htmlFsRef = new import_build_utils.FileFsRef({
        fsPath,
        contentType: contentType || "text/html;charset=utf-8"
      });
    }
  } else {
    htmlFsRef = isBlocking || isNotFound && !static404Page ? (
      // Blocking pages do not have an HTML fallback
      null
    ) : new import_build_utils.FileFsRef({
      fsPath: import_path2.default.join(
        isAppPathRoute && !isOmittedOrNotFound && appDir ? appDir : pagesDir,
        isFallback ? (
          // Fallback pages have a special file.
          addLocaleOrDefault(
            prerenderManifest.fallbackRoutes[routeKey].fallback,
            routesManifest,
            locale
          )
        ) : (
          // Otherwise, the route itself should exist as a static HTML
          // file.
          `${isOmittedOrNotFound ? localePrefixed404 ? addLocaleOrDefault("/404", routesManifest, locale) : "/404" : routeFileNoExt}.html`
        )
      )
    });
  }
  const jsonFsRef = (
    // JSON data does not exist for fallback or blocking pages
    isFallback || isBlocking || isNotFound && !static404Page || !dataRoute ? null : new import_build_utils.FileFsRef({
      fsPath: import_path2.default.join(
        isAppPathRoute && !isOmittedOrNotFound && appDir ? appDir : pagesDir,
        `${isOmittedOrNotFound ? localePrefixed404 ? addLocaleOrDefault("/404.html", routesManifest, locale) : "/404.html" : isAppPathRoute ? prefetchDataRoute || dataRoute : routeFileNoExt + ".json"}`
      )
    })
  );
  if (isOmittedOrNotFound) {
    initialStatus = 404;
  }
  if (isAppPathRoute) {
    if (routeKey !== "/index" && routeKey.endsWith("/index")) {
      routeKey = `${routeKey}/index`;
      routeFileNoExt = routeKey;
    }
  }
  let outputPathPage = import_path2.default.posix.join(entryDirectory, routeFileNoExt);
  if (!isAppPathRoute) {
    outputPathPage = normalizeIndexOutput(outputPathPage, isServerMode);
  }
  const outputPathPageOrig = import_path2.default.posix.join(
    entryDirectory,
    origRouteFileNoExt
  );
  let lambda;
  function normalizeDataRoute(route) {
    let normalized = import_path2.default.posix.join(entryDirectory, route);
    if (nonDynamicSsg || isFallback || isOmitted) {
      normalized = normalized.replace(
        new RegExp(`${(0, import_escape_string_regexp.default)(origRouteFileNoExt)}.json$`),
        // ensure we escape "$" correctly while replacing as "$" is a special
        // character, we need to do double escaping as first is for the initial
        // replace on the routeFile and then the second on the outputPath
        `${routeFileNoExt.replace(/\$/g, "$$$$")}.json`
      );
    }
    return normalized;
  }
  let outputPathData = null;
  if (dataRoute) {
    outputPathData = normalizeDataRoute(dataRoute);
  }
  let outputPathPrefetchData = null;
  if (prefetchDataRoute) {
    if (!experimentalPPR) {
      throw new Error(
        "Invariant: prefetchDataRoute can't be set without PPR"
      );
    }
    outputPathPrefetchData = normalizeDataRoute(prefetchDataRoute);
  } else if (experimentalPPR) {
    throw new Error("Invariant: expected to find prefetch data route PPR");
  }
  const outputPrerenderPathData = outputPathPrefetchData || outputPathData;
  if (isSharedLambdas) {
    const outputSrcPathPage = normalizeIndexOutput(
      import_path2.default.join(
        "/",
        srcRoute == null ? outputPathPageOrig : import_path2.default.posix.join(
          entryDirectory,
          srcRoute === "/" ? "/index" : srcRoute
        )
      ),
      isServerMode
    );
    const lambdaId = pageLambdaMap[outputSrcPathPage];
    lambda = lambdas[lambdaId];
  } else {
    let outputSrcPathPage = srcRoute == null ? outputPathPageOrig : import_path2.default.posix.join(
      entryDirectory,
      srcRoute === "/" ? "/index" : srcRoute
    );
    if (!isAppPathRoute) {
      outputSrcPathPage = normalizeIndexOutput(
        outputSrcPathPage,
        isServerMode
      );
    }
    lambda = lambdas[outputSrcPathPage];
  }
  if (!isAppPathRoute && !isNotFound && initialRevalidate === false) {
    if (htmlFsRef == null || jsonFsRef == null) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_HTMLFSREF_JSONFSREF",
        message: `invariant: htmlFsRef != null && jsonFsRef != null ${routeFileNoExt}`
      });
    }
    if (!canUsePreviewMode || routeKey === "/404" && !lambdas[outputPathPage]) {
      htmlFsRef.contentType = htmlContentType;
      prerenders[outputPathPage] = htmlFsRef;
      if (outputPrerenderPathData) {
        prerenders[outputPrerenderPathData] = jsonFsRef;
      }
    }
  }
  const isNotFoundPreview = isCorrectNotFoundRoutes && !initialRevalidate && canUsePreviewMode && isServerMode && isNotFound;
  if (prerenders[outputPathPage] == null && (!isNotFound || initialRevalidate || isNotFoundPreview)) {
    if (lambda == null) {
      throw new import_build_utils.NowBuildError({
        code: "NEXT_MISSING_LAMBDA",
        message: `Unable to find lambda for route: ${routeFileNoExt}`
      });
    }
    const pageKey = srcRoute || routeKey;
    const route = routesManifest?.dynamicRoutes.find(
      (r) => r.page === pageKey && !("isMiddleware" in r)
    );
    const routeKeys = route?.routeKeys;
    let allowQuery;
    if (isEmptyAllowQueryForPrendered) {
      const isDynamic = isDynamicRoute(routeKey);
      if (!isDynamic) {
        allowQuery = [];
      } else if (routeKeys) {
        allowQuery = Object.values(routeKeys);
      }
    } else {
      const isDynamic = isDynamicRoute(pageKey);
      if (routeKeys) {
        allowQuery = Object.values(routeKeys);
      } else if (!isDynamic) {
        allowQuery = [];
      }
    }
    const rscEnabled = !!routesManifest?.rsc;
    const rscVaryHeader = routesManifest?.rsc?.varyHeader || "RSC, Next-Router-State-Tree, Next-Router-Prefetch";
    const rscContentTypeHeader = routesManifest?.rsc?.contentTypeHeader || RSC_CONTENT_TYPE;
    const rscDidPostponeHeader = routesManifest?.rsc?.didPostponeHeader;
    let sourcePath;
    if (`/${outputPathPage}` !== srcRoute && srcRoute) {
      sourcePath = srcRoute;
    }
    let key = srcRoute || routeKey;
    if (key === "/") {
      key = "index";
    } else {
      if (!key.startsWith("/")) {
        throw new Error("Invariant: key doesn't start with /");
      }
      key = key.substring(1);
    }
    key = import_path2.default.posix.join(entryDirectory, key);
    const experimentalStreamingLambdaPath = experimentalStreamingLambdaPaths?.get(key);
    prerenders[outputPathPage] = new import_build_utils.Prerender({
      expiration: initialRevalidate,
      lambda,
      allowQuery,
      fallback: htmlFsRef,
      group: prerenderGroup,
      bypassToken: prerenderManifest.bypassToken,
      experimentalBypassFor,
      initialStatus,
      initialHeaders,
      sourcePath,
      experimentalStreamingLambdaPath,
      ...isNotFound ? {
        initialStatus: 404
      } : {},
      ...rscEnabled ? {
        initialHeaders: {
          ...initialHeaders,
          vary: rscVaryHeader
        }
      } : {}
    });
    if (outputPrerenderPathData) {
      let normalizedPathData = outputPrerenderPathData;
      if ((srcRoute === "/" || srcRoute == "/index") && outputPrerenderPathData.endsWith(RSC_PREFETCH_SUFFIX)) {
        delete lambdas[normalizedPathData];
        normalizedPathData = normalizedPathData.replace(
          /([^/]+\.prefetch\.rsc)$/,
          "__$1"
        );
      }
      prerenders[normalizedPathData] = new import_build_utils.Prerender({
        expiration: initialRevalidate,
        lambda,
        allowQuery,
        fallback: jsonFsRef,
        group: prerenderGroup,
        bypassToken: prerenderManifest.bypassToken,
        experimentalBypassFor,
        ...isNotFound ? {
          initialStatus: 404
        } : {},
        ...rscEnabled ? {
          initialHeaders: {
            "content-type": rscContentTypeHeader,
            vary: rscVaryHeader,
            // If it contains a pre-render, then it was postponed.
            ...prerender && rscDidPostponeHeader ? { [rscDidPostponeHeader]: "1" } : {}
          }
        } : {}
      });
    }
    ++prerenderGroup;
    if (routesManifest?.i18n && isBlocking) {
      for (const locale2 of routesManifest.i18n.locales) {
        const localeRouteFileNoExt = addLocaleOrDefault(
          routeFileNoExt,
          routesManifest,
          locale2
        );
        let localeOutputPathPage = import_path2.default.posix.join(
          entryDirectory,
          localeRouteFileNoExt
        );
        if (!isAppPathRoute) {
          localeOutputPathPage = normalizeIndexOutput(
            localeOutputPathPage,
            isServerMode
          );
        }
        const origPrerenderPage = prerenders[outputPathPage];
        prerenders[localeOutputPathPage] = {
          ...origPrerenderPage,
          group: prerenderGroup
        };
        if (outputPathData) {
          const localeOutputPathData = outputPathData.replace(
            new RegExp(`${(0, import_escape_string_regexp.default)(origRouteFileNoExt)}.json$`),
            `${localeRouteFileNoExt}${localeRouteFileNoExt !== origRouteFileNoExt && origRouteFileNoExt === "/index" ? "/index" : ""}.json`
          );
          const origPrerenderData = prerenders[outputPathData];
          prerenders[localeOutputPathData] = {
            ...origPrerenderData,
            group: prerenderGroup
          };
        }
        ++prerenderGroup;
      }
    }
  }
  if ((nonDynamicSsg && !isLocalePrefixed || isFallback || isOmitted) && routesManifest?.i18n && !locale) {
    for (const locale2 of routesManifest.i18n.locales) {
      if (locale2 === routesManifest.i18n.defaultLocale)
        continue;
      onPrerenderRoute(prerenderRouteArgs)(routeKey, {
        isBlocking,
        isFallback,
        isOmitted,
        locale: locale2
      });
    }
  }
};
async function getStaticFiles(entryPath, entryDirectory, outputDirectory) {
  const collectLabel = "Collected static files (public/, static/, .next/static)";
  console.time(collectLabel);
  const nextStaticFiles = await (0, import_build_utils.glob)(
    "**",
    import_path2.default.join(entryPath, outputDirectory, "static")
  );
  const staticFolderFiles = await (0, import_build_utils.glob)("**", import_path2.default.join(entryPath, "static"));
  let publicFolderFiles = {};
  let publicFolderPath;
  if (await import_fs_extra3.default.pathExists(import_path2.default.join(entryPath, "public"))) {
    publicFolderPath = import_path2.default.join(entryPath, "public");
  } else if (
    // check at the same level as the output directory also
    await import_fs_extra3.default.pathExists(import_path2.default.join(entryPath, outputDirectory, "../public"))
  ) {
    publicFolderPath = import_path2.default.join(entryPath, outputDirectory, "../public");
  }
  if (publicFolderPath) {
    (0, import_build_utils.debug)(`Using public folder at ${publicFolderPath}`);
    publicFolderFiles = await (0, import_build_utils.glob)("**/*", publicFolderPath);
  } else {
    (0, import_build_utils.debug)("No public folder found");
  }
  const staticFiles = {};
  const staticDirectoryFiles = {};
  const publicDirectoryFiles = {};
  for (const file of Object.keys(nextStaticFiles)) {
    staticFiles[import_path2.default.posix.join(entryDirectory, `_next/static/${file}`)] = nextStaticFiles[file];
  }
  for (const file of Object.keys(staticFolderFiles)) {
    staticDirectoryFiles[import_path2.default.posix.join(entryDirectory, "static", file)] = staticFolderFiles[file];
  }
  for (const file of Object.keys(publicFolderFiles)) {
    publicDirectoryFiles[import_path2.default.posix.join(entryDirectory, file)] = publicFolderFiles[file];
  }
  console.timeEnd(collectLabel);
  return {
    staticFiles,
    staticDirectoryFiles,
    publicDirectoryFiles
  };
}
function normalizeIndexOutput(outputName, isServerMode) {
  if (outputName !== "index" && outputName !== "/index" && isServerMode) {
    return outputName.replace(/\/index$/, "");
  }
  return outputName;
}
function getNextServerPath(nextVersion) {
  return import_semver.default.gte(nextVersion, "v11.0.2-canary.4") ? "next/dist/server" : "next/dist/next-server/server";
}
function updateRouteSrc(route, index, manifestItems) {
  if (route.src) {
    route.src = manifestItems[index].regex;
  }
  return route;
}
async function getPrivateOutputs(dir, entries) {
  const files = {};
  const routes = [];
  for (const [existingFile, outputFile] of Object.entries(entries)) {
    const fsPath = import_path2.default.join(dir, existingFile);
    try {
      const { mode, size } = await (0, import_fs_extra3.stat)(fsPath);
      if (size > 30 * 1024 * 1024) {
        throw new Error(`Exceeds maximum file size: ${size}`);
      }
      files[outputFile] = new import_build_utils.FileFsRef({ mode, fsPath });
      routes.push({
        src: `/${outputFile}`,
        dest: "/404",
        status: 404,
        continue: true
      });
    } catch (error) {
      (0, import_build_utils.debug)(
        `Private file ${existingFile} had an error and will not be uploaded: ${error}`
      );
    }
  }
  return { files, routes };
}
var vercelFunctionRegionsVar = process.env.VERCEL_FUNCTION_REGIONS;
var vercelFunctionRegions;
if (vercelFunctionRegionsVar) {
  vercelFunctionRegions = vercelFunctionRegionsVar.split(",");
}
function normalizeRegions(regions) {
  if (typeof regions === "string") {
    regions = [regions];
  }
  const newRegions = [];
  for (const region of regions) {
    if (region === "home") {
      if (vercelFunctionRegions) {
        newRegions.push(...vercelFunctionRegions);
      }
      continue;
    }
    if (region === "global") {
      return "all";
    }
    if (region === "auto") {
      return "auto";
    }
    newRegions.push(region);
  }
  if (newRegions.length === 0) {
    return void 0;
  }
  return newRegions;
}
function normalizeEdgeFunctionPath(shortPath, appPathRoutesManifest) {
  if (shortPath.startsWith("app/") && (shortPath.endsWith("/page") || shortPath.endsWith("/route") || shortPath === "app/_not-found")) {
    const ogRoute = shortPath.replace(/^app\//, "/");
    shortPath = (appPathRoutesManifest[ogRoute] || shortPath.replace(/(^|\/)(page|route)$/, "")).replace(/^\//, "");
    if (!shortPath || shortPath === "/") {
      shortPath = "index";
    }
  }
  if (shortPath.startsWith("pages/")) {
    shortPath = shortPath.replace(/^pages\//, "");
  }
  return shortPath;
}
async function getMiddlewareBundle({
  entryPath,
  outputDirectory,
  routesManifest,
  isCorrectMiddlewareOrder,
  prerenderBypassToken,
  nextVersion,
  appPathRoutesManifest
}) {
  const middlewareManifest = await getMiddlewareManifest(
    entryPath,
    outputDirectory
  );
  const sortedFunctions = [
    ...!middlewareManifest ? [] : middlewareManifest.sortedMiddleware.map((key) => ({
      key,
      edgeFunction: middlewareManifest?.middleware[key],
      type: "middleware"
    })),
    ...Object.entries(middlewareManifest?.functions ?? {}).map(
      ([key, edgeFunction]) => {
        return {
          key,
          edgeFunction,
          type: "function"
        };
      }
    )
  ];
  if (middlewareManifest && sortedFunctions.length > 0) {
    const workerConfigs = await Promise.all(
      sortedFunctions.map(async ({ key, edgeFunction, type }) => {
        try {
          const wrappedModuleSource = await getNextjsEdgeFunctionSource(
            edgeFunction.files,
            {
              name: edgeFunction.name,
              staticRoutes: routesManifest.staticRoutes,
              dynamicRoutes: routesManifest.dynamicRoutes.filter(
                (r) => !("isMiddleware" in r)
              ),
              nextConfig: {
                basePath: routesManifest.basePath,
                i18n: routesManifest.i18n
              }
            },
            import_path2.default.resolve(entryPath, outputDirectory),
            edgeFunction.wasm
          );
          return {
            type,
            page: edgeFunction.page,
            name: edgeFunction.name,
            edgeFunction: (() => {
              const { source: source2, map } = wrappedModuleSource.sourceAndMap();
              const transformedMap = stringifySourceMap(
                transformSourceMap(map)
              );
              const wasmFiles = (edgeFunction.wasm ?? []).reduce(
                (acc, { filePath, name }) => {
                  const fullFilePath = import_path2.default.join(
                    entryPath,
                    outputDirectory,
                    filePath
                  );
                  acc[`wasm/${name}.wasm`] = new import_build_utils.FileFsRef({
                    mode: 420,
                    contentType: "application/wasm",
                    fsPath: fullFilePath
                  });
                  return acc;
                },
                {}
              );
              const assetFiles = (edgeFunction.assets ?? []).reduce(
                (acc, { filePath, name }) => {
                  const fullFilePath = import_path2.default.join(
                    entryPath,
                    outputDirectory,
                    filePath
                  );
                  acc[`assets/${name}`] = new import_build_utils.FileFsRef({
                    mode: 420,
                    contentType: "application/octet-stream",
                    fsPath: fullFilePath
                  });
                  return acc;
                },
                {}
              );
              return new import_build_utils.EdgeFunction({
                deploymentTarget: "v8-worker",
                name: edgeFunction.name,
                files: {
                  "index.js": new import_build_utils.FileBlob({
                    data: source2,
                    contentType: "application/javascript",
                    mode: 420
                  }),
                  ...transformedMap && {
                    "index.js.map": new import_build_utils.FileBlob({
                      data: transformedMap,
                      contentType: "application/json",
                      mode: 420
                    })
                  },
                  ...wasmFiles,
                  ...assetFiles
                },
                regions: edgeFunction.regions ? normalizeRegions(edgeFunction.regions) : void 0,
                entrypoint: "index.js",
                assets: (edgeFunction.assets ?? []).map(({ name }) => {
                  return {
                    name,
                    path: `assets/${name}`
                  };
                }),
                framework: {
                  slug: "nextjs",
                  version: nextVersion
                }
              });
            })(),
            routeMatchers: getRouteMatchers(edgeFunction, routesManifest)
          };
        } catch (e) {
          e.message = `Can't build edge function ${key}: ${e.message}`;
          throw e;
        }
      })
    );
    const source = {
      staticRoutes: [],
      dynamicRouteMap: /* @__PURE__ */ new Map(),
      edgeFunctions: {}
    };
    for (const worker of workerConfigs.values()) {
      let shortPath = worker.name;
      if (shortPath.startsWith("pages/")) {
        shortPath = shortPath.replace(/^pages\//, "");
      } else {
        shortPath = normalizeEdgeFunctionPath(shortPath, appPathRoutesManifest);
      }
      if (routesManifest?.basePath) {
        const isAppPathRoute = !!appPathRoutesManifest[shortPath];
        shortPath = import_path2.default.posix.join(
          "./",
          routesManifest?.basePath,
          shortPath.replace(/^\//, "")
        );
        if (!isAppPathRoute) {
          shortPath = normalizeIndexOutput(shortPath, true);
        }
      }
      worker.edgeFunction.name = shortPath;
      source.edgeFunctions[shortPath] = worker.edgeFunction;
      if (worker.type === "function") {
        continue;
      }
      for (const matcher of worker.routeMatchers) {
        const route = {
          continue: true,
          src: matcher.regexp,
          has: matcher.has,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate",
              value: prerenderBypassToken
            },
            ...matcher.missing || []
          ]
        };
        route.middlewarePath = shortPath;
        route.middlewareRawSrc = matcher.originalSource ? [matcher.originalSource] : [];
        if (isCorrectMiddlewareOrder) {
          route.override = true;
        }
        if (routesManifest.version > 3 && isDynamicRoute(worker.page)) {
          source.dynamicRouteMap.set(worker.page, route);
        } else {
          source.staticRoutes.push(route);
        }
      }
    }
    return source;
  }
  return {
    staticRoutes: [],
    dynamicRouteMap: /* @__PURE__ */ new Map(),
    edgeFunctions: {}
  };
}
async function getFunctionsConfigManifest(entryPath, outputDirectory) {
  const functionConfigManifestPath = import_path2.default.join(
    entryPath,
    outputDirectory,
    "./server/functions-config-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(functionConfigManifestPath).then(() => true).catch(() => false);
  if (!hasManifest) {
    return;
  }
  const manifest = await import_fs_extra3.default.readJSON(
    functionConfigManifestPath
  );
  return manifest.version === 1 ? manifest : void 0;
}
async function getMiddlewareManifest(entryPath, outputDirectory) {
  const middlewareManifestPath = import_path2.default.join(
    entryPath,
    outputDirectory,
    "./server/middleware-manifest.json"
  );
  const hasManifest = await import_fs_extra3.default.access(middlewareManifestPath).then(() => true).catch(() => false);
  if (!hasManifest) {
    return;
  }
  const manifest = await import_fs_extra3.default.readJSON(
    middlewareManifestPath
  );
  return manifest.version === 1 ? upgradeMiddlewareManifest(manifest) : manifest;
}
function upgradeMiddlewareManifest(v1) {
  function updateInfo(v1Info) {
    const { regexp, ...rest } = v1Info;
    return {
      ...rest,
      matchers: [{ regexp }]
    };
  }
  const middleware = Object.fromEntries(
    Object.entries(v1.middleware).map(([p, info]) => [p, updateInfo(info)])
  );
  const functions = v1.functions ? Object.fromEntries(
    Object.entries(v1.functions).map(([p, info]) => [p, updateInfo(info)])
  ) : void 0;
  return {
    ...v1,
    version: 2,
    middleware,
    functions
  };
}
function getRouteMatchers(info, { basePath = "", i18n }) {
  function getRegexp(regexp) {
    if (info.page === "/") {
      return regexp;
    }
    const locale = i18n?.locales.length ? `(?:/(${i18n.locales.map((locale2) => (0, import_escape_string_regexp.default)(locale2)).join("|")}))?` : "";
    return `(?:^${basePath}${locale}${regexp.substring(1)})`;
  }
  function normalizeHas(has) {
    return has.map(
      (v) => v.type === "header" ? {
        ...v,
        key: v.key.toLowerCase()
      } : v
    );
  }
  return info.matchers.map((matcher) => {
    const m = {
      regexp: getRegexp(matcher.regexp),
      originalSource: matcher.originalSource
    };
    if (matcher.has) {
      m.has = normalizeHas(matcher.has);
    }
    if (matcher.missing) {
      m.missing = normalizeHas(matcher.missing);
    }
    return m;
  });
}
function transformSourceMap(sourcemap) {
  if (!sourcemap)
    return;
  const sources = sourcemap.sources?.map((source) => {
    return source.replace(/^webpack:\/\/?_N_E\/(?:\.\/)?/, "");
  }).map((source) => {
    return source.startsWith("?") ? "[native code]" : source;
  });
  return { ...sourcemap, sources };
}
function getOperationType({
  group,
  prerenderManifest,
  pageFileName
}) {
  if (group?.isApiLambda || isApiPage(pageFileName)) {
    return "API";
  }
  if (group?.isPrerenders) {
    return "ISR";
  }
  if (pageFileName && prerenderManifest) {
    const { blockingFallbackRoutes = {}, fallbackRoutes = {} } = prerenderManifest;
    if (pageFileName in blockingFallbackRoutes || pageFileName in fallbackRoutes) {
      return "ISR";
    }
  }
  return "Page";
}
function isApiPage(page) {
  if (!page) {
    return false;
  }
  return page.replace(/\\/g, "/").match(/(serverless|server)\/pages\/api(\/|\.js$)/);
}
async function getVariantsManifest(entryPath, outputDirectory) {
  const pathVariantsManifest = import_path2.default.join(
    entryPath,
    outputDirectory,
    "variants-manifest.json"
  );
  const hasVariantsManifest = await import_fs_extra3.default.access(pathVariantsManifest).then(() => true).catch(() => false);
  if (!hasVariantsManifest)
    return null;
  const variantsManifest = await import_fs_extra3.default.readJSON(
    pathVariantsManifest
  );
  return variantsManifest;
}
async function getServerlessPages(params) {
  const appDir = import_path2.default.join(params.pagesDir, "../app");
  const [pages, appPaths, middlewareManifest] = await Promise.all([
    (0, import_build_utils.glob)("**/!(_middleware).js", params.pagesDir),
    params.appPathRoutesManifest ? Promise.all([
      (0, import_build_utils.glob)("**/page.js", appDir),
      (0, import_build_utils.glob)("**/route.js", appDir),
      (0, import_build_utils.glob)("**/_not-found.js", appDir)
    ]).then((items) => Object.assign(...items)) : Promise.resolve({}),
    getMiddlewareManifest(params.entryPath, params.outputDirectory)
  ]);
  const normalizedAppPaths = {};
  if (params.appPathRoutesManifest) {
    for (const [entry, normalizedEntry] of Object.entries(
      params.appPathRoutesManifest
    )) {
      const normalizedPath = `${import_path2.default.join(
        ".",
        normalizedEntry === "/" ? "/index" : normalizedEntry
      )}.js`;
      const globPath = `${import_path2.default.posix.join(".", entry)}.js`;
      if (appPaths[globPath]) {
        normalizedAppPaths[normalizedPath] = appPaths[globPath];
      }
    }
  }
  for (const edgeFunctionFile of Object.keys(
    middlewareManifest?.functions ?? {}
  )) {
    let edgePath = middlewareManifest?.functions?.[edgeFunctionFile].name || edgeFunctionFile;
    edgePath = normalizeEdgeFunctionPath(
      edgePath,
      params.appPathRoutesManifest || {}
    );
    edgePath = (edgePath || "index") + ".js";
    delete normalizedAppPaths[edgePath];
    delete pages[edgePath];
  }
  return { pages, appPaths: normalizedAppPaths };
}
function normalizePrefetches(prefetches) {
  const updatedPrefetches = {};
  for (const key in prefetches) {
    if (key === "index.prefetch.rsc") {
      const newKey = key.replace(/([^/]+\.prefetch\.rsc)$/, "__$1");
      updatedPrefetches[newKey] = prefetches[key];
    } else {
      updatedPrefetches[key] = prefetches[key];
    }
  }
  return updatedPrefetches;
}

// src/create-serverless-config.ts
function getCustomData(importName, target) {
  return `
// @ts-nocheck
module.exports = function(...args) {
  let original = require('./${importName}');

  const finalConfig = {};
  const target = { target: '${target}' };

  if (typeof original === 'function' && original.constructor.name === 'AsyncFunction') {
    // AsyncFunctions will become promises
    original = original(...args);
  }

  if (original instanceof Promise) {
    // Special case for promises, as it's currently not supported
    // and will just error later on
    return original
      .then((orignalConfig) => Object.assign(finalConfig, orignalConfig))
      .then((config) => Object.assign(config, target));
  } else if (typeof original === 'function') {
    Object.assign(finalConfig, original(...args));
  } else if (typeof original === 'object') {
    Object.assign(finalConfig, original);
  }

  Object.assign(finalConfig, target);

  return finalConfig;
}
  `.trim();
}
function getDefaultData(target) {
  return `
// @ts-nocheck
module.exports = { target: '${target}' };
  `.trim();
}
async function createServerlessConfig(workPath, entryPath, nextVersion) {
  let target = "serverless";
  if (nextVersion) {
    try {
      if (import_semver2.default.gte(nextVersion, ExperimentalTraceVersion)) {
        target = "experimental-serverless-trace";
      }
    } catch (_ignored) {
    }
  }
  const primaryConfigPath = import_path3.default.join(entryPath, "next.config.js");
  const secondaryConfigPath = import_path3.default.join(workPath, "next.config.js");
  const backupConfigName = `next.config.__vercel_builder_backup__.js`;
  const hasPrimaryConfig = import_fs_extra4.default.existsSync(primaryConfigPath);
  const hasSecondaryConfig = import_fs_extra4.default.existsSync(secondaryConfigPath);
  let configPath;
  let backupConfigPath;
  if (hasPrimaryConfig) {
    configPath = primaryConfigPath;
    backupConfigPath = import_path3.default.join(entryPath, backupConfigName);
  } else if (hasSecondaryConfig) {
    configPath = secondaryConfigPath;
    backupConfigPath = import_path3.default.join(workPath, backupConfigName);
  } else {
    configPath = primaryConfigPath;
    backupConfigPath = import_path3.default.join(entryPath, backupConfigName);
  }
  if (import_fs_extra4.default.existsSync(configPath)) {
    await import_fs_extra4.default.rename(configPath, backupConfigPath);
    await import_fs_extra4.default.writeFile(configPath, getCustomData(backupConfigName, target));
  } else {
    await import_fs_extra4.default.writeFile(configPath, getDefaultData(target));
  }
  return target;
}

// src/legacy-versions.ts
var legacy_versions_default = [
  "0.1.0",
  "0.1.1",
  "0.2.0",
  "0.2.1",
  "0.2.2",
  "0.2.3",
  "0.2.4",
  "0.2.5",
  "0.2.6",
  "0.2.7",
  "0.2.8",
  "0.2.9",
  "0.2.10",
  "0.2.11",
  "0.2.12",
  "0.2.13",
  "0.2.14",
  "0.3.0",
  "0.3.1",
  "0.3.2",
  "0.3.3",
  "0.4.0",
  "0.4.1",
  "0.9.9",
  "0.9.10",
  "0.9.11",
  "1.0.0",
  "1.0.1",
  "1.0.2",
  "1.1.0",
  "1.1.1",
  "1.1.2",
  "1.2.0",
  "1.2.1",
  "1.2.2",
  "1.2.3",
  "2.0.0-beta.0",
  "2.0.0-beta.1",
  "2.0.0-beta.2",
  "2.0.0-beta.3",
  "2.0.0-beta.4",
  "2.0.0-beta.5",
  "2.0.0-beta.6",
  "2.0.0-beta.7",
  "2.0.0-beta.8",
  "2.0.0-beta.9",
  "2.0.0-beta.10",
  "2.0.0-beta.11",
  "2.0.0-beta.12",
  "2.0.0-beta.13",
  "2.0.0-beta.14",
  "2.0.0-beta.15",
  "2.0.0-beta.16",
  "2.0.0-beta.17",
  "2.0.0-beta.18",
  "2.0.0-beta.19",
  "2.0.0-beta.20",
  "2.0.0-beta.21",
  "2.0.0-beta.22",
  "2.0.0-beta.23",
  "2.0.0-beta.24",
  "2.0.0-beta.25",
  "2.0.0-beta.26",
  "2.0.0-beta.27",
  "2.0.0-beta.28",
  "2.0.0-beta.29",
  "2.0.0-beta.30",
  "2.0.0-beta.31",
  "2.0.0-beta.32",
  "2.0.0-beta.33",
  "2.0.0-beta.34",
  "2.0.0-beta.35",
  "2.0.0-beta.36",
  "2.0.0-beta.37",
  "2.0.0-beta.38",
  "2.0.0-beta.39",
  "2.0.0-beta.40",
  "2.0.0-beta.41",
  "2.0.0-beta.42",
  "2.0.0",
  "2.0.1",
  "2.1.0",
  "2.1.1",
  "2.2.0",
  "2.3.0-alpha1",
  "2.3.0",
  "2.3.1",
  "2.4.0",
  "2.4.1",
  "2.4.2",
  "2.4.3",
  "2.4.4",
  "2.4.5",
  "2.4.6",
  "2.4.7",
  "2.4.8",
  "2.4.9",
  "3.0.0-beta1",
  "3.0.0-beta10",
  "3.0.0-beta11",
  "3.0.0-beta12",
  "3.0.0-beta13",
  "3.0.0-beta14",
  "3.0.0-beta15",
  "3.0.0-beta16",
  "3.0.0-beta2",
  "3.0.0-beta3",
  "3.0.0-beta4",
  "3.0.0-beta5",
  "3.0.0-beta6",
  "3.0.0-beta7",
  "3.0.0-beta8",
  "3.0.0-beta9",
  "3.0.1-beta.1",
  "3.0.1-beta.2",
  "3.0.1-beta.3",
  "3.0.1-beta.4",
  "3.0.1-beta.5",
  "3.0.1-beta.6",
  "3.0.1-beta.7",
  "3.0.1-beta.8",
  "3.0.1-beta.9",
  "3.0.1-beta.10",
  "3.0.1-beta.11",
  "3.0.1-beta.12",
  "3.0.1-beta.13",
  "3.0.1-beta.14",
  "3.0.1-beta.15",
  "3.0.1-beta.16",
  "3.0.1-beta.17",
  "3.0.1-beta.18",
  "3.0.1-beta.19",
  "3.0.1-beta.20",
  "3.0.1-beta.21",
  "3.0.1",
  "3.0.2",
  "3.0.3",
  "3.0.4",
  "3.0.5",
  "3.0.6",
  "3.1.0",
  "3.2.0",
  "3.2.1",
  "3.2.2",
  "3.2.3",
  "4.0.0-beta.1",
  "4.0.0-beta.2",
  "4.0.0-beta.3",
  "4.0.0-beta.4",
  "4.0.0-beta.5",
  "4.0.0-beta.6",
  "4.0.0",
  "4.0.1",
  "4.0.2",
  "4.0.3",
  "4.0.4",
  "4.0.5",
  "4.1.0",
  "4.1.1",
  "4.1.2",
  "4.1.3",
  "4.1.4-canary.1",
  "4.1.4-canary.2",
  "4.1.4",
  "4.2.0-canary.1",
  "4.2.0-zones.2",
  "4.2.0",
  "4.2.1",
  "4.2.2",
  "4.2.3",
  "4.3.0-canary.1",
  "4.3.0-universal-alpha.1",
  "4.3.0-universal-alpha.2",
  "4.3.0-universal-alpha.3",
  "4.3.0-universal-alpha.4",
  "4.3.0-zones.1",
  "4.4.0-canary.2",
  "4.4.0-canary.3",
  "5.0.0-universal-alpha.1",
  "5.0.0-universal-alpha.2",
  "5.0.0-universal-alpha.3",
  "5.0.0-universal-alpha.4",
  "5.0.0-universal-alpha.5",
  "5.0.0-universal-alpha.6",
  "5.0.0-universal-alpha.7",
  "5.0.0-universal-alpha.8",
  "5.0.0-universal-alpha.9",
  "5.0.0-universal-alpha.10",
  "5.0.0-universal-alpha.11",
  "5.0.0-universal-alpha.12",
  "5.0.0-universal-alpha.13",
  "5.0.0-universal-alpha.14",
  "5.0.0-universal-alpha.15",
  "5.0.0-universal-alpha.16",
  "5.0.0-universal-alpha.17",
  "5.0.0-universal-alpha.18",
  "5.0.0-universal-alpha.19",
  "5.0.0-universal-alpha.20",
  "5.0.0-universal-alpha.21",
  "5.0.0-universal-alpha.22",
  "5.0.0-universal-alpha.23",
  "5.0.0-zones.1",
  "5.0.0",
  "5.0.1-canary.1",
  "5.0.1-canary.2",
  "5.0.1-canary.3",
  "5.0.1-canary.4",
  "5.0.1-canary.5",
  "5.0.1-canary.6",
  "5.0.1-canary.7",
  "5.0.1-canary.8",
  "5.0.1-canary.9",
  "5.0.1-canary.10",
  "5.0.1-canary.11",
  "5.0.1-canary.12",
  "5.0.1-canary.13",
  "5.0.1-canary.14",
  "5.0.1-canary.15",
  "5.0.1-canary.16",
  "5.0.1-canary.17",
  "5.1.0",
  "6.0.0-canary.1",
  "6.0.0-canary.2",
  "6.0.0-canary.3",
  "6.0.0-canary.4",
  "6.0.0-canary.5",
  "6.0.0-canary.6",
  "6.0.0-canary.7",
  "6.0.0",
  "6.0.1-canary.0",
  "6.0.1-canary.1",
  "6.0.1-canary.2",
  "6.0.1",
  "6.0.2-canary.0",
  "6.0.2",
  "6.0.3-canary.0",
  "6.0.3-canary.1",
  "6.0.3",
  "6.0.4-canary.0",
  "6.0.4-canary.1",
  "6.0.4-canary.2",
  "6.0.4-canary.3",
  "6.0.4-canary.4",
  "6.0.4-canary.5",
  "6.0.4-canary.6",
  "6.0.4-canary.7",
  "6.0.4-canary.8",
  "6.0.4-canary.9",
  "6.1.0-canary.0",
  "6.1.0",
  "6.1.1-canary.0",
  "6.1.1-canary.1",
  "6.1.1-canary.2",
  "6.1.1-canary.3",
  "6.1.1-canary.4",
  "6.1.1-canary.5",
  "6.1.1",
  "6.1.2",
  "7.0.0-canary.0",
  "7.0.0-canary.1",
  "7.0.0-canary.2",
  "7.0.0-canary.3",
  "7.0.0-canary.4",
  "7.0.0-canary.5",
  "7.0.0-canary.6",
  "7.0.0-canary.7",
  "7.0.0-canary.8",
  "7.0.0-canary.9",
  "7.0.0-canary.10",
  "7.0.0-canary.11",
  "7.0.0-canary.12",
  "7.0.0-canary.13",
  "7.0.0-canary.14",
  "7.0.0-canary.15",
  "7.0.0-canary.16",
  "7.0.0-canary.18",
  "7.0.0-canary.19",
  "7.0.0-canary.20",
  "7.0.0",
  "7.0.1-canary.0",
  "7.0.1-canary.1",
  "7.0.1-canary.2",
  "7.0.1-canary.3",
  "7.0.1-canary.4",
  "7.0.1-canary.5",
  "7.0.1-canary.6",
  "7.0.1",
  "7.0.2-alpha.1",
  "7.0.2-alpha.3",
  "7.0.2-canary.5",
  "7.0.2-canary.6",
  "7.0.2-canary.7",
  "7.0.2-canary.8",
  "7.0.2-canary.9",
  "7.0.2-canary.10",
  "7.0.2-canary.11",
  "7.0.2-canary.12",
  "7.0.2-canary.13",
  "7.0.2-canary.14",
  "7.0.2-canary.15",
  "7.0.2-canary.16",
  "7.0.2-canary.17",
  "7.0.2-canary.18",
  "7.0.2-canary.19",
  "7.0.2-canary.20",
  "7.0.2-canary.21",
  "7.0.2-canary.22",
  "7.0.2-canary.23",
  "7.0.2-canary.24",
  "7.0.2-canary.25",
  "7.0.2-canary.26",
  "7.0.2-canary.27",
  "7.0.2-canary.28",
  "7.0.2-canary.29",
  "7.0.2-canary.31",
  "7.0.2-canary.33",
  "7.0.2-canary.34",
  "7.0.2-canary.35",
  "7.0.2-canary.36",
  "7.0.2-canary.37",
  "7.0.2-canary.38",
  "7.0.2-canary.39",
  "7.0.2-canary.40",
  "7.0.2-canary.41",
  "7.0.2-canary.42",
  "7.0.2-canary.43",
  "7.0.2-canary.44",
  "7.0.2-canary.45",
  "7.0.2-canary.46",
  "7.0.2-canary.47",
  "7.0.2-canary.48",
  "7.0.2-canary.49",
  "7.0.2-canary.50",
  "7.0.2"
];

// src/server-build.ts
var import_path4 = __toESM(require("path"));
var import_semver3 = __toESM(require_semver());
var import_async_sema2 = __toESM(require_lib());
var import_build_utils2 = require("@vercel/build-utils");
var import_nft = require("@vercel/nft");
var import_resolve_from = __toESM(require_resolve_from());
var import_fs_extra5 = __toESM(require_lib2());
var import_escape_string_regexp2 = __toESM(require_escape_string_regexp());
var import_pretty_bytes3 = __toESM(require_pretty_bytes());
var CORRECT_NOT_FOUND_ROUTES_VERSION = "v12.0.1";
var CORRECT_MIDDLEWARE_ORDER_VERSION = "v12.1.7-canary.29";
var NEXT_DATA_MIDDLEWARE_RESOLVING_VERSION = "v12.1.7-canary.33";
var EMPTY_ALLOW_QUERY_FOR_PRERENDERED_VERSION = "v12.2.0";
var CORRECTED_MANIFESTS_VERSION = "v12.2.0";
var PRELOAD_CHUNKS = {
  APP_ROUTER_PAGES: [
    ".next/server/webpack-runtime.js",
    "next/dist/client/components/action-async-storage.external.js",
    "next/dist/client/components/request-async-storage.external.js",
    "next/dist/client/components/static-generation-async-storage.external.js",
    "next/dist/compiled/next-server/app-page.runtime.prod.js"
  ],
  APP_ROUTER_HANDLER: [
    ".next/server/webpack-runtime.js",
    "next/dist/compiled/next-server/app-route.runtime.prod.js"
  ],
  PAGES_ROUTER_PAGES: [
    ".next/server/webpack-runtime.js",
    "next/dist/compiled/next-server/pages.runtime.prod.js"
  ],
  PAGES_ROUTER_API: [
    ".next/server/webpack-api-runtime.js",
    "next/dist/compiled/next-server/pages-api.runtime.prod.js"
  ]
};
var BUNDLED_SERVER_NEXT_VERSION = "v13.5.4";
var BUNDLED_SERVER_NEXT_PATH = "next/dist/compiled/next-server/server.runtime.prod.js";
async function serverBuild({
  dynamicPages,
  pagesDir,
  config = {},
  functionsConfigManifest,
  privateOutputs,
  baseDir,
  workPath,
  entryPath,
  nodeVersion,
  buildId,
  escapedBuildId,
  dynamicPrefix,
  entryDirectory,
  outputDirectory,
  redirects,
  beforeFilesRewrites,
  afterFilesRewrites,
  fallbackRewrites,
  headers,
  dataRoutes,
  hasIsr404Page,
  hasIsr500Page,
  imagesManifest,
  wildcardConfig,
  routesManifest,
  staticPages,
  lambdaPages,
  localePrefixed404,
  nextVersion,
  lambdaAppPaths,
  canUsePreviewMode,
  trailingSlash,
  prerenderManifest,
  appPathRoutesManifest,
  omittedPrerenderRoutes,
  trailingSlashRedirects,
  isCorrectLocaleAPIRoutes,
  lambdaCompressedByteLimit,
  requiredServerFilesManifest,
  variantsManifest
}) {
  lambdaPages = Object.assign({}, lambdaPages, lambdaAppPaths);
  const lambdas = {};
  const prerenders = {};
  const lambdaPageKeys = Object.keys(lambdaPages);
  const internalPages = ["_app.js", "_error.js", "_document.js"];
  const pageBuildTraces = await (0, import_build_utils2.glob)("**/*.js.nft.json", pagesDir);
  const isEmptyAllowQueryForPrendered = import_semver3.default.gte(
    nextVersion,
    EMPTY_ALLOW_QUERY_FOR_PRERENDERED_VERSION
  );
  const projectDir = requiredServerFilesManifest.relativeAppDir ? import_path4.default.join(baseDir, requiredServerFilesManifest.relativeAppDir) : requiredServerFilesManifest.appDir || entryPath;
  const inversedAppPathManifest = {};
  if (appPathRoutesManifest) {
    for (const ogRoute of Object.keys(appPathRoutesManifest)) {
      inversedAppPathManifest[appPathRoutesManifest[ogRoute]] = ogRoute;
    }
  }
  const experimental = {
    ppr: requiredServerFilesManifest.config.experimental?.ppr === true
  };
  let appRscPrefetches = {};
  let appBuildTraces = {};
  let appDir = null;
  if (appPathRoutesManifest) {
    appDir = import_path4.default.join(pagesDir, "../app");
    appBuildTraces = await (0, import_build_utils2.glob)("**/*.js.nft.json", appDir);
    appRscPrefetches = experimental.ppr ? {} : await (0, import_build_utils2.glob)(`**/*${RSC_PREFETCH_SUFFIX}`, appDir);
    const rscContentTypeHeader = routesManifest?.rsc?.contentTypeHeader || RSC_CONTENT_TYPE;
    appRscPrefetches = normalizePrefetches(appRscPrefetches);
    for (const value of Object.values(appRscPrefetches)) {
      if (!value.contentType) {
        value.contentType = rscContentTypeHeader;
      }
    }
    for (const rewrite of afterFilesRewrites) {
      if (rewrite.src && rewrite.dest) {
        rewrite.src = rewrite.src.replace(
          /\/?\(\?:\/\)\?/,
          "(?<rscsuff>(\\.prefetch)?\\.rsc)?(?:/)?"
        );
        let destQueryIndex = rewrite.dest.indexOf("?");
        if (destQueryIndex === -1) {
          destQueryIndex = rewrite.dest.length;
        }
        rewrite.dest = rewrite.dest.substring(0, destQueryIndex) + "$rscsuff" + rewrite.dest.substring(destQueryIndex);
      }
    }
  }
  const isCorrectNotFoundRoutes = import_semver3.default.gte(
    nextVersion,
    CORRECT_NOT_FOUND_ROUTES_VERSION
  );
  const isCorrectMiddlewareOrder = import_semver3.default.gte(
    nextVersion,
    CORRECT_MIDDLEWARE_ORDER_VERSION
  );
  const isCorrectManifests = import_semver3.default.gte(
    nextVersion,
    CORRECTED_MANIFESTS_VERSION
  );
  let hasStatic500 = !!staticPages[import_path4.default.posix.join(entryDirectory, "500")];
  if (lambdaPageKeys.length === 0) {
    throw new import_build_utils2.NowBuildError({
      code: "NEXT_NO_SERVER_PAGES",
      message: "No server pages were built",
      link: "https://err.sh/vercel/vercel/now-next-no-serverless-pages-built"
    });
  }
  const pageMatchesApi = (page) => {
    const normalizedPage = `/${page.replace(/\.js$/, "")}`;
    return !inversedAppPathManifest[normalizedPage] && (page.startsWith("api/") || page === "api.js");
  };
  const { i18n } = routesManifest;
  const hasPages404 = routesManifest.pages404;
  let static404Page = staticPages[import_path4.default.posix.join(entryDirectory, "404")] && hasPages404 ? import_path4.default.posix.join(entryDirectory, "404") : staticPages[import_path4.default.posix.join(entryDirectory, "_errors/404")] ? import_path4.default.posix.join(entryDirectory, "_errors/404") : void 0;
  if (!static404Page && i18n && staticPages[import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "404")]) {
    static404Page = import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "404");
  }
  if (!hasStatic500 && i18n) {
    hasStatic500 = !!staticPages[import_path4.default.posix.join(entryDirectory, i18n.defaultLocale, "500")];
  }
  const lstatSema = new import_async_sema2.Sema(25);
  const lstatResults = {};
  const nonLambdaSsgPages = /* @__PURE__ */ new Set();
  Object.keys(prerenderManifest.staticRoutes).forEach((route) => {
    const result = onPrerenderRouteInitial(
      prerenderManifest,
      canUsePreviewMode,
      entryDirectory,
      nonLambdaSsgPages,
      route,
      routesManifest.pages404,
      routesManifest,
      appDir
    );
    if (result && result.static404Page) {
      static404Page = result.static404Page;
    }
    if (result && result.static500Page) {
      hasStatic500 = true;
    }
  });
  const hasLambdas = !static404Page || lambdaPageKeys.some(
    (page) => !internalPages.includes(page) && !nonLambdaSsgPages.has("/" + page.replace(/\.js$/, ""))
  );
  if (lambdaPages["404.js"]) {
    internalPages.push("404.js");
  }
  const experimentalPPRRoutes = /* @__PURE__ */ new Set();
  for (const [route, { experimentalPPR }] of [
    ...Object.entries(prerenderManifest.staticRoutes),
    ...Object.entries(prerenderManifest.blockingFallbackRoutes),
    ...Object.entries(prerenderManifest.fallbackRoutes)
  ]) {
    if (!experimentalPPR)
      continue;
    experimentalPPRRoutes.add(route);
  }
  const prerenderRoutes = /* @__PURE__ */ new Set([
    ...canUsePreviewMode ? omittedPrerenderRoutes : [],
    ...Object.keys(prerenderManifest.blockingFallbackRoutes),
    ...Object.keys(prerenderManifest.fallbackRoutes),
    ...Object.keys(prerenderManifest.staticRoutes).map((route) => {
      const staticRoute = prerenderManifest.staticRoutes[route];
      return staticRoute.srcRoute || route;
    })
  ]);
  const experimentalStreamingLambdaPaths = /* @__PURE__ */ new Map();
  if (hasLambdas) {
    const initialTracingLabel = "Traced Next.js server files in";
    console.time(initialTracingLabel);
    const initialTracedFiles = {};
    let initialFileList;
    let initialFileReasons;
    let nextServerBuildTrace;
    let instrumentationHookBuildTrace;
    const useBundledServer = import_semver3.default.gte(nextVersion, BUNDLED_SERVER_NEXT_VERSION) && process.env.VERCEL_NEXT_BUNDLED_SERVER === "1";
    if (useBundledServer) {
      (0, import_build_utils2.debug)("Using bundled Next.js server");
    }
    const nextServerFile = (0, import_resolve_from.default)(
      projectDir,
      useBundledServer ? BUNDLED_SERVER_NEXT_PATH : `${getNextServerPath(nextVersion)}/next-server.js`
    );
    try {
      nextServerBuildTrace = JSON.parse(
        await import_fs_extra5.default.readFile(
          import_path4.default.join(
            entryPath,
            outputDirectory,
            useBundledServer ? "next-minimal-server.js.nft.json" : "next-server.js.nft.json"
          ),
          "utf8"
        )
      );
    } catch (_) {
    }
    try {
      instrumentationHookBuildTrace = JSON.parse(
        await import_fs_extra5.default.readFile(
          import_path4.default.join(
            entryPath,
            outputDirectory,
            "server",
            "instrumentation.js.nft.json"
          ),
          "utf8"
        )
      );
    } catch (_) {
    }
    if (nextServerBuildTrace) {
      initialFileList = nextServerBuildTrace.files.map((file) => {
        return import_path4.default.relative(
          baseDir,
          import_path4.default.join(entryPath, outputDirectory, file)
        );
      });
      initialFileReasons = /* @__PURE__ */ new Map();
      (0, import_build_utils2.debug)("Using next-server.js.nft.json trace from build");
    } else {
      (0, import_build_utils2.debug)("tracing initial Next.js server files");
      const result = await (0, import_nft.nodeFileTrace)([nextServerFile], {
        base: baseDir,
        cache: {},
        processCwd: entryPath,
        ignore: [
          ...requiredServerFilesManifest.ignore.map(
            (file) => import_path4.default.join(entryPath, file)
          ),
          "node_modules/next/dist/pages/**/*",
          `node_modules/${getNextServerPath(
            nextVersion
          )}/lib/squoosh/**/*.wasm`,
          "node_modules/next/dist/compiled/webpack/(bundle4|bundle5).js",
          "node_modules/react/**/*.development.js",
          "node_modules/react-dom/**/*.development.js",
          "node_modules/use-subscription/**/*.development.js",
          "node_modules/sharp/**/*"
        ]
      });
      initialFileList = Array.from(result.fileList);
      initialFileReasons = result.reasons;
    }
    if (instrumentationHookBuildTrace) {
      initialFileList = initialFileList.concat(
        instrumentationHookBuildTrace.files.map((file) => {
          return import_path4.default.relative(
            baseDir,
            import_path4.default.join(entryPath, outputDirectory, "server", file)
          );
        })
      );
      (0, import_build_utils2.debug)("Using instrumentation.js.nft.json trace from build");
    }
    (0, import_build_utils2.debug)("collecting initial Next.js server files");
    await Promise.all(
      initialFileList.map(
        collectTracedFiles(
          baseDir,
          lstatResults,
          lstatSema,
          initialFileReasons,
          initialTracedFiles
        )
      )
    );
    (0, import_build_utils2.debug)("creating initial pseudo layer");
    const initialPseudoLayer = await createPseudoLayer(initialTracedFiles);
    console.timeEnd(initialTracingLabel);
    const lambdaCreationLabel = "Created all serverless functions in";
    console.time(lambdaCreationLabel);
    const apiPages = [];
    const nonApiPages = [];
    const appRouterPages = [];
    const appRouteHandlers = [];
    lambdaPageKeys.forEach((page) => {
      if (internalPages.includes(page) && page !== "404.js" && !(page === "_error.js" && !(static404Page || lambdaPages["404.js"]))) {
        return;
      }
      const pathname = page.replace(/\.js$/, "");
      if (nonLambdaSsgPages.has(pathname)) {
        return;
      }
      const normalizedPathname = normalizePage(pathname);
      if (isDynamicRoute(normalizedPathname)) {
        dynamicPages.push(normalizedPathname);
      }
      if (lambdaAppPaths[page]) {
        if (lambdaAppPaths[page].fsPath.endsWith("route.js")) {
          appRouteHandlers.push(page);
        } else {
          appRouterPages.push(page);
        }
      } else if (pageMatchesApi(page)) {
        apiPages.push(page);
      } else {
        nonApiPages.push(page);
      }
    });
    const requiredFiles = {};
    requiredFiles[import_path4.default.relative(baseDir, nextServerFile)] = new import_build_utils2.FileFsRef({
      mode: (await import_fs_extra5.default.lstat(nextServerFile)).mode,
      fsPath: nextServerFile
    });
    if (static404Page) {
      if (i18n) {
        for (const locale of i18n.locales) {
          let static404File = staticPages[import_path4.default.posix.join(entryDirectory, locale, "/404")];
          if (!static404File) {
            static404File = new import_build_utils2.FileFsRef({
              fsPath: import_path4.default.join(pagesDir, locale, "/404.html")
            });
            if (!import_fs_extra5.default.existsSync(static404File.fsPath)) {
              static404File = new import_build_utils2.FileFsRef({
                fsPath: import_path4.default.join(pagesDir, "/404.html")
              });
            }
          }
          requiredFiles[import_path4.default.relative(baseDir, static404File.fsPath)] = static404File;
        }
      } else {
        const static404File = staticPages[static404Page] || new import_build_utils2.FileFsRef({
          fsPath: import_path4.default.join(pagesDir, "/404.html")
        });
        requiredFiles[import_path4.default.relative(baseDir, static404File.fsPath)] = static404File;
      }
    }
    const envFiles = [];
    for (const file of await import_fs_extra5.default.readdir(workPath)) {
      const isEnv = file === ".env" || file.startsWith(".env.");
      if (isEnv) {
        const statResult = await import_fs_extra5.default.lstat(import_path4.default.join(workPath, file));
        if (statResult.isFile()) {
          envFiles.push(file);
        }
      }
    }
    for (const envFile of envFiles) {
      requiredFiles[import_path4.default.join(import_path4.default.relative(baseDir, entryPath), envFile)] = new import_build_utils2.FileFsRef({
        fsPath: import_path4.default.join(workPath, envFile)
      });
    }
    await Promise.all(
      requiredServerFilesManifest.files.map(async (file) => {
        await lstatSema.acquire();
        let fsPath = import_path4.default.join(
          entryPath,
          // remove last part of outputDirectory `.next` since this is already
          // included in the file path
          import_path4.default.join(outputDirectory, ".."),
          file
        );
        if (projectDir) {
          fsPath = import_path4.default.join(projectDir, file);
        }
        const relativePath = import_path4.default.relative(baseDir, fsPath);
        const { mode } = await import_fs_extra5.default.lstat(fsPath);
        lstatSema.release();
        requiredFiles[relativePath] = new import_build_utils2.FileFsRef({
          mode,
          fsPath
        });
      })
    );
    const requiredFilesLayer = await createPseudoLayer(requiredFiles);
    Object.assign(
      initialPseudoLayer.pseudoLayer,
      requiredFilesLayer.pseudoLayer
    );
    initialPseudoLayer.pseudoLayerBytes += requiredFilesLayer.pseudoLayerBytes;
    const uncompressedInitialSize = Object.keys(
      initialPseudoLayer.pseudoLayer
    ).reduce((prev, cur) => {
      const file = initialPseudoLayer.pseudoLayer[cur];
      return prev + file.uncompressedSize || 0;
    }, 0);
    (0, import_build_utils2.debug)(
      JSON.stringify(
        {
          uncompressedInitialSize,
          compressedInitialSize: initialPseudoLayer.pseudoLayerBytes
        },
        null,
        2
      )
    );
    if (initialPseudoLayer.pseudoLayerBytes > lambdaCompressedByteLimit || uncompressedInitialSize > MAX_UNCOMPRESSED_LAMBDA_SIZE) {
      console.log(
        `Warning: Max serverless function size of ${(0, import_pretty_bytes3.default)(
          lambdaCompressedByteLimit
        )} compressed or ${(0, import_pretty_bytes3.default)(
          MAX_UNCOMPRESSED_LAMBDA_SIZE
        )} uncompressed reached`
      );
      outputFunctionFileSizeInfo(
        [],
        initialPseudoLayer.pseudoLayer,
        initialPseudoLayer.pseudoLayerBytes,
        uncompressedInitialSize,
        {}
      );
      throw new import_build_utils2.NowBuildError({
        message: `Required files read using Node.js fs library and node_modules exceed max lambda size of ${lambdaCompressedByteLimit} bytes`,
        code: "NEXT_REQUIRED_FILES_LIMIT",
        link: "https://vercel.com/docs/platform/limits#serverless-function-size"
      });
    }
    const launcherData = await import_fs_extra5.default.readFile(
      import_path4.default.join(__dirname, "server-launcher.js"),
      "utf8"
    );
    let launcher = launcherData.replace(
      "const conf = __NEXT_CONFIG__",
      `const conf = ${JSON.stringify({
        ...requiredServerFilesManifest.config,
        distDir: import_path4.default.relative(
          projectDir,
          import_path4.default.join(entryPath, outputDirectory)
        ),
        compress: false
      })}`
    ).replace(
      "__NEXT_SERVER_PATH__",
      useBundledServer ? BUNDLED_SERVER_NEXT_PATH : `${getNextServerPath(nextVersion)}/next-server.js`
    );
    const appLauncher = launcher.replace(
      "// @preserve pre-next-server-target",
      `process.env.__NEXT_PRIVATE_PREBUNDLED_REACT = "${requiredServerFilesManifest.config?.experimental?.serverActions ? "experimental" : "next"}"`
    );
    if (entryDirectory !== "." && import_path4.default.posix.join("/", entryDirectory) !== routesManifest.basePath) {
      launcher = launcher.replace(
        "// @preserve entryDirectory handler",
        `req.url = req.url.replace(/^${import_path4.default.posix.join("/", entryDirectory).replace(/\//g, "\\/")}/, '')`
      );
    }
    const pageTraces = {};
    const compressedPages = {};
    const mergedPageKeys = [
      ...nonApiPages,
      ...appRouterPages,
      ...appRouteHandlers,
      ...apiPages,
      ...internalPages
    ];
    const traceCache = {};
    const getOriginalPagePath = (page) => {
      let originalPagePath = page;
      if (appDir && lambdaAppPaths[page]) {
        const { fsPath } = lambdaAppPaths[page];
        originalPagePath = import_path4.default.relative(appDir, fsPath);
      }
      return originalPagePath;
    };
    const getBuildTraceFile = (page) => {
      return pageBuildTraces[page + ".nft.json"] || appBuildTraces[page + ".nft.json"];
    };
    const pathsToTrace = mergedPageKeys.map((page) => {
      if (!getBuildTraceFile(page)) {
        return lambdaPages[page].fsPath;
      }
    }).filter(Boolean);
    let traceResult;
    let parentFilesMap;
    if (pathsToTrace.length > 0) {
      traceResult = await (0, import_nft.nodeFileTrace)(pathsToTrace, {
        base: baseDir,
        cache: traceCache,
        processCwd: projectDir
      });
      traceResult.esmFileList.forEach((file) => traceResult?.fileList.add(file));
      parentFilesMap = getFilesMapFromReasons(
        traceResult.fileList,
        traceResult.reasons
      );
    }
    for (const page of mergedPageKeys) {
      const tracedFiles = {};
      const originalPagePath = getOriginalPagePath(page);
      const pageBuildTrace = getBuildTraceFile(originalPagePath);
      let fileList;
      let reasons;
      if (pageBuildTrace) {
        const { files } = JSON.parse(
          await import_fs_extra5.default.readFile(pageBuildTrace.fsPath, "utf8")
        );
        const isAppPath = appDir && lambdaAppPaths[page];
        const serverComponentFile = isAppPath ? pageBuildTrace.fsPath.replace(
          /\.js\.nft\.json$/,
          ".__sc_client__.js"
        ) : null;
        if (serverComponentFile && await import_fs_extra5.default.pathExists(serverComponentFile)) {
          files.push(
            import_path4.default.relative(
              import_path4.default.dirname(pageBuildTrace.fsPath),
              serverComponentFile
            )
          );
          try {
            const scTrace = JSON.parse(
              await import_fs_extra5.default.readFile(`${serverComponentFile}.nft.json`, "utf8")
            );
            scTrace.files.forEach((file) => files.push(file));
          } catch (err) {
          }
        }
        fileList = [];
        const curPagesDir = isAppPath && appDir ? appDir : pagesDir;
        const pageDir = import_path4.default.dirname(import_path4.default.join(curPagesDir, originalPagePath));
        const normalizedBaseDir = `${baseDir}${baseDir.endsWith(import_path4.default.sep) ? "" : import_path4.default.sep}`;
        files.forEach((file) => {
          const absolutePath = import_path4.default.join(pageDir, file);
          if (absolutePath.startsWith(normalizedBaseDir)) {
            fileList.push(import_path4.default.relative(baseDir, absolutePath));
          }
        });
        reasons = /* @__PURE__ */ new Map();
      } else {
        fileList = Array.from(
          parentFilesMap?.get(
            import_path4.default.relative(baseDir, lambdaPages[page].fsPath)
          ) || []
        );
        if (!fileList) {
          throw new Error(
            `Invariant: Failed to trace ${page}, missing fileList`
          );
        }
        reasons = traceResult?.reasons || /* @__PURE__ */ new Map();
      }
      await Promise.all(
        fileList.map(
          collectTracedFiles(
            baseDir,
            lstatResults,
            lstatSema,
            reasons,
            tracedFiles
          )
        )
      );
      pageTraces[page] = tracedFiles;
      compressedPages[page] = (await createPseudoLayer({
        [page]: lambdaPages[page]
      })).pseudoLayer[page];
    }
    const tracedPseudoLayer = await createPseudoLayer(
      mergedPageKeys.reduce((prev, page) => {
        Object.assign(prev, pageTraces[page]);
        return prev;
      }, {})
    );
    const pageExtensions = requiredServerFilesManifest.config?.pageExtensions;
    const pageLambdaGroups = await getPageLambdaGroups({
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: nonApiPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      lambdaCompressedByteLimit,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions
    });
    for (const group of pageLambdaGroups) {
      group.isPages = true;
    }
    const appRouterLambdaGroups = await getPageLambdaGroups({
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: appRouterPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      lambdaCompressedByteLimit,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions,
      inversedAppPathManifest
    });
    const appRouteHandlersLambdaGroups = await getPageLambdaGroups({
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: appRouteHandlers,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      lambdaCompressedByteLimit,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      internalPages,
      pageExtensions,
      inversedAppPathManifest
    });
    for (const group of appRouterLambdaGroups) {
      if (!group.isPrerenders || group.isExperimentalPPR) {
        group.isStreaming = true;
      }
      group.isAppRouter = true;
    }
    for (const group of appRouteHandlersLambdaGroups) {
      if (!group.isPrerenders) {
        group.isStreaming = true;
      }
      group.isAppRouter = true;
      group.isAppRouteHandler = true;
    }
    const apiLambdaGroups = await getPageLambdaGroups({
      entryPath: projectDir,
      config,
      functionsConfigManifest,
      pages: apiPages,
      prerenderRoutes,
      pageTraces,
      compressedPages,
      experimentalPPRRoutes: void 0,
      tracedPseudoLayer: tracedPseudoLayer.pseudoLayer,
      initialPseudoLayer,
      initialPseudoLayerUncompressed: uncompressedInitialSize,
      lambdaCompressedByteLimit,
      internalPages,
      pageExtensions
    });
    for (const group of apiLambdaGroups) {
      group.isApiLambda = true;
    }
    (0, import_build_utils2.debug)(
      JSON.stringify(
        {
          apiLambdaGroups: apiLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          pageLambdaGroups: pageLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          appRouterLambdaGroups: appRouterLambdaGroups.map((group) => ({
            pages: group.pages,
            isPrerender: group.isPrerenders,
            pseudoLayerBytes: group.pseudoLayerBytes,
            uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
          })),
          appRouteHandlersLambdaGroups: appRouteHandlersLambdaGroups.map(
            (group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              pseudoLayerBytes: group.pseudoLayerBytes,
              uncompressedLayerBytes: group.pseudoLayerUncompressedBytes
            })
          ),
          nextServerLayerSize: initialPseudoLayer.pseudoLayerBytes
        },
        null,
        2
      )
    );
    const combinedGroups = [
      ...pageLambdaGroups,
      ...appRouterLambdaGroups,
      ...apiLambdaGroups,
      ...appRouteHandlersLambdaGroups
    ];
    await detectLambdaLimitExceeding(
      combinedGroups,
      lambdaCompressedByteLimit,
      compressedPages
    );
    for (const group of combinedGroups) {
      const groupPageFiles = {};
      for (const page of [...group.pages, ...internalPages]) {
        const pageFileName = import_path4.default.normalize(
          import_path4.default.relative(baseDir, lambdaPages[page].fsPath)
        );
        groupPageFiles[pageFileName] = compressedPages[page];
      }
      const updatedManifestFiles = {};
      if (isCorrectManifests) {
        for (const manifest of [
          "routes-manifest.json",
          "server/pages-manifest.json"
        ]) {
          const fsPath = import_path4.default.join(entryPath, outputDirectory, manifest);
          const relativePath = import_path4.default.relative(baseDir, fsPath);
          delete group.pseudoLayer[relativePath];
          const manifestData = await import_fs_extra5.default.readJSON(fsPath);
          const normalizedPages = new Set(
            group.pages.map((page) => {
              page = `/${page.replace(/\.js$/, "")}`;
              if (page === "/index")
                page = "/";
              return page;
            })
          );
          switch (manifest) {
            case "routes-manifest.json": {
              const filterItem = (item) => normalizedPages.has(item.page);
              manifestData.dynamicRoutes = manifestData.dynamicRoutes?.filter(filterItem);
              manifestData.staticRoutes = manifestData.staticRoutes?.filter(filterItem);
              break;
            }
            case "server/pages-manifest.json": {
              for (const key of Object.keys(manifestData)) {
                if (isDynamicRoute(key) && !normalizedPages.has(key)) {
                  delete manifestData[key];
                }
              }
              break;
            }
            default: {
              throw new import_build_utils2.NowBuildError({
                message: `Unexpected manifest value ${manifest}, please contact support if this continues`,
                code: "NEXT_MANIFEST_INVARIANT"
              });
            }
          }
          updatedManifestFiles[relativePath] = new import_build_utils2.FileBlob({
            contentType: "application/json",
            data: JSON.stringify(manifestData)
          });
        }
      }
      let launcherData2 = group.isAppRouter ? appLauncher : launcher;
      let preloadChunks = [];
      if (process.env.VERCEL_NEXT_PRELOAD_COMMON === "1") {
        const nextPackageDir = import_path4.default.dirname(
          (0, import_resolve_from.default)(projectDir, "next/package.json")
        );
        if (group.isPages) {
          preloadChunks = PRELOAD_CHUNKS.PAGES_ROUTER_PAGES;
        } else if (group.isApiLambda) {
          preloadChunks = PRELOAD_CHUNKS.PAGES_ROUTER_API;
        } else if (group.isAppRouter && !group.isAppRouteHandler) {
          preloadChunks = PRELOAD_CHUNKS.APP_ROUTER_PAGES;
        } else if (group.isAppRouteHandler) {
          preloadChunks = PRELOAD_CHUNKS.APP_ROUTER_HANDLER;
        }
        const normalizedPreloadChunks = [];
        for (const preloadChunk of preloadChunks) {
          const absoluteChunk = preloadChunk.startsWith(".next") ? import_path4.default.join(projectDir, preloadChunk) : import_path4.default.join(nextPackageDir, "..", preloadChunk);
          if (group.pseudoLayer[import_path4.default.join(".", import_path4.default.relative(baseDir, absoluteChunk))]) {
            normalizedPreloadChunks.push(
              // relative files need to be prefixed with ./ for require
              preloadChunk.startsWith(".next") ? `./${preloadChunk}` : preloadChunk
            );
          }
        }
        if (normalizedPreloadChunks.length > 0) {
          launcherData2 = launcherData2.replace(
            "// @preserve next-server-preload-target",
            normalizedPreloadChunks.map((name) => `require('${name}');`).join("\n")
          );
        }
      }
      const launcherFiles = {
        [import_path4.default.join(import_path4.default.relative(baseDir, projectDir), "___next_launcher.cjs")]: new import_build_utils2.FileBlob({ data: launcherData2 })
      };
      const operationType = getOperationType({ group, prerenderManifest });
      const options = {
        files: {
          ...launcherFiles,
          ...updatedManifestFiles
        },
        layers: [group.pseudoLayer, groupPageFiles],
        handler: import_path4.default.join(
          import_path4.default.relative(baseDir, projectDir),
          "___next_launcher.cjs"
        ),
        operationType,
        memory: group.memory,
        runtime: nodeVersion.runtime,
        maxDuration: group.maxDuration,
        isStreaming: group.isStreaming,
        nextVersion
      };
      const lambda = await createLambdaFromPseudoLayers(options);
      const isPPR = experimental.ppr && group.isAppRouter && !group.isAppRouteHandler;
      let revalidate;
      if (isPPR) {
        if (isPPR && !options.isStreaming) {
          throw new Error("Invariant: PPR lambda isn't streaming");
        }
        revalidate = await createLambdaFromPseudoLayers({
          ...options,
          isStreaming: false
        });
      }
      for (const page of group.pages) {
        const pageNoExt = page.replace(/\.js$/, "");
        let isPrerender = prerenderRoutes.has(
          import_path4.default.join("/", pageNoExt === "index" ? "" : pageNoExt)
        );
        if (!isPrerender && routesManifest?.i18n) {
          isPrerender = routesManifest.i18n.locales.some((locale) => {
            return prerenderRoutes.has(
              import_path4.default.join("/", locale, pageNoExt === "index" ? "" : pageNoExt)
            );
          });
        }
        let outputName = import_path4.default.posix.join(entryDirectory, pageNoExt);
        if (!group.isAppRouter && !group.isAppRouteHandler) {
          outputName = normalizeIndexOutput(outputName, true);
        }
        if (isPPR) {
          if (!revalidate) {
            throw new Error("Invariant: PPR lambda isn't set");
          }
          outputName = import_path4.default.posix.join(entryDirectory, pageNoExt);
          lambdas[outputName] = revalidate;
          const pprOutputName = import_path4.default.posix.join(
            entryDirectory,
            "/_next/postponed/resume",
            pageNoExt
          );
          lambdas[pprOutputName] = lambda;
          experimentalStreamingLambdaPaths.set(outputName, pprOutputName);
          continue;
        }
        if (i18n && !isPrerender && !group.isAppRouter && (!isCorrectLocaleAPIRoutes || !(pageNoExt === "api" || pageNoExt.startsWith("api/")))) {
          for (const locale of i18n.locales) {
            lambdas[normalizeIndexOutput(
              import_path4.default.posix.join(
                entryDirectory,
                locale,
                pageNoExt === "index" ? "" : pageNoExt
              ),
              true
            )] = lambda;
          }
        } else {
          lambdas[outputName] = lambda;
        }
      }
    }
    console.timeEnd(lambdaCreationLabel);
  }
  const prerenderRoute = onPrerenderRoute({
    appDir,
    pagesDir,
    pageLambdaMap: {},
    lambdas,
    experimentalStreamingLambdaPaths,
    prerenders,
    entryDirectory,
    routesManifest,
    prerenderManifest,
    appPathRoutesManifest,
    isServerMode: true,
    isSharedLambdas: false,
    canUsePreviewMode,
    static404Page,
    localePrefixed404,
    hasPages404: routesManifest.pages404,
    isCorrectNotFoundRoutes,
    isEmptyAllowQueryForPrendered
  });
  await Promise.all(
    Object.keys(prerenderManifest.staticRoutes).map(
      (route) => prerenderRoute(route, {})
    )
  );
  await Promise.all(
    Object.keys(prerenderManifest.fallbackRoutes).map(
      (route) => prerenderRoute(route, { isFallback: true })
    )
  );
  await Promise.all(
    Object.keys(prerenderManifest.blockingFallbackRoutes).map(
      (route) => prerenderRoute(route, { isBlocking: true })
    )
  );
  if (static404Page && canUsePreviewMode) {
    await Promise.all(
      [...omittedPrerenderRoutes].map((route) => {
        return prerenderRoute(route, { isOmitted: true });
      })
    );
  }
  prerenderRoutes.forEach((route) => {
    if (experimentalPPRRoutes.has(route))
      return;
    if (routesManifest?.i18n) {
      route = normalizeLocalePath(route, routesManifest.i18n.locales).pathname;
    }
    delete lambdas[normalizeIndexOutput(
      import_path4.default.posix.join("./", entryDirectory, route === "/" ? "/index" : route),
      true
    )];
  });
  const middleware = await getMiddlewareBundle({
    config,
    entryPath,
    outputDirectory,
    routesManifest,
    isCorrectMiddlewareOrder,
    prerenderBypassToken: prerenderManifest.bypassToken || "",
    nextVersion,
    appPathRoutesManifest: appPathRoutesManifest || {}
  });
  const isNextDataServerResolving = middleware.staticRoutes.length > 0 && import_semver3.default.gte(nextVersion, NEXT_DATA_MIDDLEWARE_RESOLVING_VERSION);
  const dynamicRoutes = await getDynamicRoutes(
    entryPath,
    entryDirectory,
    dynamicPages,
    false,
    routesManifest,
    omittedPrerenderRoutes,
    canUsePreviewMode,
    prerenderManifest.bypassToken || "",
    true,
    middleware.dynamicRouteMap,
    experimental.ppr
  ).then(
    (arr) => localizeDynamicRoutes(
      arr,
      dynamicPrefix,
      entryDirectory,
      staticPages,
      prerenderManifest,
      routesManifest,
      true,
      isCorrectLocaleAPIRoutes,
      inversedAppPathManifest
    )
  );
  const pagesPlaceholderRscEntries = {};
  if (appDir) {
    const pagesManifest = import_path4.default.join(
      entryPath,
      outputDirectory,
      `server/pages-manifest.json`
    );
    const pagesData = await import_fs_extra5.default.readJSON(pagesManifest);
    const pagesEntries = Object.keys(pagesData);
    for (const page of pagesEntries) {
      const pathName = page.startsWith("/") ? page.slice(1) : page;
      pagesPlaceholderRscEntries[`${pathName}.rsc`] = new import_build_utils2.FileBlob({
        data: "{}",
        contentType: "application/json"
      });
    }
  }
  const { staticFiles, publicDirectoryFiles, staticDirectoryFiles } = await getStaticFiles(entryPath, entryDirectory, outputDirectory);
  const normalizeNextDataRoute = (isOverride = false) => {
    return isNextDataServerResolving ? [
      // strip _next/data prefix for resolving
      {
        src: `^${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          escapedBuildId,
          "/(.*).json"
        )}`,
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/$1",
          trailingSlash ? "/" : ""
        )}`,
        ...isOverride ? { override: true } : {},
        continue: true,
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ]
      },
      // normalize "/index" from "/_next/data/index.json" to -> just "/"
      // as matches a rewrite sources will expect just "/"
      {
        src: import_path4.default.posix.join("^/", entryDirectory, "/index(?:/)?"),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: import_path4.default.posix.join(
          "/",
          entryDirectory,
          trailingSlash ? "/" : ""
        ),
        ...isOverride ? { override: true } : {},
        continue: true
      }
    ] : [];
  };
  const denormalizeNextDataRoute = (isOverride = false) => {
    return isNextDataServerResolving ? [
      {
        src: import_path4.default.posix.join(
          "^/",
          entryDirectory !== "." ? `${entryDirectory}${trailingSlash ? "/$" : "$"}` : "$"
        ),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          buildId,
          "/index.json"
        )}`,
        continue: true,
        ...isOverride ? { override: true } : {}
      },
      {
        src: import_path4.default.posix.join(
          "^/",
          entryDirectory,
          "((?!_next/)(?:.*[^/]|.*))/?$"
        ),
        has: [
          {
            type: "header",
            key: "x-nextjs-data"
          }
        ],
        dest: `${import_path4.default.posix.join(
          "/",
          entryDirectory,
          "/_next/data/",
          buildId,
          "/$1.json"
        )}`,
        continue: true,
        ...isOverride ? { override: true } : {}
      }
    ] : [];
  };
  let nextDataCatchallOutput = void 0;
  if (isNextDataServerResolving) {
    const catchallFsPath = import_path4.default.join(
      entryPath,
      outputDirectory,
      "__next_data_catchall.json"
    );
    await import_fs_extra5.default.writeFile(catchallFsPath, "{}");
    nextDataCatchallOutput = new import_build_utils2.FileFsRef({
      contentType: "application/json",
      fsPath: catchallFsPath
    });
  }
  if (appPathRoutesManifest) {
    const edgeFunctions = middleware.edgeFunctions;
    for (const route of Object.values(appPathRoutesManifest)) {
      const ogRoute = inversedAppPathManifest[route];
      if (ogRoute.endsWith("/route")) {
        continue;
      }
      const pathname = import_path4.default.posix.join(
        "./",
        entryDirectory,
        route === "/" ? "/index" : route
      );
      if (lambdas[pathname]) {
        lambdas[`${pathname}.rsc`] = lambdas[pathname];
      }
      if (edgeFunctions[pathname]) {
        edgeFunctions[`${pathname}.rsc`] = edgeFunctions[pathname];
      }
    }
  }
  const rscHeader = routesManifest.rsc?.header?.toLowerCase() || "__rsc__";
  const rscPrefetchHeader = routesManifest.rsc?.prefetchHeader?.toLowerCase();
  const rscVaryHeader = routesManifest?.rsc?.varyHeader || "RSC, Next-Router-State-Tree, Next-Router-Prefetch";
  const appNotFoundPath = import_path4.default.posix.join(".", entryDirectory, "_not-found");
  const flags = variantsManifest ? Object.entries(variantsManifest).map(([key, value]) => ({
    key,
    ...value,
    metadata: value.metadata ?? {}
  })) : [];
  if (experimental.ppr && !rscPrefetchHeader) {
    throw new Error("Invariant: cannot use PPR without 'rsc.prefetchHeader'");
  }
  return {
    wildcard: wildcardConfig,
    images: getImagesConfig(imagesManifest),
    output: {
      ...publicDirectoryFiles,
      ...lambdas,
      ...appRscPrefetches,
      ...pagesPlaceholderRscEntries,
      // Prerenders may override Lambdas -- this is an intentional behavior.
      ...prerenders,
      ...staticPages,
      ...staticFiles,
      ...staticDirectoryFiles,
      ...privateOutputs.files,
      ...middleware.edgeFunctions,
      ...isNextDataServerResolving ? {
        __next_data_catchall: nextDataCatchallOutput
      } : {}
    },
    routes: [
      /*
        Desired routes order
        - Runtime headers
        - User headers and redirects
        - Runtime redirects
        - Runtime routes
        - Check filesystem, if nothing found continue
        - User rewrites
        - Builder rewrites
      */
      // force trailingSlashRedirect to the very top so it doesn't
      // conflict with i18n routes that don't have or don't have the
      // trailing slash
      ...trailingSlashRedirects,
      ...privateOutputs.routes,
      // normalize _next/data URL before processing redirects
      ...normalizeNextDataRoute(true),
      ...i18n ? [
        // Handle auto-adding current default locale to path based on
        // $wildcard
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path4.default.posix.join("/", entryDirectory) : ""}$wildcard/$1`,
          continue: true
        },
        // Handle redirecting to locale specific domains
        ...i18n.domains && i18n.domains.length > 0 && i18n.localeDetection !== false ? [
          {
            src: `^${import_path4.default.posix.join(
              "/",
              entryDirectory
            )}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?/?$`,
            locale: {
              redirect: i18n.domains.reduce(
                (prev, item) => {
                  prev[item.defaultLocale] = `http${item.http ? "" : "s"}://${item.domain}/`;
                  if (item.locales) {
                    item.locales.map((locale) => {
                      prev[locale] = `http${item.http ? "" : "s"}://${item.domain}/${locale}`;
                    });
                  }
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // Handle redirecting to locale paths
        ...i18n.localeDetection !== false ? [
          {
            // TODO: if default locale is included in this src it won't
            // be visitable by users who prefer another language since a
            // cookie isn't set signaling the default locale is
            // preferred on redirect currently, investigate adding this
            src: "/",
            locale: {
              redirect: i18n.locales.reduce(
                (prev, locale) => {
                  prev[locale] = locale === i18n.defaultLocale ? `/` : `/${locale}`;
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory)}$`,
          dest: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            i18n.defaultLocale
          )}`,
          continue: true
        },
        // Auto-prefix non-locale path with default locale
        // note for prerendered pages this will cause
        // x-now-route-matches to contain the path minus the locale
        // e.g. for /de/posts/[slug] x-now-route-matches would have
        // 1=posts%2Fpost-1
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          dest: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            i18n.defaultLocale
          )}/$1`,
          continue: true
        }
      ] : [],
      ...headers,
      ...redirects,
      // middleware comes directly after redirects but before
      // beforeFiles rewrites as middleware is not a "file" route
      ...routesManifest?.skipMiddlewareUrlNormalize ? denormalizeNextDataRoute(true) : [],
      ...isCorrectMiddlewareOrder ? middleware.staticRoutes : [],
      ...routesManifest?.skipMiddlewareUrlNormalize ? normalizeNextDataRoute(true) : [],
      ...beforeFilesRewrites,
      // Make sure to 404 for the /404 path itself
      ...i18n ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?[/]?404/?`,
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true,
          missing: [
            {
              type: "header",
              key: "x-prerender-revalidate"
            }
          ]
        }
      ],
      // Make sure to 500 when visiting /500 directly for static 500
      ...!hasStatic500 ? [] : i18n ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})?[/]?500`,
          status: 500,
          continue: true
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "500"),
          status: 500,
          continue: true
        }
      ],
      // we need to undo _next/data normalize before checking filesystem
      ...denormalizeNextDataRoute(true),
      // while middleware was in beta the order came right before
      // handle: 'filesystem' we maintain this for older versions
      // to prevent a local/deploy mismatch
      ...!isCorrectMiddlewareOrder ? middleware.staticRoutes : [],
      ...appDir ? [
        ...rscPrefetchHeader ? [
          {
            src: `^${import_path4.default.posix.join("/", entryDirectory, "/")}`,
            has: [
              {
                type: "header",
                key: rscPrefetchHeader
              }
            ],
            dest: import_path4.default.posix.join(
              "/",
              entryDirectory,
              `/__index${RSC_PREFETCH_SUFFIX}`
            ),
            headers: { vary: rscVaryHeader },
            continue: true,
            override: true
          },
          {
            src: `^${import_path4.default.posix.join(
              "/",
              entryDirectory,
              "/((?!.+\\.rsc).+?)(?:/)?$"
            )}`,
            has: [
              {
                type: "header",
                key: rscPrefetchHeader
              }
            ],
            dest: import_path4.default.posix.join(
              "/",
              entryDirectory,
              `/$1${RSC_PREFETCH_SUFFIX}`
            ),
            headers: { vary: rscVaryHeader },
            continue: true,
            override: true
          }
        ] : [],
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory, "/")}`,
          has: [
            {
              type: "header",
              key: rscHeader
            }
          ],
          dest: import_path4.default.posix.join("/", entryDirectory, "/index.rsc"),
          headers: { vary: rscVaryHeader },
          continue: true,
          override: true
        },
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/((?!.+\\.rsc).+?)(?:/)?$"
          )}`,
          has: [
            {
              type: "header",
              key: rscHeader
            }
          ],
          dest: import_path4.default.posix.join("/", entryDirectory, "/$1.rsc"),
          headers: { vary: rscVaryHeader },
          continue: true,
          override: true
        }
      ] : [],
      // Next.js page lambdas, `static/` folder, reserved assets, and `public/`
      // folder
      { handle: "filesystem" },
      // ensure the basePath prefixed _next/image is rewritten to the root
      // _next/image path
      ...routesManifest?.basePath ? [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/image/?"),
          dest: "/_next/image",
          check: true
        }
      ] : [],
      // normalize _next/data URL before processing rewrites
      ...normalizeNextDataRoute(),
      ...!isNextDataServerResolving ? [
        // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
        // if no match to prevent rewriting _next/data unexpectedly
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path4.default.posix.join("/", entryDirectory, "_next/data/$1"),
          check: true
        }
      ] : [],
      ...rscPrefetchHeader && !experimental.ppr ? [
        {
          src: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/__index${RSC_PREFETCH_SUFFIX}`
          ),
          dest: import_path4.default.posix.join("/", entryDirectory, "/index.rsc"),
          has: [
            {
              type: "header",
              key: rscPrefetchHeader
            }
          ],
          continue: true,
          override: true
        },
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/(.+?)${RSC_PREFETCH_SUFFIX}(?:/)?$`
          )}`,
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/$1${experimental.ppr ? RSC_PREFETCH_SUFFIX : ".rsc"}`
          ),
          has: [
            {
              type: "header",
              key: rscPrefetchHeader
            }
          ],
          continue: true,
          override: true
        }
      ] : [],
      // These need to come before handle: miss or else they are grouped
      // with that routing section
      ...afterFilesRewrites,
      // ensure non-normalized /.rsc from rewrites is handled
      ...appPathRoutesManifest ? [
        {
          src: import_path4.default.posix.join("/", entryDirectory, "/\\.prefetch\\.rsc$"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/__index${RSC_PREFETCH_SUFFIX}`
          ),
          check: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, "/\\.rsc$"),
          dest: import_path4.default.posix.join("/", entryDirectory, `/index.rsc`),
          check: true
        }
      ] : [],
      { handle: "resource" },
      ...fallbackRewrites,
      // make sure 404 page is used when a directory is matched without
      // an index page
      { src: import_path4.default.posix.join("/", entryDirectory, ".*"), status: 404 },
      { handle: "miss" },
      // We need to make sure to 404 for /_next after handle: miss since
      // handle: miss is called before rewrites and to prevent rewriting /_next
      {
        src: import_path4.default.posix.join(
          "/",
          entryDirectory,
          "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
        ),
        status: 404,
        check: true,
        dest: "$0"
      },
      // remove locale prefixes to check public files and
      // to allow checking non-prefixed lambda outputs
      ...i18n ? [
        {
          src: import_path4.default.posix.join(
            "/",
            entryDirectory,
            (0, import_escape_string_regexp2.default)(i18n.defaultLocale)
          ),
          dest: "/",
          check: true
        },
        {
          src: `^${import_path4.default.posix.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})/(.*)`,
          dest: `${import_path4.default.posix.join("/", entryDirectory, "/")}$1`,
          check: true
        }
      ] : [],
      // routes that are called after each rewrite or after routes
      // if there no rewrites
      { handle: "rewrite" },
      // re-build /_next/data URL after resolving
      ...denormalizeNextDataRoute(),
      ...isNextDataServerResolving ? dataRoutes.filter((route) => {
        const { pathname } = new URL(route.dest || "/", "http://n");
        return !isDynamicRoute(pathname.replace(/\.json$/, ""));
      }) : [],
      // /_next/data routes for getServerProps/getStaticProps pages
      ...isNextDataServerResolving ? (
        // when resolving data routes for middleware we need to include
        // all dynamic routes including non-SSG/SSP so that the priority
        // is correct
        dynamicRoutes.filter((route) => !route.src.includes(".rsc")).map((route) => {
          route = Object.assign({}, route);
          let normalizedSrc = route.src;
          if (routesManifest.basePath) {
            normalizedSrc = normalizedSrc.replace(
              new RegExp(
                `\\^${(0, import_escape_string_regexp2.default)(routesManifest.basePath)}`
              ),
              "^"
            );
          }
          route.src = import_path4.default.posix.join(
            "^/",
            entryDirectory,
            "_next/data/",
            escapedBuildId,
            normalizedSrc.replace(/\^\(\?:\/\(\?</, "(?:(?<").replace(/(^\^|\$$)/g, "") + ".json$"
          );
          const parsedDestination = new URL(route.dest || "/", "http://n");
          let pathname = parsedDestination.pathname;
          const search = parsedDestination.search;
          let isPrerender = !!prerenders[import_path4.default.join("./", pathname)];
          if (routesManifest.i18n) {
            for (const locale of routesManifest.i18n?.locales || []) {
              const prerenderPathname = pathname.replace(
                /^\/\$nextLocale/,
                `/${locale}`
              );
              if (prerenders[import_path4.default.join("./", prerenderPathname)]) {
                isPrerender = true;
                break;
              }
            }
          }
          if (isPrerender) {
            if (routesManifest.basePath) {
              pathname = pathname.replace(
                new RegExp(
                  `^${(0, import_escape_string_regexp2.default)(routesManifest.basePath)}`
                ),
                ""
              );
            }
            route.dest = `${routesManifest.basePath || ""}/_next/data/${buildId}${pathname}.json${search || ""}`;
          }
          return route;
        }).filter(Boolean)
      ) : dataRoutes,
      ...!isNextDataServerResolving ? [
        // ensure we 404 for non-existent _next/data routes before
        // trying page dynamic routes
        {
          src: import_path4.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path4.default.posix.join("/", entryDirectory, "404"),
          status: 404
        }
      ] : [],
      // Dynamic routes (must come after dataRoutes as dataRoutes are more
      // specific)
      ...dynamicRoutes,
      ...isNextDataServerResolving ? [
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          headers: {
            "x-nextjs-matched-path": "/$1"
          },
          continue: true,
          override: true
        },
        // add a catch-all data route so we don't 404 when getting
        // middleware effects
        {
          src: `^${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/_next/data/",
            escapedBuildId,
            "/(.*).json"
          )}`,
          dest: "__next_data_catchall"
        }
      ] : [],
      // routes to call after a file has been matched
      { handle: "hit" },
      // Before we handle static files we need to set proper caching headers
      {
        // This ensures we only match known emitted-by-Next.js files and not
        // user-emitted files which may be missing a hash in their filename.
        src: import_path4.default.posix.join(
          "/",
          entryDirectory,
          `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
        ),
        // Next.js assets contain a hash or entropy in their filenames, so they
        // are guaranteed to be unique and cacheable indefinitely.
        headers: {
          "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
        },
        continue: true,
        important: true
      },
      {
        src: import_path4.default.posix.join("/", entryDirectory, "/index"),
        headers: {
          "x-matched-path": "/"
        },
        continue: true,
        important: true
      },
      {
        src: import_path4.default.posix.join("/", entryDirectory, `/((?!index$).*)`),
        headers: {
          "x-matched-path": "/$1"
        },
        continue: true,
        important: true
      },
      // error handling
      { handle: "error" },
      // Custom Next.js 404 page
      ...i18n && (static404Page || hasIsr404Page || lambdaPages["404.js"]) ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(/.*|$)`,
          dest: import_path4.default.posix.join("/", entryDirectory, "/$nextLocale/404"),
          status: 404,
          caseSensitive: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/${i18n.defaultLocale}/404`
          ),
          status: 404
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            static404Page || hasIsr404Page || lambdas[import_path4.default.posix.join(entryDirectory, "404")] ? "/404" : appPathRoutesManifest && (middleware.edgeFunctions[appNotFoundPath] || lambdas[appNotFoundPath]) ? "/_not-found" : "/_error"
          ),
          status: 404
        }
      ],
      // custom 500 page if present
      ...i18n && (hasStatic500 || hasIsr500Page || lambdaPages["500.js"]) ? [
        {
          src: `${import_path4.default.posix.join(
            "/",
            entryDirectory,
            "/"
          )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp2.default)(locale)).join("|")})(/.*|$)`,
          dest: import_path4.default.posix.join("/", entryDirectory, "/$nextLocale/500"),
          status: 500,
          caseSensitive: true
        },
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            `/${i18n.defaultLocale}/500`
          ),
          status: 500
        }
      ] : [
        {
          src: import_path4.default.posix.join("/", entryDirectory, ".*"),
          dest: import_path4.default.posix.join(
            "/",
            entryDirectory,
            hasStatic500 || hasIsr500Page || lambdas[import_path4.default.posix.join(entryDirectory, "500")] ? "/500" : "/_error"
          ),
          status: 500
        }
      ]
    ],
    framework: { version: nextVersion },
    flags
  };
}

// src/index.ts
var version = 2;
var htmlContentType = "text/html; charset=utf-8";
var SERVER_BUILD_MINIMUM_NEXT_VERSION = "v10.0.9-canary.4";
var BEFORE_FILES_CONTINUE_NEXT_VERSION = "v10.2.3-canary.1";
var REDIRECTS_NO_STATIC_NEXT_VERSION = "v11.0.2-canary.15";
var MAX_AGE_ONE_YEAR = 31536e3;
async function readPackageJson(entryPath) {
  const packagePath = import_path5.default.join(entryPath, "package.json");
  try {
    return JSON.parse(await (0, import_fs_extra6.readFile)(packagePath, "utf8"));
  } catch (err) {
    (0, import_build_utils3.debug)("package.json not found in entry");
    return {};
  }
}
async function writePackageJson(workPath, packageJson) {
  await (0, import_fs_extra6.writeFile)(
    import_path5.default.join(workPath, "package.json"),
    JSON.stringify(packageJson, null, 2)
  );
}
async function writeNpmRc(workPath, token) {
  await (0, import_fs_extra6.writeFile)(
    import_path5.default.join(workPath, ".npmrc"),
    `//registry.npmjs.org/:_authToken=${token}`
  );
}
function getRealNextVersion(entryPath) {
  try {
    const resolved = require_.resolve("next/package.json", {
      paths: [entryPath]
    });
    const nextVersion = require_(resolved).version;
    console.log(`Detected Next.js version: ${nextVersion}`);
    return nextVersion;
  } catch (_ignored) {
    console.log(
      `Warning: Could not identify Next.js version, ensure it is defined as a project dependency.`
    );
    return false;
  }
}
async function getNextVersionRange(entryPath) {
  let nextVersion = false;
  const pkg = await readPackageJson(entryPath);
  if (pkg.dependencies && pkg.dependencies.next) {
    nextVersion = pkg.dependencies.next;
  } else if (pkg.devDependencies && pkg.devDependencies.next) {
    nextVersion = pkg.devDependencies.next;
  }
  return nextVersion;
}
function isLegacyNext(nextVersion) {
  if (nextVersion === "canary" || nextVersion === "latest") {
    return false;
  }
  if (legacy_versions_default.indexOf(nextVersion) !== -1) {
    return true;
  }
  const maxSatisfying = import_semver4.default.maxSatisfying(legacy_versions_default, nextVersion);
  if (maxSatisfying === null) {
    return false;
  }
  return true;
}
var build = async ({
  files,
  workPath,
  repoRootPath,
  entrypoint,
  config = {},
  meta = {}
}) => {
  validateEntrypoint(entrypoint);
  const lambdaCompressedByteLimit = config.maxLambdaSize || 50 * MIB;
  let entryDirectory = import_path5.default.dirname(entrypoint);
  let entryPath = import_path5.default.join(workPath, entryDirectory);
  if (config.rootDirectory) {
    repoRootPath = entryPath;
    entryPath = import_path5.default.join(entryPath, config.rootDirectory);
  }
  const outputDirectory = import_path5.default.join("./", config.outputDirectory || ".next");
  const dotNextStatic = import_path5.default.join(entryPath, outputDirectory, "static");
  const baseDir = repoRootPath || workPath;
  (0, import_build_utils3.debug)(
    JSON.stringify(
      {
        repoRootPath,
        baseDir,
        workPath,
        entryPath,
        entryDirectory,
        outputDirectory
      },
      null,
      2
    )
  );
  const prefixedEnvs = (0, import_build_utils3.getPrefixedEnvVars)({
    envPrefix: "NEXT_PUBLIC_",
    envs: process.env
  });
  for (const [key, value] of Object.entries(prefixedEnvs)) {
    process.env[key] = value;
  }
  await (0, import_build_utils3.download)(files, workPath, meta);
  if (config.rootDirectory) {
    workPath = import_path5.default.join(workPath, config.rootDirectory);
  }
  let pkg = await readPackageJson(entryPath);
  const nextVersionRange = await getNextVersionRange(entryPath);
  const nodeVersion = await (0, import_build_utils3.getNodeVersion)(entryPath, void 0, config, meta);
  const spawnOpts = (0, import_build_utils3.getSpawnOptions)(meta, nodeVersion);
  const { cliType, lockfileVersion } = await (0, import_build_utils3.scanParentDirs)(entryPath);
  spawnOpts.env = (0, import_build_utils3.getEnvForPackageManager)({
    cliType,
    lockfileVersion,
    nodeVersion,
    env: spawnOpts.env || {}
  });
  const nowJsonPath = await (0, import_find_up.default)(["now.json", "vercel.json"], {
    cwd: entryPath
  });
  let hasLegacyRoutes = false;
  const hasFunctionsConfig = Boolean(config.functions);
  if (await (0, import_fs_extra6.pathExists)(dotNextStatic)) {
    console.warn("WARNING: You should not upload the `.next` directory.");
  }
  const isLegacy = nextVersionRange && isLegacyNext(nextVersionRange);
  (0, import_build_utils3.debug)(`MODE: ${isLegacy ? "legacy" : "server(less)"}`);
  if (isLegacy) {
    console.warn(
      "WARNING: your application is being deployed in @vercel/next's legacy mode. http://err.sh/vercel/vercel/now-next-legacy-mode"
    );
    await Promise.all([
      (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, "yarn.lock")),
      (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, "package-lock.json"))
    ]);
    (0, import_build_utils3.debug)("Normalizing package.json");
    pkg = normalizePackageJson(pkg);
    (0, import_build_utils3.debug)("Normalized package.json result: ", pkg);
    await writePackageJson(entryPath, pkg);
  }
  let buildScriptName = (0, import_build_utils3.getScriptName)(pkg, [
    "vercel-build",
    "now-build",
    "build"
  ]);
  const { installCommand, buildCommand } = config;
  if (!buildScriptName && !buildCommand) {
    console.log(
      'Your application is being built using `next build`. If you need to define a different build step, please create a `vercel-build` script in your `package.json` (e.g. `{ "scripts": { "vercel-build": "npm run prepare && next build" } }`).'
    );
    await writePackageJson(entryPath, {
      ...pkg,
      scripts: {
        "vercel-build": "next build",
        ...pkg.scripts
      }
    });
    buildScriptName = "vercel-build";
  }
  if (process.env.NPM_AUTH_TOKEN) {
    (0, import_build_utils3.debug)("Found NPM_AUTH_TOKEN in environment, creating .npmrc");
    await writeNpmRc(entryPath, process.env.NPM_AUTH_TOKEN);
  }
  if (typeof installCommand === "string") {
    if (installCommand.trim()) {
      console.log(`Running "install" command: \`${installCommand}\`...`);
      await (0, import_build_utils3.execCommand)(installCommand, {
        ...spawnOpts,
        cwd: entryPath
      });
    } else {
      console.log(`Skipping "install" command...`);
    }
  } else {
    await (0, import_build_utils3.runNpmInstall)(entryPath, [], spawnOpts, meta, nodeVersion);
  }
  const nextVersion = getRealNextVersion(entryPath);
  if (!nextVersion) {
    throw new import_build_utils3.NowBuildError({
      code: "NEXT_NO_VERSION",
      message: 'No Next.js version could be detected in your project. Make sure `"next"` is installed in "dependencies" or "devDependencies"'
    });
  }
  let isServerMode = !(config.framework === "blitzjs") && import_semver4.default.gte(nextVersion, SERVER_BUILD_MINIMUM_NEXT_VERSION);
  const beforeFilesShouldContinue = import_semver4.default.gte(
    nextVersion,
    BEFORE_FILES_CONTINUE_NEXT_VERSION
  );
  const isCorrectLocaleAPIRoutes = import_semver4.default.gte(nextVersion, "v11.0.2-canary.3");
  if (isServerMode) {
    (0, import_build_utils3.debug)(
      `Application is being built in server mode since ${nextVersion} meets minimum version of ${SERVER_BUILD_MINIMUM_NEXT_VERSION}`
    );
  } else {
    if (nowJsonPath) {
      const nowJsonData = JSON.parse(await (0, import_fs_extra6.readFile)(nowJsonPath, "utf8"));
      if (Array.isArray(nowJsonData.routes) && nowJsonData.routes.length > 0) {
        hasLegacyRoutes = true;
        console.warn(
          `WARNING: your application is being opted out of @vercel/next's optimized lambdas mode due to legacy routes in ${import_path5.default.basename(
            nowJsonPath
          )}. http://err.sh/vercel/vercel/next-legacy-routes-optimized-lambdas`
        );
      }
    }
    if (hasFunctionsConfig) {
      console.warn(
        `WARNING: Your application is being opted out of "@vercel/next" optimized lambdas mode due to \`functions\` config.
More info: http://err.sh/vercel/vercel/next-functions-config-optimized-lambdas`
      );
    }
  }
  const isSharedLambdas = !isServerMode && !hasLegacyRoutes && !hasFunctionsConfig && typeof config.sharedLambdas === "undefined" ? true : !!config.sharedLambdas;
  let target;
  if (isServerMode) {
    target = "server";
  } else if (!isLegacy) {
    target = await createServerlessConfig(workPath, entryPath, nextVersion);
  }
  const env = { ...spawnOpts.env };
  env.NEXT_EDGE_RUNTIME_PROVIDER = "vercel";
  if (target) {
    env.NEXT_PRIVATE_TARGET = target;
  }
  env.NEXT_PRIVATE_OUTPUT_TRACE_ROOT = baseDir;
  if (isServerMode) {
    env.NODE_ENV = "production";
  }
  if (buildCommand) {
    const nodeBinPaths = (0, import_build_utils3.getNodeBinPaths)({
      start: entryPath,
      base: repoRootPath
    });
    const nodeBinPath = nodeBinPaths.join(import_path5.default.delimiter);
    env.PATH = `${nodeBinPath}${import_path5.default.delimiter}${env.PATH}`;
    if (!env.YARN_NODE_LINKER) {
      env.YARN_NODE_LINKER = "node-modules";
    }
    (0, import_build_utils3.debug)(
      `Added "${nodeBinPath}" to PATH env because a build command was used.`
    );
    console.log(`Running "${buildCommand}"`);
    await (0, import_build_utils3.execCommand)(buildCommand, {
      ...spawnOpts,
      cwd: entryPath,
      env
    });
  } else if (buildScriptName) {
    await (0, import_build_utils3.runPackageJsonScript)(entryPath, buildScriptName, {
      ...spawnOpts,
      env
    });
  }
  (0, import_build_utils3.debug)("build command exited");
  let buildOutputVersion;
  try {
    const data = await (0, import_fs_extra6.readJSON)(
      import_path5.default.join(outputDirectory, "output/config.json")
    );
    buildOutputVersion = data.version;
  } catch (_) {
  }
  if (buildOutputVersion) {
    return {
      buildOutputPath: import_path5.default.join(outputDirectory, "output"),
      buildOutputVersion
    };
  }
  let appMountPrefixNoTrailingSlash = import_path5.default.posix.join("/", entryDirectory).replace(/\/+$/, "");
  const requiredServerFilesManifest = isServerMode ? await getRequiredServerFilesManifest(entryPath, outputDirectory) : false;
  isServerMode = Boolean(requiredServerFilesManifest);
  const functionsConfigManifest = await getFunctionsConfigManifest(
    entryPath,
    outputDirectory
  );
  const variantsManifest = await getVariantsManifest(
    entryPath,
    outputDirectory
  );
  const routesManifest = await getRoutesManifest(
    entryPath,
    outputDirectory,
    nextVersion
  );
  const imagesManifest = await getImagesManifest(entryPath, outputDirectory);
  const prerenderManifest = await getPrerenderManifest(
    entryPath,
    outputDirectory
  );
  const omittedPrerenderRoutes = new Set(
    Object.keys(prerenderManifest.omittedRoutes)
  );
  const hasIsr404Page = typeof prerenderManifest.staticRoutes[routesManifest?.i18n ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    import_path5.default.join("/", routesManifest?.i18n.defaultLocale, "/404")
  ) : "/404"]?.initialRevalidate === "number";
  const hasIsr500Page = typeof prerenderManifest.staticRoutes[routesManifest?.i18n ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
    import_path5.default.join("/", routesManifest?.i18n.defaultLocale, "/500")
  ) : "/500"]?.initialRevalidate === "number";
  const wildcardConfig = routesManifest?.i18n?.domains && routesManifest.i18n.domains.length > 0 ? routesManifest.i18n.domains.map((item) => {
    return {
      domain: item.domain,
      value: item.defaultLocale === routesManifest.i18n?.defaultLocale ? "" : `/${item.defaultLocale}`
    };
  }) : void 0;
  const privateOutputs = await getPrivateOutputs(
    import_path5.default.join(entryPath, outputDirectory),
    {
      "next-stats.json": "_next/__private/stats.json",
      trace: "_next/__private/trace"
    }
  );
  const headers = [];
  const beforeFilesRewrites = [];
  const afterFilesRewrites = [];
  const fallbackRewrites = [];
  let redirects = [];
  const dataRoutes = [];
  let dynamicRoutes = [];
  let hasPages404 = false;
  let buildId = "";
  let escapedBuildId = "";
  if (isLegacy || isSharedLambdas || isServerMode) {
    try {
      buildId = await (0, import_fs_extra6.readFile)(
        import_path5.default.join(entryPath, outputDirectory, "BUILD_ID"),
        "utf8"
      );
      escapedBuildId = (0, import_escape_string_regexp3.default)(buildId);
    } catch (err) {
      throw new import_build_utils3.NowBuildError({
        code: "NOW_NEXT_NO_BUILD_ID",
        message: 'The BUILD_ID file was not found in the Output Directory. Did you forget to run "next build" in your Build Command?'
      });
    }
  }
  if (routesManifest) {
    switch (routesManifest.version) {
      case 1:
      case 2:
      case 3:
      case 4: {
        redirects.push(...(0, import_superstatic.convertRedirects)(routesManifest.redirects));
        if (Array.isArray(routesManifest.rewrites)) {
          afterFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(
              routesManifest.rewrites,
              routesManifest.i18n ? ["nextInternalLocale"] : void 0
            )
          );
        } else {
          beforeFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.beforeFiles).map((r) => {
              if ("check" in r) {
                if (beforeFilesShouldContinue) {
                  delete r.check;
                  r.continue = true;
                }
                r.override = true;
              }
              return r;
            })
          );
          afterFilesRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.afterFiles)
          );
          fallbackRewrites.push(
            ...(0, import_superstatic.convertRewrites)(routesManifest.rewrites.fallback)
          );
        }
        if (routesManifest.headers) {
          headers.push(...(0, import_superstatic.convertHeaders)(routesManifest.headers));
        }
        if (import_semver4.default.gte(nextVersion, REDIRECTS_NO_STATIC_NEXT_VERSION)) {
          redirects.forEach(
            (r, i) => updateRouteSrc(r, i, routesManifest.redirects)
          );
          afterFilesRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? routesManifest.rewrites : routesManifest.rewrites.afterFiles
            )
          );
          beforeFilesRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? [] : routesManifest.rewrites.beforeFiles
            )
          );
          fallbackRewrites.forEach(
            (r, i) => updateRouteSrc(
              r,
              i,
              Array.isArray(routesManifest.rewrites) ? [] : routesManifest.rewrites.fallback
            )
          );
          headers.forEach(
            (r, i) => updateRouteSrc(r, i, routesManifest.headers || [])
          );
        }
        if (routesManifest.basePath && routesManifest.basePath !== "/") {
          const nextBasePath = routesManifest.basePath;
          if (!nextBasePath.startsWith("/")) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_STARTING_SLASH",
              message: "basePath must start with `/`. Please upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
            });
          }
          if (nextBasePath.endsWith("/")) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_TRAILING_SLASH",
              message: "basePath must not end with `/`. Please upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
            });
          }
          if (entryDirectory.length > 1) {
            throw new import_build_utils3.NowBuildError({
              code: "NEXT_BASEPATH_LEGACY_BUILDS",
              message: "basePath can not be used with `builds` in vercel.json, use Project Settings to configure your monorepo instead",
              link: "https://vercel.com/docs/platform/projects#project-settings"
            });
          }
          entryDirectory = import_path5.default.join(entryDirectory, nextBasePath);
          appMountPrefixNoTrailingSlash = import_path5.default.posix.join("/", entryDirectory).replace(/\/+$/, "");
        }
        if (routesManifest.pages404) {
          hasPages404 = true;
        }
        break;
      }
      default: {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT_VERSION_OUTDATED",
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
        });
      }
    }
  }
  let dynamicPrefix = import_path5.default.posix.join("/", entryDirectory);
  dynamicPrefix = dynamicPrefix === "/" ? "" : dynamicPrefix;
  if (imagesManifest) {
    switch (imagesManifest.version) {
      case 1: {
        if (!imagesManifest.images) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_MISSING",
            message: 'image-manifest.json "images" is required. Contact support if this continues to happen.'
          });
        }
        const { images } = imagesManifest;
        if (!Array.isArray(images.domains)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_DOMAINS",
            message: 'image-manifest.json "images.domains" must be an array. Contact support if this continues to happen.'
          });
        }
        if (!Array.isArray(images.sizes)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_SIZES",
            message: 'image-manifest.json "images.sizes" must be an array. Contact support if this continues to happen.'
          });
        }
        if (images.remotePatterns && !Array.isArray(images.remotePatterns)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_REMOTEPATTERNS",
            message: 'image-manifest.json "images.remotePatterns" must be an array. Contact support if this continues to happen'
          });
        }
        if (images.minimumCacheTTL && !Number.isInteger(images.minimumCacheTTL)) {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_MINIMUMCACHETTL",
            message: 'image-manifest.json "images.minimumCacheTTL" must be an integer. Contact support if this continues to happen.'
          });
        }
        if (typeof images.dangerouslyAllowSVG !== "undefined" && typeof images.dangerouslyAllowSVG !== "boolean") {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_DANGEROUSLYALLOWSVG",
            message: 'image-manifest.json "images.dangerouslyAllowSVG" must be a boolean. Contact support if this continues to happen.'
          });
        }
        if (typeof images.contentSecurityPolicy !== "undefined" && typeof images.contentSecurityPolicy !== "string") {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_IMAGES_CONTENTSECURITYPOLICY",
            message: 'image-manifest.json "images.contentSecurityPolicy" must be a string. Contact support if this continues to happen.'
          });
        }
        break;
      }
      default: {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT_IMAGES_VERSION_UNKNOWN",
          message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
        });
      }
    }
  }
  const userExport = await getExportStatus(entryPath);
  if (userExport) {
    const exportIntent = await getExportIntent(entryPath);
    const { trailingSlash: trailingSlash2 = false } = exportIntent || {};
    const resultingExport = await getExportStatus(entryPath);
    if (!resultingExport) {
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_EXPORT_FAILED",
        message: "Exporting Next.js app failed. Please check your build logs and contact us if this continues."
      });
    }
    if (resultingExport.success !== true) {
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_EXPORT_FAILED",
        message: "Export of Next.js app failed. Please check your build logs."
      });
    }
    const outDirectory = resultingExport.outDirectory;
    (0, import_build_utils3.debug)(`next export should use trailing slash: ${trailingSlash2}`);
    const filesAfterBuild = await (0, import_build_utils3.glob)("**", outDirectory);
    const output = {
      ...filesAfterBuild,
      ...privateOutputs.files
    };
    Object.entries(output).filter(([name]) => name.endsWith(".html")).forEach(([name, value]) => {
      const cleanName = name.slice(0, -5);
      delete output[name];
      output[cleanName] = value;
      if (value.type === "FileBlob" || value.type === "FileFsRef") {
        value.contentType = value.contentType || "text/html; charset=utf-8";
      }
    });
    console.log(
      "Notice: detected `next export`, this de-opts some Next.js features\nSee more info: https://nextjs.org/docs/advanced-features/static-html-export"
    );
    return {
      output,
      images: getImagesConfig(imagesManifest),
      routes: [
        ...privateOutputs.routes,
        ...headers,
        ...redirects,
        ...beforeFilesRewrites,
        // Make sure to 404 for the /404 path itself
        {
          src: import_path5.default.posix.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true
        },
        // Next.js pages, `static/` folder, reserved assets, and `public/`
        // folder
        { handle: "filesystem" },
        // ensure the basePath prefixed _next/image is rewritten to the root
        // _next/image path
        ...routesManifest?.basePath ? [
          {
            src: import_path5.default.posix.join("/", entryDirectory, "_next/image/?"),
            dest: "/_next/image",
            check: true
          }
        ] : [],
        // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
        // if no match to prevent rewriting _next/data unexpectedly
        {
          src: import_path5.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          dest: import_path5.default.posix.join("/", entryDirectory, "_next/data/$1"),
          check: true
        },
        {
          src: import_path5.default.posix.join("/", entryDirectory, "_next/data/(.*)"),
          status: 404
        },
        // These need to come before handle: miss or else they are grouped
        // with that routing section
        ...afterFilesRewrites,
        // make sure 404 page is used when a directory is matched without
        // an index page
        { handle: "resource" },
        ...fallbackRewrites,
        { src: import_path5.default.posix.join("/", entryDirectory, ".*"), status: 404 },
        // We need to make sure to 404 for /_next after handle: miss since
        // handle: miss is called before rewrites and to prevent rewriting
        // /_next
        { handle: "miss" },
        {
          src: import_path5.default.posix.join(
            "/",
            entryDirectory,
            "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
          ),
          status: 404,
          check: true,
          dest: "$0"
        },
        // Dynamic routes
        // TODO: do we want to do this?: ...dynamicRoutes,
        // (if so make sure to add any dynamic routes after handle: 'rewrite' )
        // routes to call after a file has been matched
        { handle: "hit" },
        // Before we handle static files we need to set proper caching headers
        {
          // This ensures we only match known emitted-by-Next.js files and not
          // user-emitted files which may be missing a hash in their filename.
          src: import_path5.default.posix.join(
            "/",
            entryDirectory,
            `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
          ),
          // Next.js assets contain a hash or entropy in their filenames, so they
          // are guaranteed to be unique and cacheable indefinitely.
          headers: {
            "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
          },
          continue: true,
          important: true
        },
        // error handling
        ...output[import_path5.default.posix.join("./", entryDirectory, "404")] || output[import_path5.default.posix.join("./", entryDirectory, "404/index")] ? [
          { handle: "error" },
          {
            status: 404,
            src: import_path5.default.posix.join(entryDirectory, ".*"),
            dest: import_path5.default.posix.join("/", entryDirectory, "404")
          }
        ] : []
      ],
      framework: { version: nextVersion }
    };
  }
  if (isLegacy) {
    (0, import_build_utils3.debug)("Running npm install --production...");
    await (0, import_build_utils3.runNpmInstall)(
      entryPath,
      ["--production"],
      spawnOpts,
      meta,
      nodeVersion
    );
  }
  if (process.env.NPM_AUTH_TOKEN) {
    await (0, import_fs_extra6.remove)(import_path5.default.join(entryPath, ".npmrc"));
  }
  const trailingSlashRedirects = [];
  let trailingSlash = false;
  redirects = redirects.filter((_redir) => {
    const redir = _redir;
    const location = redir.headers && (redir.headers.location || redir.headers.Location);
    if (redir.status === 308 && (location === "/$1" || location === "/$1/")) {
      redir.continue = true;
      trailingSlashRedirects.push(redir);
      if (location === "/$1/") {
        trailingSlash = true;
      }
      return false;
    }
    return true;
  });
  const pageLambdaRoutes = [];
  const dynamicPageLambdaRoutes = [];
  const dynamicPageLambdaRoutesMap = {};
  const pageLambdaMap = {};
  const lambdas = {};
  const prerenders = {};
  let staticPages = {};
  const dynamicPages = [];
  let static404Page;
  let page404Path = "";
  let hasStatic500;
  if (isLegacy) {
    const filesAfterBuild = await (0, import_build_utils3.glob)("**", entryPath);
    (0, import_build_utils3.debug)("Preparing serverless function files...");
    const dotNextRootFiles = await (0, import_build_utils3.glob)(`${outputDirectory}/*`, entryPath);
    const dotNextServerRootFiles = await (0, import_build_utils3.glob)(
      `${outputDirectory}/server/*`,
      entryPath
    );
    const nodeModules = excludeFiles(
      await (0, import_build_utils3.glob)("node_modules/**", entryPath),
      (file) => file.startsWith("node_modules/.cache")
    );
    const nextFiles = {
      ...nodeModules,
      ...dotNextRootFiles,
      ...dotNextServerRootFiles
    };
    if (filesAfterBuild["next.config.js"]) {
      nextFiles["next.config.js"] = filesAfterBuild["next.config.js"];
    }
    const pagesDir = import_path5.default.join(
      entryPath,
      outputDirectory,
      "server",
      "static",
      buildId,
      "pages"
    );
    const { pages } = await getServerlessPages({
      pagesDir,
      entryPath,
      outputDirectory
    });
    const launcherPath = import_path5.default.join(__dirname, "legacy-launcher.js");
    const launcherData = await (0, import_fs_extra6.readFile)(launcherPath, "utf8");
    await Promise.all(
      Object.keys(pages).map(async (page) => {
        if (["_app.js", "_error.js", "_document.js"].includes(page)) {
          return;
        }
        const pathname = page.replace(/\.js$/, "");
        const launcher = launcherData.replace(
          "PATHNAME_PLACEHOLDER",
          `/${pathname.replace(/(^|\/)index$/, "")}`
        );
        const pageFiles = {
          [`${outputDirectory}/server/static/${buildId}/pages/_document.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_document.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/_app.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_app.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/_error.js`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/_error.js`],
          [`${outputDirectory}/server/static/${buildId}/pages/${page}`]: filesAfterBuild[`${outputDirectory}/server/static/${buildId}/pages/${page}`]
        };
        let lambdaOptions = {};
        if (config && config.functions) {
          lambdaOptions = await (0, import_build_utils3.getLambdaOptionsFromFunction)({
            sourceFile: await getSourceFilePathFromPage({
              workPath: entryPath,
              page
            }),
            config
          });
        }
        (0, import_build_utils3.debug)(`Creating serverless function for page: "${page}"...`);
        lambdas[import_path5.default.posix.join(entryDirectory, pathname)] = new import_build_utils3.NodejsLambda({
          files: {
            ...nextFiles,
            ...pageFiles,
            "___next_launcher.cjs": new import_build_utils3.FileBlob({ data: launcher })
          },
          handler: "___next_launcher.cjs",
          runtime: nodeVersion.runtime,
          ...lambdaOptions,
          operationType: "Page",
          // always Page because we're in legacy mode
          shouldAddHelpers: false,
          shouldAddSourcemapSupport: false,
          supportsMultiPayloads: true,
          framework: {
            slug: "nextjs",
            version: nextVersion
          }
        });
        (0, import_build_utils3.debug)(`Created serverless function for page: "${page}"`);
      })
    );
  } else {
    (0, import_build_utils3.debug)("Preparing serverless function files...");
    const pagesDir = import_path5.default.join(
      entryPath,
      outputDirectory,
      isServerMode ? "server" : "serverless",
      "pages"
    );
    let appDir = null;
    const appPathRoutesManifest = await (0, import_fs_extra6.readJSON)(
      import_path5.default.join(entryPath, outputDirectory, "app-path-routes-manifest.json")
    ).catch(() => null);
    if (appPathRoutesManifest) {
      appDir = import_path5.default.join(pagesDir, "../app");
    }
    const { pages, appPaths: lambdaAppPaths } = await getServerlessPages({
      pagesDir,
      entryPath,
      outputDirectory,
      appPathRoutesManifest
    });
    const canUsePreviewMode = Object.keys(pages).some(
      (page) => isApiPage(pages[page].fsPath)
    );
    const originalStaticPages = await (0, import_build_utils3.glob)("**/*.html", pagesDir);
    staticPages = filterStaticPages(
      originalStaticPages,
      dynamicPages,
      entryDirectory,
      htmlContentType,
      prerenderManifest,
      routesManifest
    );
    hasStatic500 = !!staticPages[import_path5.default.posix.join(entryDirectory, "500")];
    static404Page = staticPages[import_path5.default.posix.join(entryDirectory, "404")] && hasPages404 ? import_path5.default.posix.join(entryDirectory, "404") : staticPages[import_path5.default.posix.join(entryDirectory, "_errors/404")] ? import_path5.default.posix.join(entryDirectory, "_errors/404") : void 0;
    const { i18n: i18n2 } = routesManifest || {};
    if (!static404Page && i18n2) {
      static404Page = staticPages[import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "404")] ? import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "404") : void 0;
    }
    if (!hasStatic500 && i18n2) {
      hasStatic500 = !!staticPages[import_path5.default.posix.join(entryDirectory, i18n2.defaultLocale, "500")];
    }
    if (routesManifest) {
      switch (routesManifest.version) {
        case 1:
        case 2:
        case 3:
        case 4: {
          if (routesManifest.dataRoutes) {
            for (const dataRoute of routesManifest.dataRoutes) {
              const isOmittedRoute = prerenderManifest.omittedRoutes[dataRoute.page];
              const ssgDataRoute = isOmittedRoute || prerenderManifest.fallbackRoutes[dataRoute.page] || prerenderManifest.blockingFallbackRoutes[dataRoute.page];
              if (prerenderManifest.staticRoutes[dataRoute.page] || !(static404Page && canUsePreviewMode) && isOmittedRoute) {
                continue;
              }
              const route = {
                src: (dataRoute.namedDataRouteRegex || dataRoute.dataRouteRegex).replace(/^\^/, `^${appMountPrefixNoTrailingSlash}`),
                dest: import_path5.default.posix.join(
                  "/",
                  entryDirectory,
                  // make sure to route SSG data route to the data prerender
                  // output, we don't do this for SSP routes since they don't
                  // have a separate data output
                  `${ssgDataRoute && ssgDataRoute.dataRoute || dataRoute.page}${dataRoute.routeKeys ? `?${Object.keys(dataRoute.routeKeys).map((key) => `${dataRoute.routeKeys[key]}=$${key}`).join("&")}` : ""}`
                )
              };
              if (!isServerMode) {
                route.check = true;
              }
              if (isOmittedRoute && isServerMode) {
                route.has = [
                  {
                    type: "cookie",
                    key: "__prerender_bypass",
                    value: prerenderManifest.bypassToken || void 0
                  },
                  {
                    type: "cookie",
                    key: "__next_preview_data"
                  }
                ];
              }
              const { i18n: i18n3 } = routesManifest;
              if (i18n3) {
                const origSrc = route.src;
                route.src = route.src.replace(
                  // we need to double escape the build ID here
                  // to replace it properly
                  `/${escapedBuildId}/`,
                  `/${escapedBuildId}/(?${ssgDataRoute || isServerMode ? "<nextLocale>" : ":"}${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/`
                );
                if (route.src === origSrc) {
                  route.src = route.src.replace(
                    // we need to double escape the build ID here
                    // to replace it properly
                    `/${escapedBuildId}`,
                    `/${escapedBuildId}/(?${ssgDataRoute || isServerMode ? "<nextLocale>" : ":"}${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})[/]?`
                  );
                }
                if (dataRoute.page === "/") {
                  route.src = route.src.replace(/\/index\.json/, ".json");
                }
                if (ssgDataRoute) {
                  route.dest = route.dest.replace(
                    `/${buildId}/`,
                    `/${buildId}/$nextLocale/`
                  );
                } else if (isServerMode) {
                  route.dest = route.dest.replace(
                    dataRoute.page,
                    `/$nextLocale${dataRoute.page}`
                  );
                }
              }
              dataRoutes.push(route);
            }
          }
          break;
        }
        default: {
          throw new import_build_utils3.NowBuildError({
            code: "NEXT_VERSION_OUTDATED",
            message: "This version of `@vercel/next` does not support the version of Next.js you are trying to deploy.\nPlease upgrade your `@vercel/next` builder and try again. Contact support if this continues to happen."
          });
        }
      }
    }
    if (requiredServerFilesManifest) {
      if (!routesManifest) {
        throw new Error(
          `A routes-manifest could not be located, please check your outputDirectory and try again.`
        );
      }
      const localePrefixed404 = !!(routesManifest.i18n && originalStaticPages[import_path5.default.posix.join(".", routesManifest.i18n.defaultLocale, "404.html")]);
      return serverBuild({
        config,
        functionsConfigManifest,
        nextVersion,
        trailingSlash,
        appPathRoutesManifest,
        dynamicPages,
        canUsePreviewMode,
        staticPages,
        localePrefixed404,
        lambdaPages: pages,
        lambdaAppPaths,
        omittedPrerenderRoutes,
        isCorrectLocaleAPIRoutes,
        pagesDir,
        headers,
        beforeFilesRewrites,
        afterFilesRewrites,
        fallbackRewrites,
        workPath,
        redirects,
        nodeVersion,
        dynamicPrefix,
        routesManifest,
        imagesManifest,
        wildcardConfig,
        prerenderManifest,
        entryDirectory,
        entryPath,
        baseDir,
        dataRoutes,
        buildId,
        escapedBuildId,
        outputDirectory,
        trailingSlashRedirects,
        lambdaCompressedByteLimit,
        requiredServerFilesManifest,
        privateOutputs,
        hasIsr404Page,
        hasIsr500Page,
        variantsManifest
      });
    }
    const pageKeys = Object.keys(pages);
    let hasLambdas = !static404Page || pageKeys.length > 1;
    if (pageKeys.length === 0) {
      const nextConfig = await getNextConfig(workPath, entryPath);
      if (nextConfig != null) {
        console.info("Found next.config.js:");
        console.info(nextConfig);
        console.info();
      }
      throw new import_build_utils3.NowBuildError({
        code: "NEXT_NO_SERVERLESS_PAGES",
        message: "No serverless pages were built",
        link: "https://err.sh/vercel/vercel/now-next-no-serverless-pages-built"
      });
    }
    let requiresTracing = hasLambdas;
    try {
      if (nextVersion && import_semver4.default.lt(nextVersion, ExperimentalTraceVersion)) {
        (0, import_build_utils3.debug)(
          "Next.js version is too old for us to trace the required dependencies.\nAssuming Next.js has handled it!"
        );
        requiresTracing = false;
      }
    } catch (err) {
      console.log(
        "Failed to check Next.js version for tracing compatibility: " + err
      );
    }
    let assets;
    const nonLambdaSsgPages = /* @__PURE__ */ new Set();
    Object.keys(prerenderManifest.staticRoutes).forEach((route) => {
      const result = onPrerenderRouteInitial(
        prerenderManifest,
        canUsePreviewMode,
        entryDirectory,
        nonLambdaSsgPages,
        route,
        hasPages404,
        routesManifest
      );
      if (result && result.static404Page) {
        static404Page = result.static404Page;
      }
      if (result && result.static500Page) {
        hasStatic500 = true;
      }
    });
    const pageTraces = {};
    const compressedPages = {};
    let tracedPseudoLayer;
    const apiPages = [];
    const nonApiPages = [];
    for (const page of pageKeys) {
      const pagePath = pages[page].fsPath;
      const route = `/${page.replace(/\.js$/, "")}`;
      if (route === "/_error" && static404Page)
        continue;
      if (isApiPage(pagePath)) {
        apiPages.push(page);
      } else if (!nonLambdaSsgPages.has(route)) {
        nonApiPages.push(page);
      }
      compressedPages[page] = (await createPseudoLayer({
        [page]: pages[page]
      })).pseudoLayer[page];
    }
    const mergedPageKeys = [...nonApiPages, ...apiPages];
    if (requiresTracing) {
      hasLambdas = !static404Page || apiPages.length > 0 || nonApiPages.length > 0;
      const tracingLabel = "Traced Next.js serverless functions for external files in";
      if (hasLambdas) {
        console.time(tracingLabel);
      }
      const nftCache = /* @__PURE__ */ Object.create(null);
      const lstatSema = new import_async_sema3.Sema(25);
      const lstatResults = {};
      const pathsToTrace = mergedPageKeys.map((page) => pages[page].fsPath);
      const result = await (0, import_nft2.nodeFileTrace)(pathsToTrace, {
        base: baseDir,
        cache: nftCache,
        processCwd: entryPath
      });
      result.esmFileList.forEach((file) => result.fileList.add(file));
      const parentFilesMap = getFilesMapFromReasons(
        result.fileList,
        result.reasons
      );
      for (const page of mergedPageKeys) {
        const tracedFiles = {};
        const fileList = parentFilesMap.get(
          import_path5.default.relative(baseDir, pages[page].fsPath)
        );
        if (!fileList) {
          throw new Error(
            `Invariant: Failed to trace ${page}, missing fileList`
          );
        }
        const reasons = result.reasons;
        await Promise.all(
          Array.from(fileList).map(
            collectTracedFiles(
              baseDir,
              lstatResults,
              lstatSema,
              reasons,
              tracedFiles
            )
          )
        );
        pageTraces[page] = tracedFiles;
      }
      if (hasLambdas) {
        console.timeEnd(tracingLabel);
      }
      const zippingLabel = "Compressed shared serverless function files";
      if (hasLambdas) {
        console.time(zippingLabel);
      }
      tracedPseudoLayer = await createPseudoLayer(
        mergedPageKeys.reduce((prev, page) => {
          Object.assign(prev, pageTraces[page]);
          return prev;
        }, {})
      );
      if (hasLambdas) {
        console.timeEnd(zippingLabel);
      }
    } else {
      assets = await (0, import_build_utils3.glob)(
        "assets/**",
        import_path5.default.join(entryPath, outputDirectory, "serverless")
      );
      const assetKeys = Object.keys(assets);
      if (assetKeys.length > 0) {
        (0, import_build_utils3.debug)(
          "detected (legacy) assets to be bundled with serverless function:"
        );
        assetKeys.forEach((assetFile) => (0, import_build_utils3.debug)(`	${assetFile}`));
        (0, import_build_utils3.debug)(
          "\nPlease upgrade to Next.js 9.1 to leverage modern asset handling."
        );
      }
    }
    const launcherPath = import_path5.default.join(__dirname, "templated-launcher.js");
    const launcherData = await (0, import_fs_extra6.readFile)(launcherPath, "utf8");
    const allLambdasLabel = `All serverless functions created in`;
    if (hasLambdas) {
      console.time(allLambdasLabel);
    }
    const apiLambdaGroups = [];
    const pageLambdaGroups = [];
    if (isSharedLambdas) {
      const initialPageLambdaGroups = await getPageLambdaGroups({
        entryPath,
        config,
        functionsConfigManifest,
        pages: nonApiPages,
        prerenderRoutes: /* @__PURE__ */ new Set(),
        pageTraces,
        compressedPages,
        tracedPseudoLayer: tracedPseudoLayer?.pseudoLayer || {},
        initialPseudoLayer: { pseudoLayer: {}, pseudoLayerBytes: 0 },
        initialPseudoLayerUncompressed: 0,
        lambdaCompressedByteLimit,
        // internal pages are already referenced in traces for serverless
        // like builds
        internalPages: [],
        experimentalPPRRoutes: void 0
      });
      const initialApiLambdaGroups = await getPageLambdaGroups({
        entryPath,
        config,
        functionsConfigManifest,
        pages: apiPages,
        prerenderRoutes: /* @__PURE__ */ new Set(),
        pageTraces,
        compressedPages,
        tracedPseudoLayer: tracedPseudoLayer?.pseudoLayer || {},
        initialPseudoLayer: { pseudoLayer: {}, pseudoLayerBytes: 0 },
        initialPseudoLayerUncompressed: 0,
        lambdaCompressedByteLimit,
        internalPages: [],
        experimentalPPRRoutes: void 0
      });
      for (const group of initialApiLambdaGroups) {
        group.isApiLambda = true;
      }
      (0, import_build_utils3.debug)(
        JSON.stringify(
          {
            apiLambdaGroups: initialApiLambdaGroups.map((group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              pseudoLayerBytes: group.pseudoLayerBytes
            })),
            pageLambdaGroups: initialPageLambdaGroups.map((group) => ({
              pages: group.pages,
              isPrerender: group.isPrerenders,
              pseudoLayerBytes: group.pseudoLayerBytes
            }))
          },
          null,
          2
        )
      );
      const combinedInitialLambdaGroups = [
        ...initialApiLambdaGroups,
        ...initialPageLambdaGroups
      ];
      await detectLambdaLimitExceeding(
        combinedInitialLambdaGroups,
        lambdaCompressedByteLimit,
        compressedPages
      );
      let apiLambdaGroupIndex = 0;
      let nonApiLambdaGroupIndex = 0;
      for (const group of combinedInitialLambdaGroups) {
        let routeIsApi;
        for (const page of group.pages) {
          if (["_app.js", "_document.js"].includes(page)) {
            continue;
          }
          if (page === "_error.js" && (static404Page && staticPages[static404Page] || hasPages404 && pages["404.js"])) {
            continue;
          }
          const pageFileName = import_path5.default.normalize(
            import_path5.default.relative(workPath, pages[page].fsPath)
          );
          const pathname = page.replace(/\.js$/, "");
          const routeIsDynamic = isDynamicRoute(pathname);
          routeIsApi = isApiPage(pageFileName);
          if (routeIsDynamic) {
            dynamicPages.push(normalizePage(pathname));
          }
          if (nonLambdaSsgPages.has(`/${pathname}`)) {
            continue;
          }
          const outputName = import_path5.default.join("/", entryDirectory, pathname);
          const lambdaGroupIndex = routeIsApi ? apiLambdaGroupIndex : nonApiLambdaGroupIndex;
          const lambdaGroups = routeIsApi ? apiLambdaGroups : pageLambdaGroups;
          const lastLambdaGroup = lambdaGroups[lambdaGroupIndex];
          let currentLambdaGroup = lastLambdaGroup;
          if (!currentLambdaGroup) {
            currentLambdaGroup = {
              pages: {},
              isApiLambda: !!routeIsApi,
              pseudoLayer: group.pseudoLayer,
              lambdaCombinedBytes: group.pseudoLayerBytes,
              lambdaIdentifier: import_path5.default.join(
                entryDirectory,
                `__NEXT_${routeIsApi ? "API" : "PAGE"}_LAMBDA_${lambdaGroupIndex}`
              )
            };
          }
          const addPageLambdaRoute = (escapedOutputPath) => {
            const pageLambdaRoute = {
              src: `^${escapedOutputPath.replace(
                /\/index$/,
                "(/|/index|)"
              )}/?$`,
              dest: `${import_path5.default.join("/", currentLambdaGroup.lambdaIdentifier)}`,
              headers: {
                "x-nextjs-page": outputName
              },
              check: true
            };
            if (routeIsDynamic) {
              dynamicPageLambdaRoutes.push(pageLambdaRoute);
              dynamicPageLambdaRoutesMap[outputName] = pageLambdaRoute;
            } else {
              pageLambdaRoutes.push(pageLambdaRoute);
            }
          };
          const { i18n: i18n3 } = routesManifest || {};
          if (i18n3) {
            addPageLambdaRoute(
              `[/]?(?:${i18n3.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?${(0, import_escape_string_regexp3.default)(outputName)}`
            );
          } else {
            addPageLambdaRoute((0, import_escape_string_regexp3.default)(outputName));
          }
          if (page === "_error.js" || hasPages404 && page === "404.js") {
            page404Path = import_path5.default.join("/", entryDirectory, pathname);
          }
          currentLambdaGroup.pages[outputName] = {
            pageFileName,
            pageName: page
          };
          currentLambdaGroup.pseudoLayer[import_path5.default.join(import_path5.default.relative(baseDir, entryPath), pageFileName)] = compressedPages[page];
          lambdaGroups[lambdaGroupIndex] = currentLambdaGroup;
        }
        if (routeIsApi) {
          apiLambdaGroupIndex++;
        } else {
          nonApiLambdaGroupIndex++;
        }
      }
    } else {
      await Promise.all(
        pageKeys.map(async (page) => {
          if (["_app.js", "_document.js"].includes(page)) {
            return;
          }
          if (page === "_error.js" && (static404Page && staticPages[static404Page] || hasPages404 && pages["404.js"])) {
            return;
          }
          const pathname = page.replace(/\.js$/, "");
          if (isDynamicRoute(pathname)) {
            dynamicPages.push(normalizePage(pathname));
          }
          const pageFileName = import_path5.default.normalize(
            import_path5.default.relative(entryPath, pages[page].fsPath)
          );
          const launcher = launcherData.replace(
            /__LAUNCHER_PAGE_PATH__/g,
            JSON.stringify(requiresTracing ? `./${pageFileName}` : "./page")
          );
          const launcherFiles = {
            [import_path5.default.join(
              import_path5.default.relative(baseDir, entryPath),
              "___next_launcher.cjs"
            )]: new import_build_utils3.FileBlob({ data: launcher })
          };
          let lambdaOptions = {};
          if (config && config.functions) {
            lambdaOptions = await (0, import_build_utils3.getLambdaOptionsFromFunction)({
              sourceFile: await getSourceFilePathFromPage({
                workPath: entryPath,
                page
              }),
              config
            });
          }
          const outputName = normalizeIndexOutput(
            import_path5.default.join(entryDirectory, pathname),
            isServerMode
          );
          if (requiresTracing) {
            lambdas[outputName] = await createLambdaFromPseudoLayers({
              files: launcherFiles,
              layers: [
                Object.keys(pageTraces[page] || {}).reduce((prev, cur) => {
                  prev[cur] = tracedPseudoLayer?.pseudoLayer[cur];
                  return prev;
                }, {}),
                {
                  [import_path5.default.join(import_path5.default.relative(baseDir, entryPath), pageFileName)]: compressedPages[page]
                }
              ],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType: getOperationType({
                prerenderManifest,
                pageFileName
              }),
              runtime: nodeVersion.runtime,
              nextVersion,
              ...lambdaOptions
            });
          } else {
            lambdas[outputName] = await createLambdaFromPseudoLayers({
              files: {
                ...launcherFiles,
                ...assets
              },
              layers: [
                {
                  [import_path5.default.join(import_path5.default.relative(baseDir, entryPath), "page.js")]: compressedPages[page]
                }
              ],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType: getOperationType({ pageFileName }),
              // can only be API or Page
              runtime: nodeVersion.runtime,
              nextVersion,
              ...lambdaOptions
            });
          }
        })
      );
    }
    dynamicRoutes = await getDynamicRoutes(
      entryPath,
      entryDirectory,
      dynamicPages,
      false,
      routesManifest,
      omittedPrerenderRoutes,
      canUsePreviewMode,
      prerenderManifest.bypassToken || "",
      isServerMode
    ).then(
      (arr) => localizeDynamicRoutes(
        arr,
        dynamicPrefix,
        entryDirectory,
        staticPages,
        prerenderManifest,
        routesManifest,
        isServerMode,
        isCorrectLocaleAPIRoutes
      )
    );
    if (isSharedLambdas) {
      const launcherPath2 = import_path5.default.join(__dirname, "templated-launcher-shared.js");
      const launcherData2 = await (0, import_fs_extra6.readFile)(launcherPath2, "utf8");
      const completeDynamicRoutes = await getDynamicRoutes(
        entryPath,
        entryDirectory,
        dynamicPages,
        false,
        routesManifest,
        void 0,
        canUsePreviewMode,
        prerenderManifest.bypassToken || "",
        isServerMode
      ).then(
        (arr) => arr.map((route) => {
          route.src = route.src.replace("^", `^${dynamicPrefix}`);
          return route;
        })
      );
      await Promise.all(
        [...apiLambdaGroups, ...pageLambdaGroups].map(
          async function buildLambdaGroup(group) {
            const groupPageKeys = Object.keys(group.pages);
            const launcher = launcherData2.replace(
              "let page = {};",
              `let page = {};
              const url = require('url');

              ${routesManifest?.i18n ? `
                  function stripLocalePath(pathname) {
                  // first item will be empty string from splitting at first char
                  const pathnameParts = pathname.split('/')

                  ;(${JSON.stringify(
                routesManifest.i18n.locales
              )}).some((locale) => {
                    if (pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
                      pathnameParts.splice(1, 1)
                      pathname = pathnameParts.join('/') || '/index'
                      return true
                    }
                    return false
                  })

                  return pathname
                }
                ` : `function stripLocalePath(pathname) { return pathname }`}

              page = function(req, res) {
                try {
                  const pages = {
                    ${groupPageKeys.map(
                (page) => `'${page}': () => require('./${import_path5.default.join(
                  "./",
                  group.pages[page].pageFileName
                )}')`
              ).join(",\n")}
                    ${""}
                  }
                  let toRender = req.headers['x-nextjs-page']

                  if (!toRender) {
                    try {
                      const { pathname } = url.parse(req.url)
                      toRender = stripLocalePath(pathname).replace(/\\/$/, '') || '/index'
                    } catch (_) {
                      // handle failing to parse url
                      res.statusCode = 400
                      return res.end('Bad Request')
                    }
                  }

                  let currentPage = pages[toRender]

                  if (
                    toRender &&
                    !currentPage
                  ) {
                    if (toRender.includes('/_next/data')) {
                      toRender = toRender
                        .replace(new RegExp('/_next/data/${escapedBuildId}/'), '/')
                        .replace(/\\.json$/, '')

                      toRender = stripLocalePath(toRender) || '/index'
                      currentPage = pages[toRender]
                    }

                    if (!currentPage) {
                      // for prerendered dynamic routes (/blog/post-1) we need to
                      // find the match since it won't match the page directly
                      const dynamicRoutes = ${JSON.stringify(
                completeDynamicRoutes.map((route) => ({
                  src: route.src,
                  dest: route.dest
                }))
              )}

                      for (const route of dynamicRoutes) {
                        const matcher = new RegExp(route.src)

                        if (matcher.test(toRender)) {
                          toRender = url.parse(route.dest).pathname
                          currentPage = pages[toRender]
                          break
                        }
                      }
                    }
                  }

                  if (!currentPage) {
                    console.error(
                      "pages in lambda:",
                      Object.keys(pages),
                      "page header received:",
                      req.headers["x-nextjs-page"]
                    );
                    throw new Error(
                      "Failed to find matching page in lambda for: " +
                        JSON.stringify(
                          {
                            toRender,
                            url: req.url,
                            header: req.headers["x-nextjs-page"],
                          },
                          null,
                          2
                        )
                    );
                  }

                  const mod = currentPage()
                  const method = mod.render || mod.default || mod

                  return method(req, res)
                } catch (err) {
                  console.error('Unhandled error during request:', err)
                  throw err
                }
              }
              `
            );
            const launcherFiles = {
              [import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              )]: new import_build_utils3.FileBlob({ data: launcher })
            };
            for (const page of groupPageKeys) {
              pageLambdaMap[page] = group.lambdaIdentifier;
            }
            const operationType = getOperationType({
              group,
              prerenderManifest
            });
            lambdas[group.lambdaIdentifier] = await createLambdaFromPseudoLayers({
              files: {
                ...launcherFiles,
                ...assets
              },
              layers: [group.pseudoLayer],
              handler: import_path5.default.join(
                import_path5.default.relative(baseDir, entryPath),
                "___next_launcher.cjs"
              ),
              operationType,
              runtime: nodeVersion.runtime,
              nextVersion
            });
          }
        )
      );
    }
    if (hasLambdas) {
      console.timeEnd(allLambdasLabel);
    }
    const prerenderRoute = onPrerenderRoute({
      appDir,
      pagesDir,
      hasPages404,
      static404Page,
      pageLambdaMap,
      lambdas,
      experimentalStreamingLambdaPaths: void 0,
      isServerMode,
      prerenders,
      entryDirectory,
      routesManifest,
      prerenderManifest,
      appPathRoutesManifest,
      isSharedLambdas,
      canUsePreviewMode
    });
    Object.keys(prerenderManifest.staticRoutes).forEach(
      (route) => prerenderRoute(route, { isBlocking: false, isFallback: false })
    );
    Object.keys(prerenderManifest.fallbackRoutes).forEach(
      (route) => prerenderRoute(route, { isBlocking: false, isFallback: true })
    );
    Object.keys(prerenderManifest.blockingFallbackRoutes).forEach(
      (route) => prerenderRoute(route, { isBlocking: true, isFallback: false })
    );
    if (static404Page && canUsePreviewMode) {
      omittedPrerenderRoutes.forEach((route) => {
        prerenderRoute(route, { isOmitted: true });
      });
    }
    if (!(routesManifest && routesManifest.dataRoutes)) {
      [
        ...Object.entries(prerenderManifest.fallbackRoutes),
        ...Object.entries(prerenderManifest.blockingFallbackRoutes)
      ].forEach(
        ([
          ,
          {
            dataRouteRegex,
            dataRoute,
            prefetchDataRouteRegex,
            prefetchDataRoute
          }
        ]) => {
          if (!dataRoute || !dataRouteRegex)
            return;
          dataRoutes.push({
            // Next.js provided data route regex
            src: dataRouteRegex.replace(
              /^\^/,
              `^${appMountPrefixNoTrailingSlash}`
            ),
            // Location of lambda in builder output
            dest: import_path5.default.posix.join(entryDirectory, dataRoute),
            check: true
          });
          if (!prefetchDataRoute || !prefetchDataRouteRegex)
            return;
          dataRoutes.push({
            src: prefetchDataRouteRegex.replace(
              /^\^/,
              `^${appMountPrefixNoTrailingSlash}`
            ),
            dest: import_path5.default.posix.join(entryDirectory, prefetchDataRoute),
            check: true
          });
        }
      );
    }
  }
  if (!isSharedLambdas) {
    omittedPrerenderRoutes.forEach((routeKey) => {
      const routeFileNoExt = import_path5.default.posix.join(
        entryDirectory,
        routeKey === "/" ? "/index" : routeKey
      );
      if (typeof lambdas[routeFileNoExt] === void 0) {
        throw new import_build_utils3.NowBuildError({
          code: "NEXT__UNKNOWN_ROUTE_KEY",
          message: `invariant: unknown lambda ${routeKey} (lookup: ${routeFileNoExt}) | please report this immediately`
        });
      }
      delete lambdas[routeFileNoExt];
    });
  }
  const mergedDataRoutesLambdaRoutes = [];
  const mergedDynamicRoutesLambdaRoutes = [];
  if (isSharedLambdas) {
    for (let i = 0; i < dynamicRoutes.length; i++) {
      const route = dynamicRoutes[i];
      mergedDynamicRoutesLambdaRoutes.push(route);
      const { pathname } = import_url2.default.parse(route.dest);
      if (pathname && pageLambdaMap[pathname]) {
        mergedDynamicRoutesLambdaRoutes.push(
          dynamicPageLambdaRoutesMap[pathname]
        );
      }
    }
    for (let i = 0; i < dataRoutes.length; i++) {
      const route = dataRoutes[i];
      mergedDataRoutesLambdaRoutes.push(route);
      const { pathname } = import_url2.default.parse(route.dest);
      if (pathname && pageLambdaMap[pathname] && dynamicPageLambdaRoutesMap[pathname]) {
        mergedDataRoutesLambdaRoutes.push(dynamicPageLambdaRoutesMap[pathname]);
      }
    }
  }
  const { staticFiles, publicDirectoryFiles, staticDirectoryFiles } = await getStaticFiles(entryPath, entryDirectory, outputDirectory);
  const { i18n } = routesManifest || {};
  return {
    output: {
      ...publicDirectoryFiles,
      ...lambdas,
      // Prerenders may override Lambdas -- this is an intentional behavior.
      ...prerenders,
      ...staticPages,
      ...staticFiles,
      ...staticDirectoryFiles,
      ...privateOutputs.files
    },
    wildcard: wildcardConfig,
    images: getImagesConfig(imagesManifest),
    /*
      Desired routes order
      - Runtime headers
      - User headers and redirects
      - Runtime redirects
      - Runtime routes
      - Check filesystem, if nothing found continue
      - User rewrites
      - Builder rewrites
    */
    routes: [
      // force trailingSlashRedirect to the very top so it doesn't
      // conflict with i18n routes that don't have or don't have the
      // trailing slash
      ...trailingSlashRedirects,
      ...privateOutputs.routes,
      ...i18n ? [
        // Handle auto-adding current default locale to path based on
        // $wildcard
        {
          src: `^${import_path5.default.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          // we aren't able to ensure trailing slash mode here
          // so ensure this comes after the trailing slash redirect
          dest: `${entryDirectory !== "." ? import_path5.default.join("/", entryDirectory) : ""}$wildcard/$1`,
          continue: true
        },
        // Handle redirecting to locale specific domains
        ...i18n.domains && i18n.domains.length > 0 && i18n.localeDetection !== false ? [
          {
            src: `^${import_path5.default.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?/?$`,
            locale: {
              redirect: i18n.domains.reduce(
                (prev, item) => {
                  prev[item.defaultLocale] = `http${item.http ? "" : "s"}://${item.domain}/`;
                  if (item.locales) {
                    item.locales.map((locale) => {
                      prev[locale] = `http${item.http ? "" : "s"}://${item.domain}/${locale}`;
                    });
                  }
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        // Handle redirecting to locale paths
        ...i18n.localeDetection !== false ? [
          {
            // TODO: if default locale is included in this src it won't
            // be visitable by users who prefer another language since a
            // cookie isn't set signaling the default locale is
            // preferred on redirect currently, investigate adding this
            src: "/",
            locale: {
              redirect: i18n.locales.reduce(
                (prev, locale) => {
                  prev[locale] = locale === i18n.defaultLocale ? `/` : `/${locale}`;
                  return prev;
                },
                {}
              ),
              cookie: "NEXT_LOCALE"
            },
            continue: true
          }
        ] : [],
        {
          src: `^${import_path5.default.join("/", entryDirectory)}$`,
          dest: `${import_path5.default.join("/", entryDirectory, i18n.defaultLocale)}`,
          continue: true
        },
        // Auto-prefix non-locale path with default locale
        // note for prerendered pages this will cause
        // x-now-route-matches to contain the path minus the locale
        // e.g. for /de/posts/[slug] x-now-route-matches would have
        // 1=posts%2Fpost-1
        {
          src: `^${import_path5.default.join(
            "/",
            entryDirectory,
            "/"
          )}(?!(?:_next/.*|${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(?:/.*|$))(.*)$`,
          dest: `${import_path5.default.join("/", entryDirectory, i18n.defaultLocale)}/$1`,
          continue: true
        }
      ] : [],
      ...headers,
      ...redirects,
      ...beforeFilesRewrites,
      // Make sure to 404 for the /404 path itself
      ...i18n ? [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?[/]?404/?`,
          status: 404,
          continue: true
        }
      ] : [
        {
          src: import_path5.default.join("/", entryDirectory, "404/?"),
          status: 404,
          continue: true
        }
      ],
      // Make sure to 500 when visiting /500 directly for static 500
      ...!hasStatic500 ? [] : i18n ? [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})?[/]?500`,
          status: 500,
          continue: true
        }
      ] : [
        {
          src: import_path5.default.join("/", entryDirectory, "500"),
          status: 500,
          continue: true
        }
      ],
      // Next.js page lambdas, `static/` folder, reserved assets, and `public/`
      // folder
      { handle: "filesystem" },
      // map pages to their lambda
      ...pageLambdaRoutes.filter((route) => {
        if ("headers" in route) {
          let page = route.headers?.["x-nextjs-page"];
          page = page === "/index" ? "/" : page;
          if (prerenders[page]) {
            return false;
          }
        }
        return true;
      }),
      // ensure the basePath prefixed _next/image is rewritten to the root
      // _next/image path
      ...routesManifest?.basePath ? [
        {
          src: import_path5.default.join("/", entryDirectory, "_next/image/?"),
          dest: "/_next/image",
          check: true
        }
      ] : [],
      // No-op _next/data rewrite to trigger handle: 'rewrites' and then 404
      // if no match to prevent rewriting _next/data unexpectedly
      {
        src: import_path5.default.join("/", entryDirectory, "_next/data/(.*)"),
        dest: import_path5.default.join("/", entryDirectory, "_next/data/$1"),
        check: true
      },
      // These need to come before handle: miss or else they are grouped
      // with that routing section
      ...afterFilesRewrites,
      // make sure 404 page is used when a directory is matched without
      // an index page
      { handle: "resource" },
      ...fallbackRewrites,
      { src: import_path5.default.join("/", entryDirectory, ".*"), status: 404 },
      // We need to make sure to 404 for /_next after handle: miss since
      // handle: miss is called before rewrites and to prevent rewriting /_next
      { handle: "miss" },
      {
        src: import_path5.default.join(
          "/",
          entryDirectory,
          "_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media)/.+"
        ),
        status: 404,
        check: true,
        dest: "$0"
      },
      // remove locale prefixes to check public files
      ...i18n ? [
        {
          src: `^${import_path5.default.join("/", entryDirectory)}/?(?:${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/(.*)`,
          dest: `${import_path5.default.join("/", entryDirectory, "/")}$1`,
          check: true
        }
      ] : [],
      // for non-shared lambdas remove locale prefix if present
      // to allow checking for lambda
      ...isSharedLambdas || !i18n ? [] : [
        {
          src: `${import_path5.default.join("/", entryDirectory, "/")}(?:${i18n?.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})/(.*)`,
          dest: "/$1",
          check: true
        }
      ],
      // routes that are called after each rewrite or after routes
      // if there no rewrites
      { handle: "rewrite" },
      // /_next/data routes for getServerProps/getStaticProps pages
      ...isSharedLambdas ? mergedDataRoutesLambdaRoutes : dataRoutes,
      // ensure we 404 for non-existent _next/data routes before
      // trying page dynamic routes
      {
        src: import_path5.default.join("/", entryDirectory, "_next/data/(.*)"),
        dest: import_path5.default.join("/", entryDirectory, "404"),
        status: 404,
        check: true
      },
      // re-check page routes to map them to the lambda
      ...pageLambdaRoutes,
      // Dynamic routes (must come after dataRoutes as dataRoutes are more
      // specific)
      ...isSharedLambdas ? mergedDynamicRoutesLambdaRoutes : dynamicRoutes,
      // routes to call after a file has been matched
      { handle: "hit" },
      // Before we handle static files we need to set proper caching headers
      {
        // This ensures we only match known emitted-by-Next.js files and not
        // user-emitted files which may be missing a hash in their filename.
        src: import_path5.default.join(
          "/",
          entryDirectory,
          `_next/static/(?:[^/]+/pages|pages|chunks|runtime|css|image|media|${escapedBuildId})/.+`
        ),
        // Next.js assets contain a hash or entropy in their filenames, so they
        // are guaranteed to be unique and cacheable indefinitely.
        headers: {
          "cache-control": `public,max-age=${MAX_AGE_ONE_YEAR},immutable`
        },
        continue: true,
        important: true
      },
      // error handling
      ...isLegacy ? [] : [
        // Custom Next.js 404 page
        { handle: "error" },
        ...i18n && (static404Page || hasIsr404Page) ? [
          {
            src: `${import_path5.default.join(
              "/",
              entryDirectory,
              "/"
            )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(/.*|$)`,
            dest: "/$nextLocale/404",
            status: 404,
            caseSensitive: true
          },
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: `/${i18n.defaultLocale}/404`,
            status: 404
          }
        ] : [
          isSharedLambdas ? {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            // if static 404 is not present but we have pages/404.js
            // it is a lambda due to _app getInitialProps
            dest: import_path5.default.join(
              "/",
              static404Page ? static404Page : pageLambdaMap[page404Path]
            ),
            status: 404,
            ...static404Page ? {} : {
              headers: {
                "x-nextjs-page": page404Path
              }
            }
          } : {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            // if static 404 is not present but we have pages/404.js
            // it is a lambda due to _app getInitialProps
            dest: static404Page ? import_path5.default.join("/", static404Page) : import_path5.default.join(
              "/",
              entryDirectory,
              hasPages404 && lambdas[import_path5.default.join("./", entryDirectory, "404")] ? "404" : "_error"
            ),
            status: 404
          }
        ],
        // static 500 page if present
        ...!hasStatic500 ? [] : i18n ? [
          {
            src: `${import_path5.default.join(
              "/",
              entryDirectory,
              "/"
            )}(?<nextLocale>${i18n.locales.map((locale) => (0, import_escape_string_regexp3.default)(locale)).join("|")})(/.*|$)`,
            dest: "/$nextLocale/500",
            status: 500
          },
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: `/${i18n.defaultLocale}/500`,
            status: 500
          }
        ] : [
          {
            src: import_path5.default.join("/", entryDirectory, ".*"),
            dest: import_path5.default.join("/", entryDirectory, "/500"),
            status: 500
          }
        ]
      ]
    ],
    framework: { version: nextVersion }
  };
};
var prepareCache = async ({
  workPath,
  repoRootPath,
  entrypoint,
  config = {}
}) => {
  (0, import_build_utils3.debug)("Preparing cache...");
  const entryDirectory = import_path5.default.dirname(entrypoint);
  const entryPath = import_path5.default.join(workPath, entryDirectory);
  const outputDirectory = import_path5.default.join("./", config.outputDirectory || ".next");
  const nextVersionRange = await getNextVersionRange(entryPath);
  const isLegacy = nextVersionRange && isLegacyNext(nextVersionRange);
  if (isLegacy) {
    return {};
  }
  (0, import_build_utils3.debug)("Producing cache file manifest...");
  const isMonorepo = repoRootPath && repoRootPath !== workPath;
  const cacheBasePath = repoRootPath || workPath;
  const cacheEntrypoint = import_path5.default.relative(cacheBasePath, entryPath);
  const cache = {
    ...await (0, import_build_utils3.glob)(
      isMonorepo ? "**/node_modules/**" : import_path5.default.join(cacheEntrypoint, "node_modules/**"),
      cacheBasePath
    ),
    ...await (0, import_build_utils3.glob)(
      import_path5.default.join(cacheEntrypoint, outputDirectory, "cache/**"),
      cacheBasePath
    )
  };
  (0, import_build_utils3.debug)("Cache file manifest produced");
  return cache;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MAX_AGE_ONE_YEAR,
  build,
  htmlContentType,
  prepareCache,
  version
});
/*! Bundled license information:

bytes/index.js:
  (*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   *)
*/
